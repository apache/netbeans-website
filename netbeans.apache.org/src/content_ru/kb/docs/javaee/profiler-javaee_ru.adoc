// 
//     Licensed to the Apache Software Foundation (ASF) under one
//     or more contributor license agreements.  See the NOTICE file
//     distributed with this work for additional information
//     regarding copyright ownership.  The ASF licenses this file
//     to you under the Apache License, Version 2.0 (the
//     "License"); you may not use this file except in compliance
//     with the License.  You may obtain a copy of the License at
// 
//       http://www.apache.org/licenses/LICENSE-2.0
// 
//     Unless required by applicable law or agreed to in writing,
//     software distributed under the License is distributed on an
//     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//     KIND, either express or implied.  See the License for the
//     specific language governing permissions and limitations
//     under the License.
//

= Profiling an Enterprise Application in IDE NetBeans
:jbake-type: tutorial
:jbake-tags: tutorials 
:jbake-status: published
:icons: font
:syntax: true
:source-highlighter: pygments
:toc: left
:toc-title:
:description: Profiling an Enterprise Application in IDE NetBeans - Apache NetBeans
:keywords: Apache NetBeans, Tutorials, Profiling an Enterprise Application in IDE NetBeans

IDE NetBeans includes a powerful profiling tool that can provide important information about the runtime behavior of enterprise applications. С помощью средства профилирования можно легко следить за состояниями потоков и получать данные о производительности ЦП и использовании приложением памяти.

В этом документе говорится об использовании средства профилирования для получения данных о простых приложениях, которые развернуты на сервере приложений как файлы WAR. В документе показано, как использовать среду IDE, чтобы получить результаты профилирования следующих показателей.

* Поведение приложения при выполнении
* Время ЦП, используемое методами приложения
* Создание объекта

При развертывании приложения на локальном зарегистрированном сервере Tomcat, сервере GlassFish или установке JBoss приложение можно профилировать всего лишь несколькими нажатиями кнопок мыши и почти не настраивая. Процесс профилирования проекта очень похож на использование команды "Выполнить" в среде IDE. Можно с легкостью начать профилирование проектов приложений или отдельных веб-модулей и модулей EJB, выбрав пункт "Профиль" > "Профилировать главный проект" главного меню.


* Создание примера проекта

*Для работы с этим учебным курсом требуется следующее программное обеспечение и ресурсы.*

|===
|Программное обеспечение или материал |Требуемая версия 

|link:https://netbeans.org/downloads/index.html[+IDE NetBeans+] |7.3, 7.4, 8.0, пакет Java EE 

|link:http://www.oracle.com/technetwork/java/javase/downloads/index.html[+Комплект для разработчика на языке Java (JDK)+] |JDK 7 или 8 

|Сервер GlassFish |3.1, 4.0 
|===

[NOTE]
====
* При первом использовании профилировщика рекомендуется ознакомиться с разделом link:../java/profiler-intro.html[+Введение в профилирование приложений Java в IDE NetBeans+], который содержит обзор задач отслеживания и профилирования.
* Если используется IDE NetBeans 7.2 или более ранняя версия, см. раздел link:../../72/javaee/profiler-javaee.html[+Профилирование корпоративных приложений в IDE NetBeans 7.2+]
* В этом документе говорится о профилировании корпоративного приложения, развернутого на сервере GlassFish. Предпочтительная и самая простая настройка профилирования во время разработки корпоративных или веб-приложений — запуск приложения на локальных серверах Tomcat, GlassFish или JBoss.
====


== О профилировании приложений в среде IDE

При профилировании корпоративных приложений в большинстве случаев требуется анализировать производительность приложения для получения времени выполнения методов проекта. Это позволяет исправить ошибки приложения и улучшить его производительность. В некоторых случаях требуется также получить данные по использованию памяти для оптимизации сбора мусора.

Процесс профилирования корпоративных приложений, модулей EJB и веб-приложений по сути такой же, как выполнение проекта с помощью команды "Выполнить". После выбора задачи профилирования и настройки параметров нажмите "Выполнить" в диалоговом окне "Выбрать задачу профилирования" для запуска сессии профилирования. При запуске сеанса профилирования среда IDE выполняет следующие действия:

* компилирует приложение;
* запускает целевой сервер в режиме профилирования;
* развертывает приложение;
* прикрепляется к приложению;
* открывает веб-страницу веб-браузера (если это указано в свойствах проекта);
* открывает вкладку "Текущие результаты профилирования".

В зависимости от параметров профилирования среда IDE может немедленно вывести результаты профилирования во вкладке "Текущие результаты профилирования". В некоторых случаях, например, при указании профилирования корневых методов, может оказаться необходимым произвести некоторые действия в веб-браузере, прежде чем будут показаны результаты.


=== Профилирование проектов корпоративных приложений

Корпоративное приложение, которое создается в среде IDE, может быть и веб-приложением, которое развертывается на сервере приложений как архивный веб-файл (WAR), и проектом корпоративного приложения, содержащим веб-приложение и дополнительные библиотеки, развернутым на сервере как архивный файл корпоративного приложения (EAR).

Если необходимо развернуть приложение как архивный файл EAR, создайте проект корпоративного приложения NetBeans, который содержит подпроекты и библиотеки. Проект корпоративного приложения не содержит ни одного исходного файла, только информацию о сборке и развертывании приложения и о метаданных настроек сервера. Бизнес-логика приложения проекта обычно содержится в модуле EJB, а исходный код уровня представления — в веб-модуле.

При наличии всех исходных файлов проекта корпоративного приложения самым лучшим и простым методом профилирования является профилирование всего проекта корпоративного приложения целиком, а не его подпроектов. Это позволяет удостовериться, что весь необходимый код был скомпилирован и развернут, а приложение работает корректно. Чтобы профилировать проект корпоративного приложение, выполните следующие действия:

* Если проект является главным проектом, нажмите кнопку "Профилировать главный проект" на панели инструментов или выберите "Профилирование" > "Профилировать главный проект" в главном меню.
* Щелкните правой кнопкой мыши проект приложения в окне проектов и выберите "Профилировать" из всплывающего меню.

При профилировании корпоративного приложения можно увеличить корректность результатов профилирования, указав профилирование корневых методов и используя фильтры инструментирования для ограничения количества классов, которые будут профилированы. Это поможет сократить влияние дополнительного расхода ресурсов процессом профилирования на производительность приложения и увеличит корректность результатов профилирования.

При запуске корпоративных приложений, в отличие от веб-приложений, браузер не всегда открывается автоматически. (Это зависит от настройки проекта.) Это означает, что в некоторых случаях понадобится вручную запустить внешний интерфейс веб-приложения и затем вызвать код, такой как бизнес-логика в модуле EJB, из веб-браузера.


=== Профилирование модуля EJB и подпроектов веб-модулей

Сеанс профилирования можно запустить из любого модуля EJB или веб-модуля проекта. В этом случае можно выбрать один из подходов:

* *Профилирование модуля EJB.* Если использовать этот подход, возможно, придется вызывать код приложения вручную с веб-браузера или другого клиента, поскольку проекты модулей EJB, как правило, не настроены для открытия веб-браузера. После того, как модуль EJB развернут на сервере, необходимо вызвать его код точно так же, как при отладке или оценке функциональности приложения. Обычно это делается запуском внешнего интерфейса веб-приложения и выполнения действий в веб-браузере.
* *Профилирования веб-модуля.* Если использовать этот подход, необходимо скомпилировать и развернуть модуль EJB на сервер до профилирования проекта веб-модуля. Обычно код EJB выполняется в результате некоторых действий пользователя в браузере. Если эти действия выполнены/обработаны кодом веб-приложения, код EJB будет виден в дереве вызовов.


== Создание примера проекта

В этом документе говорится о профилировании демонстрационного приложения ServletStateless. Приложение ServletStateless — это простое корпоративное веб-приложение, которое включено в среду IDE как демонстрационный проект.

Для создания приложения ServletStateless выполните следующие действия:

1. Выберите 'Файл' > 'Создать проект' (Ctrl-Shift-N; ⌘-Shift-N в Mac) в главном меню.
2. В мастере создания проекта выберите категорию "Примеры > Java EE".
3. Выберите проект "Servlet Stateless". Нажмите кнопку "Далее".
4. Укажите местоположение проекта. Нажмите кнопку "Завершить".

После нажатия кнопки "Готово" среда IDE создает демонстрационный проект ServletStateless. Проект ServletStateless отображается в окне 'Проекты'.

[NOTE]
====
* По умолчанию, при использовании среды IDE для профилирования проекта, IDE выполнит профилирование проекта, выбранного в окне 'Проекты', если открыто более одного проекта. Если выбрать 'Выполнить' > 'Задать главный проект' в главном меню и задать проект как главный, то профилирование главного проекта выполняется по умолчанию. Можно щелкнуть правой кнопкой мыши узео проекта в окне 'Проекты' и выбрать 'Профиль' во всплывающем меню.
* Если необходимо выполнить профилирование такого файла, как страница  ``.jsp``  или сервлет, щелкните правой кнопкой мыши файл и выберите 'Профилировать файл' во всплывающем меню. Процесс профилирования такой же, как при выборе "Профилирование главного проекта", но при запуске сессии профилирования в браузере откроется выбранная страница вместо страницы проекта по умолчанию.
====


== Наблюдение за приложением

Наблюдение за приложением позволяет получать информацию о свойствах целевой виртуальной машины Java, включая активность потоков и распределение памяти. Поскольку наблюдение за приложением не требует большого дополнительного расхода ресурсов, можно запускать приложение в этом режиме в течение длительного времени. При выборе задачи наблюдения целевое приложение запускается без каких-либо инструментов.

Для отслеживания приложения ServletStateless выполните следующие действия:

1. Выберите 'Выполнить' > 'Задать главный проект' > ServletStateless для задания проекта как главного.

При настройке проекта как главного, имя проекта будет выделено полужирным в окне 'Проекты'.



. Выберите "Профиль > Профилировать главный проект" в главном меню.

NOTE:  Выберите JDK 1.7 или JDK 1.8 при отображении запроса на выбор платформы Java для профилирования.



. Выберите "Наблюдение" в диалоговом окне "Выбор задачи профилирования".


. Нажмите кнопку "Выполнить".

NOTE:  Если средство профилирования не использовалось ранее, может быть отображен запрос на калибровку средства профилирования до выбора 'Выполнить'. Дополнительные сведения о калибровке профилировщика см. раздел link:../java/profiler-intro.html#calibrate[+Первое использование профилировщика+] в link:../java/profiler-intro.html[+Введение в профилирование приложений Java в IDE NetBeans+].

По кнопке "Выполнить" среда IDE собирает приложение, запускает сервер в режиме профилирования, а затем разворачивает приложение на сервере. Затем среда IDE прикрепляется к приложению и запускает извлечение данных.

Данные о потоках целевой виртуальной машины Java отображаются на вкладке "Потоки". Вкладка "Потоки" отображает данные по всем потокам, как серверным, так и потокам приложения.

Дополнительную информацию о наблюдении можно получить, нажав кнопку "Обзор телеметрии" в окне "Профилировщик", чтобы открылось окно "Обзор телеметрии виртуальной машины". Окно "Обзор телеметрии виртуальной машины" позволяет быстро просмотреть данные наблюдения в реальном времени. Щелкнув два раза график в окне "Обзор телеметрии виртуальной машины", можно открыть более крупную версию изображения графика.

При наблюдении за корпоративным приложением графики Memory (Heap) и Memory (GC) (график "кучи" памяти и график использования памяти при сборке мусора) помогают быстро проследить использование памяти приложением. Наведя указатель мыши на график, можно получить подсказку с более подробной информацией. Равномерное увеличение размера "кучи" или числа сохранившихся поколений указывает на утечку памяти. При подозрении на утечку памяти следует профилировать использование памяти приложением.

image::images/monitor-memory-telemetry.png[title="График памяти (GC), на котором отображаются данные GC"] 


== Анализ производительности приложения

Задача анализа производительности ЦП позволяет увидеть данные производительности ЦП на уровне методов (время запуска) и количество вызовов методов из приложения. Можно предпочесть анализ производительности всего приложения или выбрать корень профилирования, чтобы применить профилирование только для части кода приложения.

image::images/sample-task.png[title="Режим образца приложения выбран на панели ЦП диалогового окна 'Выбор задачи профилирования'"]

При запуске задачи анализа производительности ЦП в окне "Задачи профилирования" можно выбрать, какую часть приложения профилировать, отметив один из перечисленных параметров:

* *Быстрый (образец).* В этом режиме IDE создает образец приложения и периодически создает трассировку стека. Этот вариант менее точен, чем методы инструментирования, но вызывает меньший дополнительный расход ресурсов. Этот вариант может помочь выбрать методы для инструментирования.
* *Расширенный (инструментация).* В этом режиме методы профилируемого приложения инструментируются. Среда IDE регистрирует вход и выход потоков в методы проекта, позволяя отслеживать время, затрачиваемое на каждый метод. При входе в метод потоки создают событие "вход в метод". При выходе из метода потоки создают соответствующее событие "выход из метода". Записываются метки времени обоих событий. Эти данные обрабатываются в реальном времени.

Можно выбрать инструментирование всех методов приложения или ограничить инструментирование поднабором кода приложения, указав один или несколько *корневых методов*. Определение корневых методов может сильно уменьшить дополнительный расход ресурсов на профилирование. Корневой метод — это метод, класс или пакет в исходном коде, который можно указать как корень обработки. Данные профилирования собираются при входе и выходе одного из потоков приложения из корня обработки. До входа одного из потоков приложения в корневой метод данные профилирования не собираются. Корневой метод можно указать, используя всплывающее меню в исходном коде, или щелкнув *настроить*, чтобы открыть диалоговое окно "Изменить корневые методы профилирования".

*Советы про профилированию веб-приложений*

* В дополнение к основным классам Java, корпоративные приложения обычно вызывают ряд методов в классах на целевом сервере. По этой причине важно настроить фильтр для ограничения количества исходного кода, которое необходимо инструментировать. Рекомендуется использовать фильтр *Профилировать только классы проекта* при профилировании корпоративных приложений.
* Результаты профилирования собираются сразу при запуске сеанса профилирования. Если при использовании метода 'Расширенный' не указано профилирования ни одного корневого метода, некоторые интересные данные можно получить сразу же после запуска сервера, а именно прослушивателей веб-приложений и инициализации фильтров. Если указано профилирование неких корневых методов, эти данные, скорее всего, получены не будут. Их получение зависит от выбранных корневых методов.
* Обычно данные прослушивателей и фильтров не бывают интересными, поэтому для их удаления можно нажать кнопку "Сбросить собранные результаты". Первые полезные данные собираются после того, как в результате некоторого действия в веб-браузере вызывается некоторый код, обычно это отображение страницы JSP, которая использует JavaBeans и/или избранные теги, или обработка методов  ``doGet`` / ``doPost``  сервлета. Следует отметить, что данные, которые собираются при первом запуске приложения, обычно отражают только поведение веб-приложения при запуске.
* Если страница JSP отображается впервые, она сервером внутренне компилируется в сервлет, что влияет на дерево вызовов и подсчет времени обработки метода. К тому же поведение кода сервлетов и других приложений при первом запуске может слегка отличаться от их поведения при производственной эксплуатации, когда они запущены постоянно. Для получения данных измерений, которые бы лучше характеризовали производительность приложения, перед измерением любых временных показателей следует увеличить рабочую нагрузку на профилируемый код (не должно повлиять на деревья вызовов). Для увеличения рабочей нагрузки можно использовать генераторы нагрузки. (Дополниетльные сведения см. в разделе link:../java/profile-loadgenerator.html[+Использование генератора нагрузки в IDE NetBeans+]). Средства кэширования у различных браузеров также могут повлиять на производительность.

NOTE:  При профилировании веб-приложений на сервере приложений GlassFish на компьютере под управлением Windows при запуске сервера для профилирования может произойти ошибка, если путь установки IDE NetBeans содержит пробелы (как например при установке в каталог по умолчанию  ``C:\Program Files\netbeans-7.4`` ). В качестве временного решения можно установить или скопировать каталог установки IDE NetBeans в местоположение, путь к которому не содержит пробелов (например,  ``C:\netbeans-7.4`` ).


=== Опрос приложения

Вариант "Быстрый" используется для обзора режима работы всего приложения в целом, когда нет необходимости в инструментировании методов. В режиме опроса приложения профиль Quick периодически снимает данные трассировки. Расход системных ресурсов в режиме профилирования 'Быстрый' меньше, чем в режиме профилирования 'Расширенный'.

В следующем упражнении будет проанализирована производительность приложения в режиме профилирования 'Быстрый'.

1. Остановите сеанс наблюдения, нажав кнопку "Стоп" в меню "Профилирование".
2. Выберите "Профиль > Профилировать главный проект" в главном меню.
3. Выберите "ЦП" в диалоговом окне "Выбор задачи профилирования".
4. Выберите режим *Быстрый (образец)*.
5. Выберите *Профилировать только классы проекта* из раскрывающегося списка фильтров. Нажмите кнопку "Выполнить".

NOTE:  Этот фильтр ограничит классы, инструментированные для классов, найденных в проекте корпоративного приложения. Нажмите кнопку *Показать значение фильтра*, чтобы увидеть список отфильтрованных классов.

image::images/sample-task.png[title="Режим образца приложения выбран на панели ЦП диалогового окна 'Выбор задачи профилирования'"]

По шкале в диалоговом окне можно заметить, что трата системных ресурсов относительно невысока.



. Нажмите кнопку "Текущие результаты профилирования" в окне "Профилирование", чтобы открыть вкладку текущих результатов профилирования.

image::images/sample-task-results.png[title="Результаты режима 'Образцы приложений'"]

На вкладке "Текущие результаты профилирования" показано время выполнения метода  ``service``  для сервлета из класса  ``Servlet2Stateless``  и то, что метод был вызван один раз.


=== Инструментирование всех методов

В режиме "Профилирование приложения" все методы приложения инструментируются. Хотя это более точный метод изменения производительности приложения, трата системных ресурсов при профилировании выше, чем в режиме опроса. Можно настроить профилирование корневых методов так, чтобы ограничить количество инструментируемых методов и уменьшить загрузку при профилировании. Для некоторых приложений указание корневого метода может быть единственным способом получения подробных и/или реалистичных данных производительности, поскольку профилирование всего приложения может создать так много данных профилирования, что приложение станет непригодным к использованию, или даже произойдет отказ приложения.

В следующем упражнении будет проанализирована производительность приложения с помощью инструментирования всех его методов.

1. Остановите сеанс наблюдения, нажав кнопку "Стоп" в меню "Профилирование".
2. Выберите "Профиль > Профилировать главный проект" в главном меню.
3. Выберите "ЦП" в диалоговом окне "Выбор задачи профилирования".
4. Выберите режим *Расширенный (инструментарий)*.
5. Выберите *Профилировать только классы проекта* из раскрывающегося списка фильтров. Нажмите кнопку "Выполнить".

image::images/advanced-cpu-task.png[title="Режим профилирования приложения выбран на панели ЦП диалогового окна 'Выбор задачи профилирования'"]

По шкале в диалоговом окне можно заметить, что трата системных ресурсов выше, чем в режиме быстрого профилирования.



. Нажмите кнопку "Текущие результаты профилирования" в окне "Профилирование", чтобы открыть вкладку текущих результатов профилирования.

На вкладке "Текущие результаты профилирования" показано время выполнения методов  ``init``  и  ``service``  для сервлета из класса  ``Servlet2Stateless`` , и то, что каждый из методов был вызван один раз. Метод  ``init``  в классе  ``StatelessSessionBean`` также был вызван.

image::images/cpu-pane1-results.png[title="Результаты режима 'Профилирование приложений'"]

NOTE:  По умолчанию режим автоматического обновления активен, что обеспечивает обновление отображаемых данных каждые несколько секунд. Можно включать или отключать режим автоматического обновления, нажав кнопку "Автообновление" на панели инструментов.

Для повышения удобочитаемости собранные данные можно фильтровать, используя фильтр "Результаты" в списке "Просмотр горячих точек" окна "Текущие результаты профилирования". Фильтр "Результаты" формирует выборку только по результатам и не затрагивает обрабатываемые классы. Используя фильтр "Результаты", можно отбирать результаты, которые соответствуют определенному шаблону. Для фильтрации можно использовать также более сложные регулярные выражения. Данные фильтруются по именам пакетов/классов/методов, в точности, как они появляются в первой колонке таблицы результатов. Можно определить более, чем один шаблон фильтрации, разделяя их пробелом или точкой с пробелом.



. Введите свое имя в поле в веб-браузере и нажмите "Отправить запрос".

image::images/cpu-pane1-results1.png[title="Результаты режима 'Профилирование приложений'"]

По нажатию кнопки "Отправить запрос"данные на вкладке "Текущие результаты профилирования" обновляются для отражения действий в веб-браузере. Нажатие кнопки запускает метод  ``sayHello``  в классе  ``StatelessSessionBean``  и вновь вызывает метод  ``init`` .  ``Служебный``  метод для сервлета из  ``Servlet2Stateless``  также был вызван вновь. Вкладка "Текущие результаты профилирования" также показывает, сколько времени было затрачено в каждом из методов.

Чтобы увидеть графическое представление относительного времени, затраченного в различных областях приложения (сервлетах, прослушивателях и т.д.), нажмите кнопку "Развернуть". Можно нажать на сам график, чтобы развернуть результаты профилирования на экран.

image::images/drill-down.png[title="График перехода по иерархии относительного времени, потраченного в сервлетах в приложении"]

Инструментирование приложения всегда затрачивает некоторое количество системных ресурсов на профилирование. В таком простом приложении затрата системных ресурсов незаметна, но в сложных приложениях она может быть весьма значительной. Можно уменьшить затраты системных ресурсов ограничением количества профилируемых классов, выбрав профилирование корневого метода.


=== Использование профилирования корневых методов

В следующем упражнении будет профилирована только часть приложения. Этот метод профилирования используется, если известны потенциальные "узкие места" приложения, касающиеся производительности, или если необходимо профилировать определенную часть кода, например, один из нескольких сервлетов. При этом методе на профилирование обычно затрачивается гораздо меньше системных ресурсов, чем при методе инструментирования всего приложения. При инструментировании только с части приложения собираются и отображаются только интересующие данные.

Чтобы профилировать часть приложения, необходимо назначить один или более корневых методов профилирования. Среда IDE инструментирует только те методы, которые вызываются потоком, входящим в корневой метод профилирования. Например, если назначить метод  ``sayHello``  в классе  ``StatelessSessionBean``  корневым методом и использовать фильтр "Профилировать только классы проекта", среда IDE запустит методы инструментирования при вызове метода, когда в него войдет поток приложения. В этом приложении конструктор  ``init``  не будет инструментирован, поскольку он вызывается перед  ``sayHello`` .

image::images/profileroot-sayhello-project.png[title="График перехода по иерархии относительного времени, потраченного в сервлетах в приложении"]

Если выбрать фильтр "Профилировать все классы", среда IDE инструментирует все методы, вызванные  ``sayHello`` , включая базовые классы языка Java.

image::images/profileroot-sayhello-all.png[title="График перехода по иерархии относительного времени, потраченного в сервлетах в приложении"]

NOTE:  В более комплексных приложениях может потребоваться указание нескольких корневых методов. В качестве корней профилирования можно выбрать отдельные методы, целые классы и пакеты.

Чтобы указать корень профилирования и проанализировать производительность приложения, выполните следующие действия.

1. Остановите предыдущие сессии профилирования (если они все еще запущены), нажав кнопку "Завершить" в окне "Профилирование".
2. Выберите "Профиль > Профилировать главный проект" в главном меню.
3. Выберите "ЦП" в диалоговом окне "Выбор задачи профилирования".
4. Выберите режим *Расширенный (инструментарий)*.
5. Нажмите кнопку *настроить*, чтобы открыть диалоговое окно "Изменение корневых методов профилирования".

Чтобы профилировать часть приложения необходимо сначала определить корневые методы. После выбора корневого метода профилирование будет применяться только к тем методам, которые вызываются потоком, входящим в корень профилирования.



. В диалоговом окне "Изменить корневые методы профилирования" выберите "Вид веб-приложения" в раскрывающемся списке "Выбрать вид".


. Разверните узел ServletStateless и выберите метод  ``service``  в пакете сервлетов. Нажмите кнопку "ОК".

image::images/edit-profiling-roots.png[title="Представление веб-приложения в диалоговом окне 'Изменение корневых методов профилирования'"]

В противном случае можно выбрать "Просмотр пакета", чтобы увидеть все исходные пакеты приложения и выбрать метод  ``service``  из класса  ``Servlet2Stateless``  пакета  ``servlet.stateless`` .

image::images/edit-profiling-roots-pkg.png[title="Представление пакета в диалоговом окне 'Изменение корневых методов профилирования'"]

NOTE:  Обратите внимание, что конструктор  ``Servlet2Stateless``  не выбран. Диалог "Изменить корневые методы профилирования" используется, чтобы применять инструментирование только к определенным методам класса. Если нет необходимости применять инструментирование только к определенным методам, можно использовать представление пакетов, чтобы выбрать весь класс или пакет. Например, если выбрать класс  ``Servlet2Stateless``  в представлении пактов диалога "Изменить корневые методы профилирования", среда IDE инструментирует конструктор  ``init``  и метод  ``service`` .

Если нажать кнопку "Дополнительно", можно увидеть, что метод  ``service``  представлен в диалоговом окне "Изменить корневые методы профилирования (Дополнительно)", как единственный корневой метод. Чтобы явно определить метод, добавив ему подпись и класс, нажмите кнопку "Добавить".

image::images/edit-profilingroots-pkg-adv.png[title="Диалоговое окно 'Изменение корневых методов профилирования' (Расширенное)"]



. Нажмите кнопку "ОК" в диалоговом окне "Изменить корневые методы профилирования".

В диалоговом окне "Выбрать задачу профилирования" видно, что режим расширенного профилирования будет запущен с помощью специальных корневых методов профилирования. Чтобы просмотреть и изменить выбранный корневой метод нажмите *Изменить*. Заметим, что затраты системных ресурсов после этих действий ниже, чем была до настройки корневых методов.



. Выберите *Профилировать только классы проекта* из раскрывающегося списка фильтров. Нажмите кнопку "Выполнить".

image::images/advanced-cpu-task-custom.png[title="Режим профилирования приложения выбран с нестандартным корнем профилирования"]

При нажатии кнопки "Запустить" среда IDE собирает и разворачивает приложение и открывает в веб-браузере страницу сервлета.

В среде IDE результаты профилирования показываются на вкладке "Текущие результаты профилирования".

image::images/cpu-pane2-results.png[title="Результаты методов инструментирования с использованием корня профилирования"]

Можно увидеть, что в среде IDE показываются результаты только для метода, определенного как корень профилирования. Поток приложения не вошел больше ни в один из методов приложения после входа в корень профилирования.

Хотя поток приложения выполнил вход в другие методы после входа в корень профилирования, эти методы не отображаются, поскольку фильтр инструментирования отбирает для инструментирования только те классы, которые являются частью проекта.



. Введите свое имя в поле в веб-браузере и нажмите "Отправить запрос".

image::images/cpu-pane2-results1.png[title="Результаты методов инструментирования с использованием корня профилирования после вызова метода sayHello"]

По нажатию кнопки "Отправить запрос"данные на вкладке "Текущие результаты профилирования" обновляются для отражения действий в веб-браузере. Нажатие кнопки вызывает метод  ``sayHello``  класса  ``StatelessSessionBean``  один раз. Метод  ``service``  также заново вызывается.

Результирующие данные, которые отражают производительность приложения, могут не совсем точно описывать производительность приложения, работающего уже некоторое время. Один из способов сымитировать поведение веб-приложения в более реальных условиях — запустить сценарий генератора загрузки.



. Повторите в браузере предыдущее действие несколько раз, затем нажмите "Сбросить результаты" на вкладке "Текущие результаты профилирования" для удаления результатов.


. После сброса результатов профилирования введите свое имя и нажмите "Отправить запрос" еще раз.

image::images/cpu-pane2-results2.png[title="Результаты методов инструментирования с использованием корня профилирования после вызова метода sayHello"]

При взгляде на результаты профилирования в большинстве случаев заметно, что производительность приложения улучшилась.


=== Использование инструментальных фильтров

При анализе производительность ЦП можно уменьшить затраты системных ресурсов с помощью инструментального фильтра, который отберет для профилирования интересующую части кода приложения. Фильтр отбирает пакеты/классы для инструментирования. Можно выбрать фильтр из следующего списка фильтров по умолчанию или создать индивидуальный.

* *Профилирование всех классов.* Если выбрать этот фильтр при профилировании веб-приложений или корпоративных приложений, инструментируются все классы, включая основные классы Java и классов серверов. Этот фильтр необходимо использовать с осторожностью, поскольку инструментирование такого большого количества классов может повлечь *очень* значительные затраты системных ресурсов.
* *Профилирование только классов проекта.* При профилировании корпоративного приложения рекомендуется использовать именно этот фильтр, чтобы инструментировать только классы проекта. Серверные классы не будут инструментированы.
* *Профилирование классов проектов и подпроектов.* При профилировании проекта корпоративного приложения, которое содержит подпроекты, такие как веб-приложения, модули EJB или библиотеки классов, можно выбрать этот фильтр, чтобы ограничить инструментированного кода для классов в подпроектах.

Можно создать индивидуальный фильтр, который будет использоваться в определенном проекте или для определенных типов профилирования. Например, если требуется использовать инструментальный фильтр для профилирования веб-приложений на сервере Oracle WebLogic, можно нажать кнопку "Изменить набор фильтров" и создать набор фильтров, которые будут исключать из процесса инструментирования базовые классы языка Java, классы Oracle WebLogic и классы NetBeans (удобно при отключенном мониторинге HTTP). Набору фильтров можно дать название, как, например "Только для веб-приложений WebLogic", и затем выбирать этот фильтр из выпадающего списка фильтров при профилировании приложения, развернутого на сервере WebLogic.

image::images/custom-filter.png[title="диалоговое окно, которое отображается при профилировании проекта в первый раз"]

Можно задать простой инструментальный фильтр, выбрав "Быстрый фильтр" из выпадающего списка фильтров, который откроет диалоговое окно "Установить быстрый фильтр". Затем можно быстро изменить список пакетов или классов для инструментирования. Это создаст быстрый фильтр, который затем можно выбирать из выпадающего списка фильтров.

image::images/set-quick-filter.png[title="диалоговое окно, которое отображается при профилировании проекта в первый раз"]

Более подробную информацию об определении и использовании инструментальных фильтров можно найти в документации по профилированию, поставляемой с IDE.


== Анализ использования памяти приложением

С помощью средства профилирования, встроенного в IDE, можно анализировать, сколько памяти использует корпоративное приложение, чтобы получить подробные данные по размещению объектов и сборке мусора. Задач "Анализ использования памяти" предоставляет данные об объектах, выделенных в целевом приложении, таких как число, тип и расположение выделенных объектов.

При профилировании использования памяти нет возможности задать корневой метод профилирования и/или инструментальные фильтры, поэтому отслеживаются все объекты, созданные во время работы сервера. На сложных серверах приложений это может привести к серьезному потреблению памяти и затратам системных ресурсов на профилирование. Поэтому, прежде чем запускать этот тип профилирования, необходимо иметь в виду потенциальные ограничения работы компьютера. Чтобы уменьшить затраты системных ресурсов на профилирование, можно изменить его настройки так, чтобы профилировался только каждый десятый объект. Также можно отключить (ограничить) запись трассировки стеков для размещения объектов.

При профилировании корпоративного приложения для поиска утечек памяти, полезно использовать метрики "сохранившихся поколений". Трассировкой числа различных циклов сборки мусора сохранившихся поколений, инструмент профилирования может найти утечку памяти заранее, пока приложение не использовало значительный объем памяти.

Для анализа производительности памяти необходимо выбрать объем данных для получения, выбрав один из следующих вариантов.

* *Быстро.* Если выбран этот вариант, профилировщик создаст образец приложения для предоставления данных, которые ограничены живыми объектами. Живые объекты - все доступные (и недоступные), не востребованные повторно сборщиком мусора (Garbage Collector). Этот параметр отслеживает только живые объекты и не отслеживает распределение при использовании инструментов. Если выбран этот вариант, невозможно регистрировать трассировки стеков или использовать точки профилирования. Этот вариант требует значительно меньших затрат, чем 'Дополнительно'.
* *Дополнительно.* Если выбран этот вариант, можно получить информацию о количестве, типе и местоположении выделенных объектов. Выделенные объекты - это объекты, созданные с момента запуска приложения (или с момента последнего сброса собранных результатов в профилировщике). Все классы, которые в настоящее время загружены целевым JVM (и каждый новый класс после его загрузки) являются инструментами для получения информации о распределении объектов. Этот вариант необходимо выбрать, если нужно использовать точки профилирования при анализе памяти или если нужно выполнить запись стека вызовов. Этот вариант требует больших затрат на профилирование по сравнению с вариантом 'Быстро'.

Если вы выберете вариант 'Дополнительно', вы также можете установить следующие параметры.

* *Запись полного образа жизни объекта.* Выберите этот вариант, чтобы записать всю информацию по каждому объекту, в том числе количество выживших поколений.
* *Запись трассировки стека для распределения.* Выберите этот вариант, чтобы записать полный стек вызовов. Этот вариант позволяет просматривать дерево обратных вызовов для вызовов методов при просмотре снимка памяти.
* *Использование определенных точек профилирования.* Выберите этот вариант, чтобы включить поддержку точек профилирования. Отключенные точки профилирования игнорируются. При отмене этого параметра все точки профилирования в проекте игнорируется.

Измеритель 'Издержки' в окне 'Выбор задачи профилирования' дает приблизительное представление об увеличении или уменьшении издержек на профилирование в соответствии с выбранными параметрами профилирования.

Используем среду IDE для анализа производительности памяти корпоративного приложения. Если необходимо получать информацию о выживших поколениях, необходимо выбрать вариант *Дополнительно*. Кроме того, если необходимы данные только о живых объектах, можно выбрать вариант *Быстро*.

1. Остановите предыдущие сессии профилирования (если они все еще запущены), нажав кнопку "Завершить" в окне "Профилирование".
При нажатии "Остановить" среда IDE отсоединяется от приложения.


. Выберите "Профиль > Профилировать главный проект" в главном меню.


. Выберите *Память* в диалоговом окне "Выбрать задачу профилирования".


. Выберите *Дополнительно*.


. Выберите *Запись полного жизненного цикла объекта* для получения данных о выживании поколений.

NOTE:  При выборе этого параметра уровень затрат системных ресурсов значительно повысится. При профилировании корпоративного приложения может понадобиться увеличить размер памяти, используемой IDE, из-за количество собранных данных.



. Снимите отметку с параметра *Использовать определенные точки профилирования* (если он был отмечен). Нажмите кнопку "Выполнить".

image::images/profile-memory-advanced.png[title="Диалоговое окно 'Выбрать задачу профилированию', в котором поазывается задача и параметры памяти"]

При нажатии кнопки "Выполнить" среда IDE компилирует приложение, запускает сервер в режиме профилирования и разворачивает на нем приложение. Чтобы просмотреть результаты профилирования, нажмите кнопку "Текущие результаты" в окне "Средство профилирования", при этом откроется окно "Текущие результаты". Окно "Текущие результаты" показывает информацию о размере и количестве объектов, находящихся на целевой виртуальной машине Java. В дополнение к объектам, размещенным корпоративным приложением, в результатах показываются все объекты, размещенные сервером приложений.

image::images/profile-memory-results.png[title="Вкладка 'Результаты профилирования', на которой отображаются результаты профилирования использования памяти"]

По умолчанию результаты сохраняются и отображаются как число выделенных байтов, но можно щелкнуть заголовок столбца, чтобы изменить способ отображения результатов. Также можно выполнить фильтрацию результатов, введя имя класса в поле фильтра под списком.

link:/about/contact_form.html?to=3&subject=Feedback:%20Profiling%20Enterprise%20Applications[+Отправить отзыв по этому учебному курсу+]



== Дополнительные сведения

Этот документ описал основной подход к получению данных измерений при профилировании корпоративного приложение, развернутого на сервере приложений GlassFish.

Для получения более подробной информации о параметрах и функциях профилирования, не рассмотренных в этом документе, воспользуйтесь документацией, входящей в состав среды IDE и доступной из меню "Справка".

Сопутствующая документация приведена в следующих ресурсах.

* link:http://wiki.netbeans.org/wiki/view/NetBeansUserFAQ#section-NetBeansUserFAQ-Profiler[+Часто задаваемые вопросы по профилированию NetBeans+]
Документ содержит часто задаваемые вопросы по профилированию приложений в среде IDE NetBeans
* link:http://wiki.netbeans.org/wiki/view/FaqProfilerProfileFreeForm[+Часто задаваемые вопросы: профилирование проекта произвольной формы+]
* link:../java/profiler-screencast.html[+Демонстрация: точки профилирования, детализированные графики, анализатор кучи+]
Демонстрация некоторых функций профилирования в среде IDE NetBeans
* link:../../../community/magazine/html/04/profiler.html[+Расширенное профилирование: теория на практике+]
* link:http://profiler.netbeans.org/index.html[+profiler.netbeans.org+]
Сайт проекта средства профилирования NetBeans
* link:http://blogs.oracle.com/nbprofiler/[+Блог по средству профилирования NetBeans+]
* link:http://profiler.netbeans.org/mailinglists.html[+Списки рассылки по средству профилирования NetBeans+]
* link:http://profiler.netbeans.org/docs/help/5.5/index.html[+Использование профилировщика NetBeans, версии 5.5+]

<<top,В начало>>

