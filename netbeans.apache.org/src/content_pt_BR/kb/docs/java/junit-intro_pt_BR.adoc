// 
//     Licensed to the Apache Software Foundation (ASF) under one
//     or more contributor license agreements.  See the NOTICE file
//     distributed with this work for additional information
//     regarding copyright ownership.  The ASF licenses this file
//     to you under the Apache License, Version 2.0 (the
//     "License"); you may not use this file except in compliance
//     with the License.  You may obtain a copy of the License at
// 
//       http://www.apache.org/licenses/LICENSE-2.0
// 
//     Unless required by applicable law or agreed to in writing,
//     software distributed under the License is distributed on an
//     "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//     KIND, either express or implied.  See the License for the
//     specific language governing permissions and limitations
//     under the License.
//

= Escrevendo Testes JUnit no NetBeans IDE
:jbake-type: tutorial
:jbake-tags: tutorials 
:jbake-status: published
:icons: font
:syntax: true
:source-highlighter: pygments
:toc: left
:toc-title:
:description: Escrevendo Testes JUnit no NetBeans IDE - Apache NetBeans
:keywords: Apache NetBeans, Tutorials, Escrevendo Testes JUnit no NetBeans IDE

Este tutorial apresenta os princípios básicos da escrita e execução de testes de unidade JUnit no NetBeans IDE. O teste de uma aplicação faz parte do ciclo de desenvolvimento, e a escrita e manutenção de testes de unidade podem ajudar a garantir que os métodos individuais em seu código-fonte funcionem corretamente. O suporte integrado do IDE para o framework de teste de unidades JUnit permite que você crie os testes e conjuntos de testes do JUnit de modo fácil e rápido.

Neste tutorial você cria testes de unidade JUnit 3 e JUnit 4 e conjuntos de testes para um projeto de biblioteca de classe Java. A primeira parte do tutorial mostra como criar testes na JUnit 3. A segunda parte mostra como criar os mesmos testes na JUnit 4 usando anotações da JUnit. Não é necessário completar ambas as partes do tutorial, pois os testes são os mesmos. No entanto, ver como os testes são escritos em ambas as versões permite que você veja algumas das alterações introduzidas na JUnit 4.

Para saber mais sobre a utilização da JUnit, consulte link:http://www.junit.org[+www.junit.org+].


image::images/netbeans-stamp-80-74-73.png[title="O conteúdo desta página se aplica ao NetBeans IDE 7.2, 7.3, 7.4 e 8.0"]


*Para seguir este tutorial, são necessários os recursos e o software a seguir.*

|===
|Software ou Recurso |Versão Necessária 

|link:https://netbeans.org/downloads/index.html[+NetBeans IDE+] |7.2, 7.3, 7.4, 8.0 

|link:http://www.oracle.com/technetwork/java/javase/downloads/index.html[+JDK (Java Development Kit)+] |versão 7 ou 8 

|Projeto JUnitSampleSol |link:https://netbeans.org/projects/samples/downloads/download/Samples/Java/JUnitSampleSol.zip[+download+] 
|===

Para executar as etapas neste tutorial, instale o plug-in do JUnit na Central de Atualização. Você poderá instalar o plug-in do JUnit no gerenciador de Plug-ins se não tiver instalado o plug-in quando instalou o IDE.


== Criando o Projeto

Para concluir este tutorial, você cria primeiramente um projeto de biblioteca de classe Java chamado JUnit-Sample. Após você criar o projeto, copie as duas classes do projeto de amostra JUnitSampleSol para seu projeto JUnit-Sample.


=== Criando o Projeto de Biblioteca de Classe Java

1. Escolha Arquivo > Novo Projeto no menu principal.
2. Selecione Biblioteca de Classe Java em Categoria Java e clique em Próximo.
3. Insira *JUnit-Sample* para o projeto e defina a localização do projeto.
4. Desmarque a opção Usar Pasta Dedicada, se ela estiver selecionada.

Para este tutorial, há pouco motivo para copiar as bibliotecas de projeto em uma pasta dedicada, pois você não precisará compartilhar bibliotecas com outros usuários ou projetos.

Clique em Finalizar.

Na primeira vez em que você criar um teste JUnit, o IDE solicita que você selecione uma versão e, em seguida, adiciona o nó Testar Bibliotecas e a biblioteca do JUnit.


=== Fazendo Download do Projeto da Solução

Você pode fazer o download do projeto de amostra JUnitSampleSol usado neste tutorial das seguintes formas:

* Faça download link:https://netbeans.org/projects/samples/downloads/download/Samples/Java/JUnitSampleSol.zip[+de um arquivo compactado zip do projeto finalizado+].
* Faça o check-out do código-fonte do projeto das Amostras do NetBeans ao executar as etapas a seguir:
1. Escolha Equipe > Subversion > Efetuar check-out no menu principal.
2. Na caixa de diálogo Efetuar Check-out, insira o Repositório URL a seguir:
 ``https://svn.netbeans.org/svn/samples~samples-source-code`` 
Clique em Próximo.


. No painel Pastas para Checkout, clique em Procurar para abrir a caixa de diálogo Procurar Pastas do Repositório.


. Expanda o nó raiz e selecione *samples/java/JUnitSampleSol*. Clique em OK.


. Especifique a Pasta Local dos códigos-fonte. Clique em Finalizar.

Quando você clica em Finalizar, o IDE inicializa a pasta local como um repositório Subversion e verifica os códigos-fonte do projeto.



. Clique em Abrir Projeto na caixa de diálogo exibida quando o check-out for concluído.

Para saber mais sobre a instalação do Subversion, consulte a seção link:../ide/subversion.html#settingUp[+Configurando o Subversion+] no link:../ide/subversion.html[+Guia do Subversion no NetBeans IDE+].

*Observação.* Se você não instalou o plug-in JUnit quando você instalou o IDE, quando você abrir o projeto NetBeans, será solicitado que você instale o plug-in JUnit para resolver a referência para as bibliotecas junit.


=== Criando as Classes Java

Neste exercício você copia os arquivos  ``Utils.java``  e  ``Vectors.java``  do projeto de amostra JUnitSampleSol para o projeto de biblioteca de classes criado.

1. Na janela Projetos, clique com o botão direito do mouse no nó Pacotes de Código-fonte de seu projeto *JUnit-Sample* e escolha Novo > Pacote Java no menu pop-up.
2. Insira *sample* como nome do pacote. Clique em Finalizar.
3. Abra o projeto *JUnitSampleSol* (se já não estiver aberto) e expanda o nó Pacotes de código-fonte na janela Projetos.

image::images/projects-window.png[title="Projetos -junit Amostra e junitsamplesol na janela Projetos"]


. Copie as classes  ``Utils.java``  e  ``Vectors.java``  no projeto JUnitSampleSol, e cole-as no pacote de código-fonte  ``sample``  no JUnit-Sample.

Se você observar o código-fonte das classes, perceberá que  ``Utils.java``  tem três métodos ( ``computeFactorial`` ,  ``concatWords``  e  ``normalizeWord`` ) e que  ``Vectors.java``  tem dois métodos ( ``equals``  e  ``scalarMultiplication`` ). O próximo passo é criar classes de teste para cada classe e escrever alguns casos de teste para os métodos.

*Observação.* Você pode fechar o projeto junitsamplesol porque não será necessário informar novamente. O projeto JUnitSampleSol contém todos os testes descritos neste documento.


== Escrevendo Testes de Unidade JUnit 3

Nesta parte do tutorial você cria testes básicos de unidade JUnit 3 para as classes  ``Vectors.java``  e  ``Utils.java`` . Você usará a IDE para criar classes de teste esqueleto baseadas nas classes de seu projeto. Em seguida, você modificará os métodos de teste gerados e adicionará novos métodos de teste.

O IDE solicita que você escolha uma versão da JUnit na primeira vez em que usar o IDE para criar seus testes no projeto. A versão selecionada se torna a versão da JUnit default e o IDE irá gerar todos os testes e conjuntos de testes subseqüentes para essa versão.


=== Criando uma Classe de Teste para  ``Vectors.java`` 

Neste exercício você criará um esqueleto de teste JUnit para o  ``Vectors.java`` . Você também selecionará JUnit como o framework de teste e JUnit 3 como a versão.

*Observação.* Se você estiver usando o NetBeans IDE 7.1 ou uma versão mais recente, não precisará especificar o framework de teste porque o JUnit é especificado por default. No NetBeans IDE 7.2, você tem a opção de especificar JUnit ou TestNG como o framework de teste.

1. Clique com o botão direito do mouse em  ``Vectors.java``  e selecione Ferramentas > Criar Testes.
2. Modifique o nome da classe de teste *VectorsJUnit3Test* na caixa de diálogo Criar Testes.

Quando você alterar o nome da classe de teste, será exibido uma advertência sobre a alteração do nome. O nome default é baseado no nome da classe que você está testando, com a palavra Teste acrescentada ao nome. Por exemplo, para a classe  ``MyClass.java`` , o nome default da classe de teste é  ``MyClassTest.java`` . Normalmente, é melhor manter o nome default, mas para a finalidade deste tutorial você mudará o nome porque também irá criar testes JUnit 4 no mesmo pacote e os nomes das classes de teste devem ser únicos.



. Selecione JUnit na lista drop-down Framework.


. Desmarque Inicializador de Teste e Finalizador de Teste. Clique em OK.

image::images/junit3-vectors-createtests.png[title="Selecione caixa de diálogo versão JUnit"]


. Selecione JUnit 3.x na caixa de diálogo Versão da JUnit.

image::images/junit3-select-version.png[title="Selecione caixa de diálogo versão JUnit"]

Quando você seleciona a JUnit 3.x, o IDE adiciona a biblioteca JUnit 3 ao projeto.

Quando você clica em Selecionar, o IDE cria a classe de teste  ``VectorsJUnit3Test.java``  no pacote  ``sample``  no nó Pacotes de Teste, na janela Projetos.

image::images/projects-window2.png[title="Estrutura de amostra-junit projeto na janela Projetos"]

Um projeto precisa de um diretório para que os pacotes de teste criem testes. A localização default do diretório de pacotes de teste está no nível raiz do projeto; porém, dependendo do tipo de projeto, você pode especificar uma localização diferente para o diretório na caixa de diálogo Propriedades do projeto.

Se você observar a classe de teste  ``VectorsJUnit3Test.java``  gerada no editor, você poderá notar que o IDE gerou a classe de teste a seguir com os métodos de teste para os métodos  ``equal``  e  ``scalarMultiplication`` .


[source,java]
----

public class VectorsJUnit3Test extends TestCase {
    /**
     * Test of equal method, of class Vectors.
     */
    public void testEqual() {
        System.out.println("equal");
        int[] a = null;
        int[] b = null;
        boolean expResult = false;
        boolean result = Vectors.equal(a, b);
        assertEquals(expResult, result);
        // TODO review the generated test code and remove the default call to fail.
        fail("The test case is a prototype.");
    }

    /**
     * Test of scalarMultiplication method, of class Vectors.
     */
    public void testScalarMultiplication() {
        System.out.println("scalarMultiplication");
        int[] a = null;
        int[] b = null;
        int expResult = 0;
        int result = Vectors.scalarMultiplication(a, b);
        assertEquals(expResult, result);
        // TODO review the generated test code and remove the default call to fail.
        fail("The test case is a prototype.");
    }
}
----

O corpo do método de cada teste gerado é fornecido somente como um guia e precisa ser modificado para ser um caso de teste real. Você pode desmarcar Corpos de Método Default na caixa de diálogo Criar Testes se não quiser que o código seja gerado por você.

Quando o IDE gera os nomes para os métodos de teste, cada nome de método é prefixado com  ``teste`` , pois a JUnit 3 usa convenções de nomeação e reflexão para identificar testes. Para identificar métodos de teste, cada método deverá seguir a sintaxe  ``test_<NOME>_`` .

*Observação.* Na JUnit 4 não é mais necessário usar essa sintaxe de nomeação de métodos de teste, pois você pode usar anotações para identificar os métodos de teste e a classe de teste não precisa mais estender o  ``TestCase`` .

 


=== Escrevendo Métodos de Teste para  ``Vectors.java`` 

Neste exercício, você modifica os métodos de teste gerados para torná-los testes funcionais e modificar as mensagens de saída default. Você não precisa modificar as mensagens de saída para executar os testes, mas pode querer modificar a saída para ajudar a identificar os resultados exibidos na janela de saída Resultados do teste JUnit.

1. Abra o  ``VectorsJUnit3Test.java``  no editor.
2. Modifique o esqueleto de teste do  ``testScalarMultiplication`` , alterando o valor de  ``println``  e removendo as variáveis geradas. O método de teste agora deve se parecer com o seguinte (as alterações são mostradas em negrito):

[source,java]
----

public void testScalarMultiplication() {
    System.out.println("** VectorsJUnit3Test: testScalarMultiplication()*");
    assertEquals(expResult, result);
}
----


. Agora adicione algumas asserções para testar o método.

[source,java]
----

public void testScalarMultiplication() {
    System.out.println("* VectorsJUnit3Test: testScalarMultiplication()");
    *assertEquals(  0, Vectors.scalarMultiplication(new int[] { 0, 0}, new int[] { 0, 0}));
    assertEquals( 39, Vectors.scalarMultiplication(new int[] { 3, 4}, new int[] { 5, 6}));
    assertEquals(-39, Vectors.scalarMultiplication(new int[] {-3, 4}, new int[] { 5,-6}));
    assertEquals(  0, Vectors.scalarMultiplication(new int[] { 5, 9}, new int[] {-9, 5}));
    assertEquals(100, Vectors.scalarMultiplication(new int[] { 6, 8}, new int[] { 6, 8}));*
}
----

Este método de teste usa o método  ``assertEquals``  da JUnit. Para usar a asserção, forneça as variáveis de entrada e o resultado esperado. Para passar no teste, o método de teste deve retornar de modo bem-sucedido todos os resultados esperados com base nas variáveis fornecidas durante a execução do método. Você deve adicionar um número suficiente de asserções para abranger as várias permutações possíveis.



. Modifique o esqueleto de teste para  ``testEqual``  deletando os corpos de método gerados e adicionando a seguinte  ``println`` .

[source,java]
----

    *System.out.println("* VectorsJUnit3Test: testEqual()");*
----

O método de teste deve ser semelhante a:


[source,java]
----

public void testEqual() {
    System.out.println("* VectorsJUnit3Test: testEqual()");
}
----


. Modifique o método  ``testEqual``  adicionando as seguintes asserções (exibidas em negrito).

[source,java]
----

public void testEqual() {
    System.out.println("* VectorsJUnit3Test: testEqual()");
    *assertTrue(Vectors.equal(new int[] {}, new int[] {}));
    assertTrue(Vectors.equal(new int[] {0}, new int[] {0}));
    assertTrue(Vectors.equal(new int[] {0, 0}, new int[] {0, 0}));
    assertTrue(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 0, 0}));
    assertTrue(Vectors.equal(new int[] {5, 6, 7}, new int[] {5, 6, 7}));

    assertFalse(Vectors.equal(new int[] {}, new int[] {0}));
    assertFalse(Vectors.equal(new int[] {0}, new int[] {0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0}, new int[] {0, 0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0}, new int[] {0}));
    assertFalse(Vectors.equal(new int[] {0}, new int[] {}));

    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 0, 1}));
    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 1, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {1, 0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0, 1}, new int[] {0, 0, 3}));*
}
----

O teste usa os métodos  ``assertTrue``  e  ``assertFalse``  da JUnit para testar vários resultados possíveis. Para que o teste deste método seja aprovado, o  ``assertTrue``  deve ser totalmente verdadeiro e  ``assertFalse``  deve ser totalmente falso.



. Salve as alterações.

Compare: <<Exercise_32,Escrevendo Métodos de Teste para  ``Vectors.java``  (JUnit 4)>>

 


=== Criando uma Classe de Teste para  ``Utils.java`` 

Agora você pode criar os esqueletos de teste para  ``Utils.java`` . Quando você criou o teste no exercício anterior, o IDE solicitou a versão da JUnit. Desta vez, você não precisará selecionar uma versão.

1. Clique com o botão direito do mouse em  ``Utils.java``  e escolha Ferramentas > Criar Testes.
2. Selecione JUnit na lista drop-down Framework, se não estiver selecionada.
3. Selecione Inicializador de Teste e Finalizador de Teste na caixa de diálogo, se estiverem desmarcados.
4. Modifique o nome da classe de teste para *UtilsJUnit3Test* na caixa de diálogo Criar Testes. Clique em OK.

Quando você clicar em OK, o IDE criará o arquivo de teste  ``UtilsJUnit3Test.java``  no diretório Pacotes de Teste > Amostras. Você pode ver que, além de criar os esqueletos de teste  ``testComputeFactorial`` ,  ``testConcatWords``  e  ``testNormalizeWord``  para os métodos em  ``Utils.java`` , o IDE também cria o método  ``setUp``  do inicializador de teste e o método  ``tearDown``  do finalizador de teste.

 


=== Escrevendo Métodos de Teste para  ``Utils.java`` 

Neste exercício você adiciona casos de teste que ilustram alguns elementos de teste JUnit comuns. Você também adiciona um  ``println``  aos métodos, pois alguns métodos, por default, não imprimem saída. Adicionando um  ``println``  aos métodos, você pode olhar posteriormente na janela de resultado de teste JUnit para verificar se os métodos foram executados e em qual ordem.


==== Inicializadores e Finalizadores de Testes

Os métodos  ``setUp``  e  ``tearDown``  são usados para inicializar e finalizar condições de teste. Você não precisa dos métodos  ``setUp``  e  ``tearDown``  para testar o  ``Utils.java`` , mas eles estão incluídos aqui para demonstrar como funcionam.

O método  ``setUp``  é um método de inicialização de testes e é executado antes de cada caso de teste na classe de teste. Um método de inicialização de teste não é obrigatório para executar testes, mas se for necessário inicializar algumas variáveis antes de executá-lo, use o método do inicializador de testes.

O método  ``tearDown``  é um método de finalizador de testes e é executado depois de cada caso de teste na classe de teste. Um método de finalizador de teste não é obrigatório para executar testes, mas você pode precisar de um finalizador para limpar quaisquer dados que eram necessários durante a execução dos casos de teste.

1. Faça as alterações a seguir (exibidas em negrito) para adicionar um  ``println``  em cada método.

[source,java]
----

@Override
protected void setUp() throws Exception {
    super.setUp();
    *System.out.println("* UtilsJUnit3Test: setUp() method");*
}

@Override
protected void tearDown() throws Exception {
    super.tearDown();
    *System.out.println("* UtilsJUnit3Test: tearDown() method");*
}
----

Quando você executa o teste, o texto do  ``println``  de cada método será exibido na janela de saída Resultados de Testes JUnit. Se você não adicionar o  ``println`` , não haverá saída para mostrar que os métodos foram executados.


==== Testando o Uso de uma Asserção Simples

Este caso de teste simples testa o método  ``concatWords`` . Em vez de usar o método de teste gerado  ``testConcatWords`` , você adicionará um novo método de teste chamado  ``testHelloWorld`` , que usa uma única asserção simples para testar se o método concatena as strings corretamente. O  ``assertEquals``  no caso de teste usa a sintaxe  ``assertEquals(_EXPECTED_RESULT, ACTUAL_RESULT_)``  para testar se o resultado esperado é igual ao resultado real. Nesse caso, se a entrada para o método  ``concatWords``  é " ``Hello`` ", " ``, `` ", " ``world`` " e " ``!`` ", o resultado esperado deve ser igual a  ``"Hello, world!"`` .

1. Delete o método de teste gerado  ``testConcatWords``  em  ``UtilsJUnit3Test.java`` .
2. Adicione o método a seguir para testar o método  ``concatWords`` .*public void testHelloWorld() {
    assertEquals("Hello, world!", Utils.concatWords("Hello", ", ", "world", "!"));
}*


. Adicione uma instrução  ``println``  para exibir o texto sobre o teste na janela Resultados de Testes JUnit.

[source,java]
----

public void testHelloWorld() {
    *System.out.println("* UtilsJUnit3Test: test method 1 - testHelloWorld()");*
    assertEquals("Hello, world!", Utils.concatWords("Hello", ", ", "world", "!"));
----

Compare: <<Exercise_342,Testando Usando uma Asserção Simples (JUnit 4)>>


==== Testando com um Time-out

Esse teste demonstra como verificar se um método está demorando muito tempo para ser concluído. Se o método está demorando muito tempo, o thread de teste é interrompido e o teste falha. Você pode especificar o limite de tempo no teste.

O método de teste chama o método  ``computeFactorial``  em  ``Utils.java`` . Você pode supor que o método  ``computeFactorial``  esteja correto, mas nesse caso você quer testar se o cálculo é concluído dentro de 1000 milissegundos. O thread  ``computeFactorial``  e um thread de teste são iniciados ao mesmo tempo. O thread de teste será interrompido depois de 1000 milissegundos e lançará um  ``TimeoutException``  a menos que o thread  ``computeFactorial``  seja concluído primeiro. Você adicionará uma mensagem de modo que uma mensagem seja exibida se um  ``TimeoutException``  for lançado.

1. Delete o método de teste gerado  ``testComputeFactorial`` .
2. Adicione o método  ``testWithTimeout``  que calcula o fatorial de um número gerado aleatoriamente.*public void testWithTimeout() throws InterruptedException, TimeoutException {
    final int factorialOf = 1 + (int) (30000 * Math.random());
    System.out.println("computing " + factorialOf + '!');

    Thread testThread = new Thread() {
        public void run() {
            System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
        }
    };
}*


. Corrija suas importações para importar  ``java.util.concurrent.TimeoutException`` .


. Adicione o código a seguir (exibido em negrito) para que o método interrompa o thread e exiba uma mensagem se o teste levar muito tempo para ser executado.

[source,java]
----

    Thread testThread = new Thread() {
        public void run() {
            System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
        }
    };

    *testThread.start();
    Thread.sleep(1000);
    testThread.interrupt();

    if (testThread.isInterrupted()) {
        throw new TimeoutException("the test took too long to complete");
    }*
}
----

Você pode modificar a linha  ``Thread.sleep``  para alterar o número de milissegundos antes que o time-out seja lançado.



. Adicione a seguinte  ``println``  (exibida em negrito) para imprimir o texto sobre o teste na janela Resultados dos Testes JUnit.

[source,java]
----

public void testWithTimeout() throws InterruptedException, TimeoutException {
    *System.out.println("* UtilsJUnit3Test: test method 2 - testWithTimeout()");*
    final int factorialOf = 1 + (int) (30000 * Math.random());
    System.out.println("computing " + factorialOf + '!');
            
----

Compare: <<Exercise_343,Testando com um Time-out (JUnit 4)>>


==== Testando a Existência de uma Exceção Esperada

Esse teste demonstra como testar se há uma exceção esperada. O método falhará se não lançar a exceção esperada especificada. Nesse caso, você está testando se o método  ``computeFactorial``  lança um  ``IllegalArgumentException``  caso a variável de entrada seja um número negativo (-5).

1. Adicione o método  ``testExpectedException``  a seguir, que chama o método  ``computeFactorial``  com uma entrada de -5.*public void testExpectedException() {
    try {
        final int factorialOf = -5;
        System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
        fail("IllegalArgumentException was expected");
    } catch (IllegalArgumentException ex) {
    }
}*


. Adicione a seguinte  ``println``  (exibida em negrito) para imprimir o texto sobre o teste na janela Resultados dos Testes JUnit.

[source,java]
----

public void testExpectedException() {
    *System.out.println("* UtilsJUnit3Test: test method 3 - testExpectedException()");*
    try {
----

Compare: <<Exercise_344,Testando se há uma Exceção Esperada (JUnit 4)>>


==== Desativando um Teste

Este teste demonstra como desativar temporariamente um método de teste. Na JUnit 3, se um nome de método não iniciar com  ``test`` , ele não será reconhecido como um método de teste. Nesse caso, você acrescenta o prefixo  ``DISABLED_``  ao nome do método de teste para desativá-lo.

1. Delete o método de teste gerado  ``testNormalizeWord`` .
2. Adicione o método de teste a seguir à classe de teste.*public void testTemporarilyDisabled() throws Exception {
    System.out.println("* UtilsJUnit3Test: test method 4 - checkExpectedException()");
    assertEquals("Malm\u00f6", Utils.normalizeWord("Malmo\u0308"));
}*

O método de teste  ``testTemporarilyDisabled``  será executado se você executar a classe de teste.



. Acrescente o prefixo  ``DISABLED_``  (exibido em negrito) ao nome do método de teste.

[source,java]
----

public void *DISABLED_*testTemporarilyDisabled() throws Exception {
    System.out.println("* UtilsJUnit3Test: test method 4 - checkExpectedException()");
    assertEquals("Malm\u00f6", Utils.normalizeWord("Malmo\u0308"));
}
----

Compare: <<Exercise_345,Desativando um Teste (JUnit 4)>>

Agora que você escreveu os testes, poderá executar o teste e visualizar a saída do teste na janela Resultados de Testes JUnit.

 


=== Executando os Testes

Quando você executa um teste JUnit, os resultados são exibidos na janela Resultados do Teste do IDE. Você pode executar classes de teste JUnit individuais ou selecionar Executar > Testar _PROJECT_NAME_ no menu principal para executar todos os testes do projeto. Se você escolher Executar > Teste, o IDE executará todas as classes de teste na pasta Pacotes de Teste. Para executar uma classe de teste individual, clique com o botão direito do mouse na classe de teste no nó Pacotes de Teste e selecione Executar Arquivo.

1. Escolha Executar > Definir Projeto Principal no menu principal e selecione o projeto Amostra de JUnit.
2. Selecione Executar > Testar Projeto (JUnit-Sample), a partir do menu principal.
3. Selecione Janela > Ferramentas IDE > Resultados do Teste para abrir a janela Resultados de Teste.

Quando você executar o teste, verá um dos resultados a seguir na janela Resultados de Testes JUnit.

[.feature]
--
image:images/junit3-test-pass-sm.png[role="left", link="images/junit3-test-pass.png"]
--

Nesta imagem (clique na imagem para ampliá-la) você pode ver que o projeto foi aprovado em todos os testes. O painel esquerdo exibe os resultados dos métodos de teste individuais e o painel direito exibe a saída do teste. Se você observar na saída, poderá verificar a ordem na qual os testes foram executados. A  ``println``  adicionada a cada um dos métodos de testes imprimiu o nome do teste na janela de saída. Você também pode observar que na  ``UtilJUnit3Test``  o método  ``setUp``  foi executado antes de cada método de teste, e o método  ``tearDown``  foi executado depois de cada método.

[.feature]
--
image:images/junit3-test-fail-sm.png[role="left", link="images/junit3-test-fail.png"]
--

Nesta imagem (clique na imagem para ampliá-la) você pode verificar que o projeto falhou em um dos testes. O método  ``testTimeout``  demorou muito tempo para ser concluído e o thread de teste foi interrompido, causando a falha do teste. Ele levou mais de 1000 milissegundos para calcular o fatorial do número gerado aleatoriamente (22991).

A próxima etapa após a criação das classes de teste de unidades é criar conjuntos de testes. Consulte <<Exercise_41,Criando Conjuntos de Testes JUnit 3>> para ver como executar os testes especificados como um grupo, de modo que você não precise executar cada teste individualmente.


== Escrevendo Testes JUnit 4

Neste exercício, você cria testes de unidades JUnit 4 para as classes  ``Vectors.java``  e  ``Utils.java`` . Os casos de teste da JUnit 4 são os mesmos dos casos de teste da JUnit 3, mas você observará que a sintaxe para a escrita dos testes é mais simples.

Você usará os assistentes do IDE para criar esqueletos de teste com base nas classes em seu projeto. Na primeira vez em que você usar o IDE para criar esqueletos de teste, o IDE solicitará que você escolha a versão da JUnit.

*Observação.* Se você já selecionou a JUnit 3.x como a versão default para seus testes, será necessário alterar a versão default para JUnit 4.x. Para alterar a versão da JUnit default, expanda o nó Testar Bibliotecas, clique com o botão direito na biblioteca do JUnit e escolha Remover. Agora, você pode usar a caixa de diálogo Adicionar Biblioteca para adicionar explicitamente a biblioteca JUnit 4 ou selecionar a versão 4.x quando for solicitado a selecionar a versão do JUnit durante a criação de um novo teste. Você ainda pode executar testes das JUnit 3, mas quaisquer novos testes criados usarão a JUnit 4.


=== Criando uma Classe de Teste para  ``Vectors.java`` 

Neste exercício, você criará os esqueletos de teste da JUnit para o  ``Vectors.java`` .

*Observação.* Se você estiver usando o NetBeans IDE 7.1 ou uma versão mais recente, não precisará especificar o framework de teste porque o JUnit é especificado por default. No NetBeans IDE 7.2, você tem a opção de especificar JUnit ou TestNG como o framework de teste.

1. Clique com o botão direito do mouse em  ``Vectors.java``  e selecione Ferramentas > Criar Testes.
2. Modifique o nome da classe de teste para *VectorsJUnit4Test* na caixa de diálogo Criar Testes.

Quando você alterar o nome da classe de teste, será exibido uma advertência sobre a alteração do nome. O nome default é baseado no nome da classe que você está testando, com a palavra Teste acrescentada ao nome. Por exemplo, para a classe  ``MyClass.java`` , o nome default da classe de teste é  ``MyClassTest.java`` . Diferente da JUnit 3, na JUnit 4, o teste não precisa ser finalizado com a palavra Teste. Normalmente, é melhor manter o nome default, porém, como você está criando todos os testes da JUnit no mesmo pacote neste tutorial, os nomes das classes de teste devem ser exclusivos.



. Selecione JUnit na lista drop-down Framework.


. Desmarque Inicializador de Teste e Finalizador de Teste. Clique em OK.

image::images/junit4-vectors-createtests.png[title="Caixa de diálogo Criar Testes JUnit 4"]


. Selecione a JUnit 4.x na caixa de diálogo Selecionar a Versão da JUnit. Clique em Selecionar.

image::images/junit4-select-version.png[title="Selecione caixa de diálogo versão JUnit"]

Quando você clica em OK, o IDE cria a classe de teste  ``VVectorsJUnit4Test.java``  no pacote  ``sample``  no nó Pacotes de Teste, na janela Projetos.

image::images/projects-window3.png[title="estrutura do projeto JUnit-Sample com as classes de teste JUnit 3 e JUnit 4"]

*Observação.* Um projeto precisa de um diretório para que os pacotes de teste criem testes. A localização default do diretório de pacotes de teste está no nível de raiz do projeto, mas você pode especificar uma localização diferente para o diretório na caixa de diálogo Propriedades do projeto.

Se observar  ``VectorsJUnit3Test.java``  no editor, você irá verificar que o IDE gerou os métodos de teste  ``testEqual``  e  ``testScalarMultiplication`` . Em  ``VectorsJUnit4Test.java`` , cada método de teste é anotado com  ``@Test`` . O IDE gerou os nomes dos métodos de teste com base nos nomes do método em  ``Vectors.java`` , mas o nome do método de teste não precisa ter o prefixo  ``test`` . O corpo default de cada método de teste gerado é fornecido exclusivamente como um guia e precisa ser modificado para se tornar caso de teste real.

Você pode desmarcar Corpos de Método Default na caixa de diálogo Criar Testes se não quiser que os corpos do método sejam gerados para você.

O IDE também gerou os seguintes métodos de inicializador e finalizador de classes de teste:


[source,java]
----

@BeforeClass
public static void setUpClass() throws Exception {
}

@AfterClass
public static void tearDownClass() throws Exception {
}
----

O IDE gera os métodos inicializador e finalizador de classes por default durante a criação das classes de teste JUnit 4. As anotações  ``@BeforeClass``  e  ``@AfterClass``  são usadas para marcar métodos que devem ser executados antes e depois de executar a classe de teste. Você pode deletar métodos, pois não precisará deles para testar o  ``Vectors.java`` .

É possível configurar os métodos que são gerados por default configurando as opções da JUnit na janela Opções.

*Observação.* Para testes JUnit 4, observe que por default o IDE adiciona uma declaração de importação estática para  ``org.junit.assert.*`` .

 


=== Escrevendo Métodos de Teste para  ``Vectors.java`` 

Neste exercício, você modificará cada um dos métodos de teste gerados para testar os métodos usando o método  ``assert``  da JUnit e para alterar os nomes dos métodos de teste. Na JUnit 4 você tem maior flexibilidade ao nomear métodos de teste, pois os métodos de teste são indicados pela anotação  ``@Test``  e não exigem o prefixo  ``test``  para nomes de métodos de teste.

1. Abra o  ``VectorsJUnit4Test.java``  no editor.
2. Modifique o método de teste do  ``testScalarMultiplication``  alterando o nome do método, o valor de  ``println``  e removendo as variáveis geradas. O método de teste agora deve se parecer com o seguinte (as alterações são mostradas em negrito):

[source,java]
----

@Test
public void *ScalarMultiplicationCheck*() {
    System.out.println("** VectorsJUnit4Test: ScalarMultiplicationCheck()*");
    assertEquals(expResult, result);
}
----

*Observação.* Ao escrever testes, não é necessário alterar a saída impressa. Isso é realizado neste exercício, portanto é mais fácil identificar os resultados de teste na janela de saída.



. Agora adicione algumas asserções para testar o método.

[source,java]
----

@Test
public void ScalarMultiplicationCheck() {
    System.out.println("* VectorsJUnit4Test: ScalarMultiplicationCheck()");
    *assertEquals(  0, Vectors.scalarMultiplication(new int[] { 0, 0}, new int[] { 0, 0}));
    assertEquals( 39, Vectors.scalarMultiplication(new int[] { 3, 4}, new int[] { 5, 6}));
    assertEquals(-39, Vectors.scalarMultiplication(new int[] {-3, 4}, new int[] { 5,-6}));
    assertEquals(  0, Vectors.scalarMultiplication(new int[] { 5, 9}, new int[] {-9, 5}));
    assertEquals(100, Vectors.scalarMultiplication(new int[] { 6, 8}, new int[] { 6, 8}));*
}
----

Neste método de teste, você usa o método  ``assertEquals``  da JUnit. Para usar a asserção, forneça as variáveis de entrada e o resultado esperado. Para passar no teste, o método de teste deve retornar de modo bem-sucedido todos os resultados esperados com base nas variáveis fornecidas durante a execução do método. Você deve adicionar um número suficiente de asserções para abranger as várias permutações possíveis.



. Altere o nome do método de teste  ``testEqual``  para  ``equalsCheck`` .


. Delete o corpo do método gerado do método de teste  ``equalsCheck`` .


. Adicione o seguinte  ``println``  ao método de teste  ``equalsCheck`` .*System.out.println("* VectorsJUnit4Test: equalsCheck()");*

O método de teste deve ser semelhante a:


[source,java]
----

@Test
public void equalsCheck() {
    System.out.println("* VectorsJUnit4Test: equalsCheck()");
}
----


. Modifique o método  ``equalsCheck``  adicionando as asserções a seguir (exibidas em negrito).

[source,java]
----

@Test
public void equalsCheck() {
    System.out.println("* VectorsJUnit4Test: equalsCheck()");
    *assertTrue(Vectors.equal(new int[] {}, new int[] {}));
    assertTrue(Vectors.equal(new int[] {0}, new int[] {0}));
    assertTrue(Vectors.equal(new int[] {0, 0}, new int[] {0, 0}));
    assertTrue(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 0, 0}));
    assertTrue(Vectors.equal(new int[] {5, 6, 7}, new int[] {5, 6, 7}));

    assertFalse(Vectors.equal(new int[] {}, new int[] {0}));
    assertFalse(Vectors.equal(new int[] {0}, new int[] {0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0}, new int[] {0, 0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0}, new int[] {0}));
    assertFalse(Vectors.equal(new int[] {0}, new int[] {}));

    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 0, 1}));
    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {0, 1, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0, 0}, new int[] {1, 0, 0}));
    assertFalse(Vectors.equal(new int[] {0, 0, 1}, new int[] {0, 0, 3}));*
}
----

O teste usa os métodos  ``assertTrue``  e  ``assertFalse``  da JUnit para testar vários resultados possíveis. Para que o teste deste método seja aprovado, o  ``assertTrue``  deve ser totalmente verdadeiro e  ``assertFalse``  deve ser totalmente falso.

Compare: <<Exercise_22,Escrevendo Métodos de Teste para  ``Vectors.java``  (JUnit 3)>>

 


=== Criando uma Classe de Teste para  ``Utils.java`` 

Agora você criará os métodos de teste da JUnit para o  ``Utils.java`` . Quando você criou a classe de teste no exercício anterior, o IDE solicitou a versão da JUnit. Agora é solicitado que você selecione uma versão, pois já selecionou a versão da JUnit e todos os testes subseqüentes da JUnit são criados nessa versão.

*Observação.* Você ainda pode escrever e executar testes da JUnit 3 se selecionar a JUnit 4 como a versão, mas o IDE usa o modelo da JUnit 4 para a geração de esqueletos de teste.

1. Clique com o botão direito do mouse em  ``Utils.java``  e escolha Ferramentas > Criar Testes.
2. Selecione JUnit na lista drop-down Framework, se não estiver selecionada.
3. Selecione Inicializador de Teste e Finalizador de Teste na caixa de diálogo, se estiverem desmarcados.
4. Modifique o nome da classe de teste para *UtilsJUnit4Test* na caixa de diálogo Criar Testes. Clique em OK.

Quando você clica em OK, o IDE cria o arquivo de teste  ``UtilsJUnit4Test.java``  no diretório Pacotes de Teste > Amostra. Você pode observar que o IDE gerou os métodos de teste  ``testComputeFactorial`` ,  ``testConcatWords``  e  ``testNormalizeWord``  para os métodos em  ``Utils.java`` . O IDE também gerou os métodos inicializador e finalizador para o teste e para a classe de teste.

 


=== Escrevendo Métodos de Teste para  ``Utils.java`` 

Neste exercício, você adicionará casos de teste que ilustram alguns elementos comuns de teste da JUnit. Você também adicionará uma  ``println``  aos métodos, pois alguns métodos não imprimem saída alguma na janela Resultados do Teste JUnit para indicar que foram executados ou que o método passou no teste. Pela adição de uma  ``println``  aos métodos, você pode verificar se os métodos foram executados e em qual ordem.


==== Inicializadores e Finalizadores de Testes

Quando você criou a classe de teste para  ``Utils.java`` , o IDE gerou métodos anotados do inicializador e finalizador. Você pode escolher qualquer nome do método, pois não há convenção de nomeação obrigatória.

*Observação.* Não é necessário que os métodos inicializador e finalizador testem  ``Utils.java`` , mas eles são incluídos neste tutorial para demonstrar como funcionam.

Na JUnit 4, você pode usar anotações para marcar os tipos de métodos inicializador e finalizador a seguir.

* *Inicializador da Classe do Teste.* A anotação  ``@beforeclass``  marcas um método como um método de inicialização da classe de teste. Um método de inicialização de classe de teste é executado somente uma vez, e antes de qualquer outro método na classe de teste. Por exemplo, em vez de criar uma conexão de banco de dados em um inicializador de teste e criar uma nova conexão antes de cada método de teste, você pode usar um inicializador da classe de teste para abrir uma conexão antes de executar os testes. Em seguida, é possível fechar a conexão com o finalizador da classe de teste.
* *Finalizador da Classe de Teste.* A anotação  ``@AfterClass``  marca um método como um método de finalizador da classe de teste. Um método finalizador da classe de teste é executado apenas uma vez e depois que todos os outros métodos na classe de teste foram finalizados.
* *inicializador de Teste.* A anotação  ``@Before``  marca um método como um método de inicialização de teste. Um método de inicialização de teste é executado antes de cada caso de teste na classe de teste. Um método de inicialização de teste não é obrigatório para executar os testes, mas se você precisar inicializar algumas variáveis antes de executar um teste, você usará um método inicializador de teste.
* *Finalizador de Teste.* A anotação  ``@After``  marca um método como um método de finalizador de teste. Um método finalizador de teste é executado depois de cada caso de teste na classe de teste. Um método finalizador de teste não é obrigatório para executar testes, mas você pode precisar de um finalizador para limpar eventuais dados que foram necessários ao executar os casos de teste.

Faça as seguintes alterações (mostradas em negrito) em  ``UtilsJUnit4Test.java`` .


[source,java]
----

@BeforeClass
public static void setUpClass() throws Exception {
    *System.out.println("* UtilsJUnit4Test: @BeforeClass method");*
}

@AfterClass
public static void tearDownClass() throws Exception {
    *System.out.println("* UtilsJUnit4Test: @AfterClass method");*
}

@Before
public void setUp() {
    *System.out.println("* UtilsJUnit4Test: @Before method");*
}

@After
public void tearDown() {
    *System.out.println("* UtilsJUnit4Test: @After method");*
}
----

Compare: <<Exercise_241,Inicializadores e finalizadores de testes (JUnit 3)>>

Quando você executa a classe de teste, o texto da  ``println``  que você adicionou é exibido no painel de saída da janela Resultados do Teste JUnit. Se você não adicionar a  ``println`` , não haverá saída para indicar que os métodos inicializador e finalizador foram executados.


==== Testando o Uso de uma Asserção Simples

Este caso de teste simples testa o método  ``concatWords`` . Em vez de usar o método de teste gerado  ``testConcatWords`` , você adicionará um novo método de teste chamado  ``helloWorldCheck`` , que usa uma única asserção simples para testar se o método concatena as strings corretamente. O  ``assertEquals``  no caso de teste usa a sintaxe  ``assertEquals(_EXPECTED_RESULT, ACTUAL_RESULT_)``  para testar se o resultado esperado é igual ao resultado real. Nesse caso, se a entrada para o método  ``concatWords``  é " ``Hello`` ", " ``, `` ", " ``world`` " e " ``!`` ", o resultado esperado deve ser igual a  ``"Hello, world!"`` .

1. Delete o método de teste gerado  ``testConcatWords`` .
2. Adicione o método  ``helloWorldCheck``  a seguir para testar  ``Utils.concatWords`` .*@Test
public void helloWorldCheck() {
    assertEquals("Hello, world!", Utils.concatWords("Hello", ", ", "world", "!"));
}*


. Adicione uma instrução  ``println``  para exibir o texto sobre o teste na janela Resultados de Testes JUnit.

[source,java]
----

@Test
public void helloWorldCheck() {
    *System.out.println("* UtilsJUnit4Test: test method 1 - helloWorldCheck()");*
    assertEquals("Hello, world!", Utils.concatWords("Hello", ", ", "world", "!"));
----

Compare: <<Exercise_242,Testando usando uma Asserção Simples (JUnit 3)>>


==== Testando com um Time-out

Esse teste demonstra como verificar se um método está demorando muito tempo para ser concluído. Se o método está demorando muito tempo, o thread de teste é interrompido e o teste falha. Você pode especificar o limite de tempo no teste.

O método de teste chama o método  ``computeFactorial``  em  ``Utils.java`` . Você pode supor que o método  ``computeFactorial``  esteja correto, mas nesse caso você quer testar se o cálculo é concluído dentro de 1000 milissegundos. Você faz isso interrompendo o thread de teste depois de 1000 milissegundos. Se o thread for interrompido, o método de teste lançará uma  ``TimeoutException`` .

1. Delete o método de teste gerado  ``testComputeFactorial`` .
2. Adicione o método  ``testWithTimeout``  que calcula o fatorial de um número gerado aleatoriamente.*@Test
public void testWithTimeout() {
    final int factorialOf = 1 + (int) (30000 * Math.random());
    System.out.println("computing " + factorialOf + '!');
    System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
}*


. Adicione o código a seguir (exibido em negrito) para definir o time-out e para interromper o thread se o método demorar muito tempo para ser executado.

[source,java]
----

@Test*(timeout=1000)*
public void testWithTimeout() {
    final int factorialOf = 1 + (int) (30000 * Math.random());
----

Você pode observar que o time-out foi definido como 1000 milissegundos.



. Adicione a seguinte  ``println``  (exibida em negrito) para imprimir o texto sobre o teste na janela Resultados dos Testes JUnit.

[source,java]
----

@Test(timeout=1000)
public void testWithTimeout() {
    *System.out.println("* UtilsJUnit4Test: test method 2 - testWithTimeout()");*
    final int factorialOf = 1 + (int) (30000 * Math.random());
    System.out.println("computing " + factorialOf + '!');
            
----

Compare: <<Exercise_243,Testando com um Time-out (JUnit 3)>>


==== Testando a Existência de uma Exceção Esperada

Esse teste demonstra como testar se há uma exceção esperada. O método falhará se não lançar a exceção esperada especificada. Nesse caso, você está testando se o método  ``computeFactorial``  lança um  ``IllegalArgumentException``  caso a variável de entrada seja um número negativo (-5).

1. Adicione o método  ``testExpectedException``  a seguir, que chama o método  ``computeFactorial``  com uma entrada de -5.*@Test
public void checkExpectedException() {
    final int factorialOf = -5;
    System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
}*


. Adicione a propriedade a seguir (exibida em negrito) à anotação  ``@Test``  para especificar que se espera que o teste lance a  ``IllegalArgumentException`` .

[source,java]
----

@Test*(expected=IllegalArgumentException.class)*
public void checkExpectedException() {
    final int factorialOf = -5;
    System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
}
----


. Adicione a seguinte  ``println``  (exibida em negrito) para imprimir o texto sobre o teste na janela Resultados dos Testes JUnit.

[source,java]
----

@Test (expected=IllegalArgumentException.class)
public void checkExpectedException() {
    *System.out.println("* UtilsJUnit4Test: test method 3 - checkExpectedException()");*
    final int factorialOf = -5;
    System.out.println(factorialOf + "! = " + Utils.computeFactorial(factorialOf));
}
----

Compare: <<Exercise_244,Testando a Existência de uma Exceção Esperada (JUnit 3)>>


==== Desativando um Teste

Este teste demonstra como desativar temporariamente um método de teste. Na JUnit 4, você simplesmente adiciona a anotação  ``@Ignore``  para desativar o teste.

1. Delete o método de teste gerado  ``testNormalizeWord`` .
2. Adicione o método de teste a seguir à classe de teste.*@Test
public void temporarilyDisabledTest() throws Exception {
    System.out.println("* UtilsJUnit4Test: test method 4 - checkExpectedException()");
    assertEquals("Malm\u00f6", Utils.normalizeWord("Malmo\u0308"));
}*

O método de teste  ``temporarilyDisabledTest``  será executado se você executar a classe de teste.



. Adicione a anotação  ``@Ignore``  (exibida em negrito) acima de  ``@Test``  para desativar o teste.*@Ignore*

[source,java]
----

@Test
public void temporarilyDisabledTest() throws Exception {
    System.out.println("* UtilsJUnit4Test: test method 4 - checkExpectedException()");
    assertEquals("Malm\u00f6", Utils.normalizeWord("Malmo\u0308"));
}
----


. Corrija as importações para importar a  ``org.junit.Ignore`` .

Compare: <<Exercise_245,Desativando um Teste (JUnit 3)>>

Agora que você escreveu os testes, poderá executar o teste e visualizar a saída do teste na janela Resultados de Testes JUnit.

 


=== Executando os Testes

Você pode executar testes JUnit em todo a aplicação ou em arquivos individuais e verificar os resultados no IDE. O modo mais fácil de executar todos os testes de unidade para o projeto é selecionar Executar > Teste _<PROJECT_NAME>_ no menu principal. Se você escolher esse método, o IDE executará todas as classes de teste nos Pacotes de Teste. Para executar uma classe de teste individual, clique com o botão direito do mouse na classe de teste no nó Pacotes de Teste e selecione Executar Arquivo.

1. Clique com o botão direito do mouse em  ``UtilsJUnit4Test.java``  na janela Projetos.
2. Escolha Arquivo de Teste.
3. Selecione Janela > Ferramentas IDE > Resultados do Teste para abrir a janela Resultados de Teste.

Quando você executa  ``UtilsJUnit4Tests.java`` , o IDE executa somente os testes na classe de teste. Se a classe for aprovada em todos os testes, você observará algo similar à imagem a seguir na janela Resultados do Teste JUnit.

[.feature]
--
image:images/junit4-utilstest-pass-sm.png[role="left", link="images/junit4-utilstest-pass.png"]
--

Nesta imagem (clique na imagem para ampliá-la) você pode notar que o IDE executou o teste JUnit em  ``Utils.java``  e que a classe passou em todos os testes. O painel esquerdo exibe os resultados dos métodos de teste individuais e o painel direito exibe a saída do teste. Se você observar na saída, poderá verificar a ordem na qual os testes foram executados. A  ``println``  adicionada a cada um dos métodos de testes imprimiu o nome do teste na janela Resultados do Teste e na janela de Saída.

Você pode notar que em  ``UtilsJUnit4Test``  o método inicializador da classe de teste anotado com  ``@BeforeClass``  foi executado antes dos outros métodos e foi executado somente uma vez. O método finalizador da classe de teste anotado com  ``@AfterClass``  foi executado por último, depois de todos os outros métodos na classe. O método inicializador de teste anotado com  ``@Before``  foi executado antes de cada método de teste.

Os controles no lado esquerdo da janela Resultados do Teste, permitem executar com facilidade novamente o teste. Você pode usar o filtro para alternar entre a exibição de todos os resultados do teste ou somente os testes que falharam. As setas permitem ir para a próxima falha ou para a falha anterior.

Quando você clica com o botão direito do mouse em um resultado do teste na janela Resultados do Teste, o menu pop-up permite escolher ir para o código-fonte de teste, executar novamente o teste ou depurar o teste.

O próximo passo após a criação das classes de teste de unidades é criar conjuntos de testes. Consulte <<Exercise_42,Criando Conjuntos de Testes JUnit 4>> para ver como executar os testes especificados como um grupo, de modo que você não tenha que executar cada teste individualmente.


== Criando Conjuntos de Testes

Durante a criação de testes para um projeto, geralmente acabará com muitas classes de teste. Embora seja possível executar classes de teste individualmente ou executar todos os testes em um projeto, em muitos casos você vai querer executar um subconjunto dos testes ou executar testes em uma ordem específica. Você pode fazer isso criando um ou mais conjuntos de testes. Por exemplo, você pode criar conjuntos que testam aspectos específicos de seu código ou condições específicas.

Um conjunto de testes é basicamente uma classe com um método que chama os casos de teste especificados, como as classes de teste específicas, os métodos de teste em classes de teste e outros conjuntos. Um conjunto de testes pode ser incluído como parte de uma classe de teste, mas as práticas recomendadas aconselham a criar classes individuais de conjuntos de testes.

Você pode criar conjuntos de teste JUnit 3 e JUnit 4 para seu projeto manualmente ou o IDE pode gerar os conjuntos para você. Quando você usa o IDE para gerar um conjunto de testes, por default o IDE gera o código para chamar todas as classes de teste no mesmo pacote do conjunto de testes. Depois que o conjunto de testes foi criado, você pode modificar a classe para especificar os testes que deseja executar como parte desse conjunto.


=== Criando Conjuntos de Testes JUnit 3

Se você selecionou o JUnit 3 como a versão de seus testes, o IDE pode gerar conjuntos de teste JUnit 3 com base nas classes de testes no pacote de testes. Na JUnit 3 você especifica as classes de teste a incluir no conjunto de testes criando uma instância do  ``TestSuite``  e usando o método  ``addTest``  para cada teste.

1. Clique com o botão direito do mouse no nó do projeto *JUnit-Sample* na janela Projetos e escolha Novo > Outro para abrir o assistente para Novo Arquivo.
2. Selecione Conjunto de Testes na categoria Testes da Unidade. Clique em Próximo.
3. Digite *JUnit3TestSuite* para o Nome da Classe.
4. Selecione o pacote  ``amostra``  para criar o conjunto de testes na pasta de amostras, contida na pasta pacotes de testes.
5. Desmarque Inicializador de Teste e Finalizador de Teste. Clique em Finalizar.

image::images/junit-testsuite-wizard.png[title="Assistente Conjunto de Testes JUnit"]

Quando você clicar em Finalizar, o IDE criará a classe do conjunto de testes no pacote  ``amostra``  e abrirá a classe no editor. O conjunto de testes conterá o código a seguir.


[source,java]
----

public class JUnit3TestSuite extends TestCase {
    public JUnit3TestSuite(String testName) {
        super(testName);
    }

    public static Test suite() {
        TestSuite suite = new TestSuite("JUnit3TestSuite");
        return suite;
    }
}
----


. Modifique o método  ``suite()``  para adicionar as classes de teste que serão executadas como parte do conjunto.

[source,java]
----

public JUnit3TestSuite(String testName) {
    super(testName);
}

public static Test suite() {
    TestSuite suite = new TestSuite("JUnit3TestSuite");
    *suite.addTest(new TestSuite(sample.VectorsJUnit3Test.class));
    suite.addTest(new TestSuite(sample.UtilsJUnit3Test.class));*
    return suite;
}
----


. Salve as alterações.
 


=== Criando Conjuntos de Testes JUnit 4

Se você selecionou a JUnit 4 para a versão de seus testes, o IDE pode gerar conjuntos de teste JUnit 4. A JUnit 4 é compatível com versões anteriores, portanto você pode executar conjuntos de testes JUnit 4 que contenham testes JUnit 4 ou JUnit 3. Nos conjuntos de teste JUnit 4, você especifica as classes de teste a incluir como valores da anotação  ``@Suite`` .

*Observação.* Para executar os conjuntos de teste JUnit 3 como parte de um conjunto de teste JUnit 4 é necessária a JUnit 4.4 ou superior.

1. Clique com o botão direito do mouse no nó do projeto na janela Projetos e escolha Novo > Outro para abrir o assistente para Novo Arquivo.
2. Selecione Conjunto de Testes na categoria Testes da Unidade. Clique em Próximo.
3. Insira *JUnit4TestSuite* como o nome de arquivo.
4. Selecione o pacote  ``amostra``  para criar o conjunto de testes na pasta de amostras, contida na pasta pacotes de testes.
5. Desmarque Inicializador de Teste e Finalizador de Teste. Clique em Finalizar.

Quando você clicar em Finalizar, o IDE criará a classe do conjunto de testes no pacote  ``amostra``  e abrirá a classe no editor. O conjunto de teste contém código semelhante ao mostrado a seguir.


[source,java]
----

@RunWith(Suite.class)
@Suite.SuiteClasses(value={UtilsJUnit4Test.class, VectorsJUnit4Test.class})
public class JUnit4TestSuite {
}
----

Quando você executar o conjunto de testes, o IDE executará as classes de teste e na ordem em que foram apresentadas.


=== Executando Conjuntos de Teste

Você pode executar um conjunto de teste da mesma forma que você executa qualquer classe de teste individual.

1. Expanda o nó Pacotes de Teste na janela Projetos.
2. Clique com o botão direito do mouse na classe do conjunto de testes e selecione Arquivo de Teste.

Quando você executar o conjunto de testes, o IDE executará os testes incluídos no conjunto na ordem em que foram apresentados. Os resultados são exibidos na janela Resultados do Teste JUnit.

[.feature]
--
image:images/junit3-suite-results-sm.png[role="left", link="images/junit3-suite-results.png"]
--

Nessa imagem (clique na imagem para ampliá-la) você pode verificar os resultados de um conjunto de testes JUnit 3. O conjunto de testes executou as classes de teste  ``UtilsJUnit3Test``  e  ``VectorsJUnit3Test``  como um teste único e exibiu os resultados no painel esquerdo como resultados de um só teste. A saída no painel direito é a mesma de quando você executa o teste individualmente.

[.feature]
--
image:images/junit4-suite-results-sm.png[role="left", link="images/junit4-suite-results.png"]
--

Nessa imagem (clique na imagem para ampliá-la) você pode verificar os resultados um conjunto de testes JUnit 4. O conjunto de testes executou as classes de teste  ``UtilsJUnit4Test``  e  ``VectorsJUnit4Test``  como um teste único e exibiu os resultados no painel esquerdo como resultados de um só teste. A saída no painel direito é a mesma de quando você executa o teste individualmente.

[.feature]
--
image:images/junitmix3and4-suite-results-sm.png[role="left", link="images/junitmix3and4-suite-results.png"]
--

Nessa imagem (clique na imagem para ampliá-la) você pode verificar os resultados de um conjunto de testes mistos. O conjunto de testes inclui a JUnit 4 e uma das classes de teste JUnit 3. O conjunto de testes executou as classes de teste  ``UtilsJUnit3Test.java``  e  ``JUnit4TestSuite.java``  como um único teste e exibiu os resultados no painel esquerdo como resultados de um só teste. A saída no painel direito é a mesma obtida com a execução do teste individualmente.


== Resumo

Este tutorial foi uma introdução básica à criação de testes de unidades JUnit e conjuntos de testes no NetBeans IDE. O IDE suporta o JUnit 3 e o JUnit 4, e este documento demonstrou algumas das alterações introduzidas no JUnit 4, que são projetadas para tornar mais simples a criação e a execução de testes.

Como demonstrado neste tutorial, um dos principais aprimoramentos no JUnit4 é o seu suporte para anotações. No JUnit 4 você agora pode usar anotações para fazer o seguinte:

* Identificar um teste usando a anotação  ``@Test``  ao invés de uma convenção de nomeação
* Identificar os métodos  ``setUp``  e  ``tearDown``  com as anotações  ``@Before``  e  ``@After`` 
* Identificar os métodos  ``setUp``  e  ``tearDown``  que se aplicam à toda a classe de teste. Métodos anotados com  ``@BeforeClass``  são executados somente uma vez, antes que quaisquer métodos de teste na classe sejam executados. Métodos anotados com  ``@AfterClass``  também são executados somente uma vez, após todos os métodos de teste serem finalizados.
* Identificar exceções esperadas
* Identificar testes que deveriam ser ignorados usando a anotação  ``@Ignore`` 
* Especificar um parâmetro de time-out para um teste

Para obter mais informações sobre o uso do JUnit e outras alterações introduzidas no JUnit4, consulte os seguintes recursos:

* link:http://tech.groups.yahoo.com/group/junit/[+Grupo JUnit nos grupos do Yahoo+]
* link:http://www.junit.org[+www.junit.org+]

O código de teste geralmente ajuda a garantir que pequenas alterações feitas no código não interrompam a aplicação. As ferramentas de testes automatizadas como a JUnit simplificam o processo de teste e, além disso, a execução freqüente de testes pode ajudar a encontrar erros precocemente.


link:https://netbeans.org/about/contact_form.html?to=3&subject=Feedback:%20Writing%20JUnit%20Tests%20in%20NetBeans%20IDE[+Enviar Feedback neste Tutorial+]



== Consulte Também

Para obter mais informações sobre o uso do NetBeans IDE para desenvolver aplicações Java , consulte os seguintes recursos:

* link:http://www.oracle.com/pls/topic/lookup?ctx=nb8000&id=NBDAG366[+Criando Projetos Java+] em _Desenvolvendo Aplicações com o NetBeans IDE_
* link:../../trails/java-se.html[+Trilha de Aprendizado da Programação Java e IDE Básica+]
