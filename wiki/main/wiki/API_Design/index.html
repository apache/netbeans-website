<!doctype html>
<html class="no-js" lang="en" dir="ltr">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Introduction: How to Design a Module API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Introduction: How To Design a (module) API">
    <meta name="author" content="Apache NetBeans">
    <meta name="keywords" content="">
    <meta name="generator" content="Apache NetBeans">
    <link rel="stylesheet" href="../../../../_/css/font-awesome.min.css">
    <link rel="alternate" type="application/atom+xml" title="Apache NetBeans Blog" href="https://netbeans.apache.org/blogs/atom" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css">
    <link rel="stylesheet" href="../../../../_/css/netbeans.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/images/fav/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/images/fav/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/images/fav/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/images/fav/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/images/fav/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
    <link href="../../../../_/css/font-open-sans.css" rel="stylesheet">
    <!--
        Licensed to the Apache Software Foundation (ASF) under one
        or more contributor license agreements.  See the NOTICE file
        distributed with this work for additional information
        regarding copyright ownership.  The ASF licenses this file
        to you under the Apache License, Version 2.0 (the
        "License"); you may not use this file except in compliance
        with the License.  You may obtain a copy of the License at
        http://www.apache.org/licenses/LICENSE-2.0
        Unless required by applicable law or agreed to in writing,
        software distributed under the License is distributed on an
        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, either express or implied.  See the License for the
        specific language governing permissions and limitations
        under the License.
    -->
  </head>
  <body>
    <div class="title-bar" data-responsive-toggle="responsive-menu" data-hide-for="medium">
    <button type="button" data-toggle="responsive-menu"><i style='font-size: 32px; color: #fff; padding: 8px' class='fa fa-bars'></i></button>
    <div class="title-bar-title">Apache NetBeans</div>
</div>
<div class="top-bar" id="responsive-menu">
    <div class='top-bar-left'>
        <a class='title' href="../../../../index.html"><img src='../../../../_/images/apache-netbeans.svg' style='padding: 8px; height: 48px;'></img> Apache NetBeans</a>
    </div>
    <div class="top-bar-right">
        <ul class="vertical medium-horizontal menu" data-responsive-menu="drilldown medium-dropdown">
            <li> <input id="search-input" type="text" placeholder="Search the docs"> </li>
            <li> <a href="../../../../front/main/community">Community</a> </li>
            <li> <a href="../../../../front/main/participate">Participate</a> </li>
            <li> <a href="../../../../front/main/blogs">Blog</a></li>
            <li> <a href="../../../../front/main/help">Get Help</a> </li>
            <li> <a href="https://plugins.netbeans.apache.org/">Plugins</a> </li>
            <li> <a href="../../../../front/main/download">Download</a> </li>
        </ul>
    </div>
</div>

    <!-- src/templates/news -->
<section class="hero news alternate">
    <div class='grid-container'>
        <div class='cell'>
            <div class="annotation">Latest release</div>
            <h1>Apache NetBeans 20</h1>
            <p><a class="button success" href="../../../../front/main/download/nb20">Download</a></p>
        </div>
    </div>
</section>
    <div class='grid-container main-content'>
      <article class="doc">
      <h1 style="visibily: hidden">Introduction: How to Design a Module API</h1>
      <div class='aside' style='text-align: center; padding: 20px;'>
    <a href="../../../../wiki/main/wiki" title="Apache NetBeans WIKI">Apache NetBeans Wiki Index</a>
    <p><b>Note:</b> These pages are being reviewed.</p>
</div>
      <div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#Why_API">Why API?</a></li>
<li><a href="#What_is_an_API">What is an API?</a></li>
<li><a href="#The_Importance_of_Being_Use_Case_Oriented">The Importance of Being Use Case Oriented</a></li>
<li><a href="#Life-cycle_of_an_API">Life-cycle of an API</a>
<ul class="sectlevel2">
<li><a href="#_api_stability">API Stability</a></li>
</ul>
</li>
<li><a href="#Preservation_of_Investments">Preservation of Investments</a>
<ul class="sectlevel2">
<li><a href="#Maintained_.26amp.3B_unmaintained">Maintained &amp; unmaintained</a></li>
<li><a href="#Examples">Examples</a></li>
</ul>
</li>
<li><a href="#Design_Practices">Design Practices</a>
<ul class="sectlevel2">
<li><a href="#Do_not_expose_more_than_you_want">Do not expose more than you want</a></li>
<li><a href="#Separate_API_for_clients_from_support_API">Separate API for clients from support API</a></li>
<li><a href="#Interfaces_vs._abstract_classes">Interfaces vs. abstract classes</a></li>
<li><a href="#Use_cases">Use cases</a></li>
<li><a href="#Interfaces_or_Classes">Interfaces or Classes?</a></li>
</ul>
</li>
<li><a href="#Case_Study_of_client_API_and_SPI_separation">Case Study of client API and SPI separation</a>
<ul class="sectlevel2">
<li><a href="#Move_Protected_Methods_Into_Interface">Move Protected Methods Into Interface</a></li>
<li><a href="#Passing_Notifications_to_Implementation">Passing Notifications to Implementation</a></li>
<li><a href="#Callbacks_to_Implementation">Callbacks to Implementation</a></li>
<li><a href="#Extensible_Client_Behaviour">Extensible Client Behaviour</a></li>
<li><a href="#Extensible_Communication_betwen_provider_and_implementation">Extensible Communication betwen provider and implementation</a></li>
<li><a href="#Extensible_Provider_Evolution">Extensible Provider Evolution</a></li>
</ul>
</li>
<li><a href="#Using_games_to_Improve_API_Design_Skills">Using games to Improve API Design Skills</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Please visit <a href="http://wiki.apidesign.org/wiki/Main_Page">apidesign.org</a> for more information on API Design, and links for the "Practical API Design" book.</p>
</div>
<div class="paragraph">
<p>A description of good design practices when design any APIs with especially closer look to the case of an API based on NetBeans infrastructure is content of this evolving document.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Why_API"><a class="anchor" href="#Why_API"></a>Why API?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The API stands for <em>Application Programming Inteface</em> and before we drill down to descriptions and suggestions how to write it, it is not unreasonable to analyze a bit the meaning of these words.</p>
</div>
<div class="paragraph">
<p>The word <em>interface</em> indicates that the <em>API</em> lives between at least two different subjects. For example the internal structure of the application could be seen on one side, while leaving foreing applications making calls into it on the on the other. Or there is the programmer (or team) developing the application and its API on one side and on the other the programmers using it. The important observation is that in both cases these two sides are <em>separated</em> - either <em>compiled</em> separatelly or <em>developed</em> in completely different groups with their own schedules, goals and needs.</p>
</div>
<div class="paragraph">
<p>It is exactly this <em>separation</em> that implies that rules for designing and maintaining an API. If there was no <em>separation</em> and the whole product was developed by tight team, build at once, there would be no need for bothering with API (as it is definitively more work) and also writing this tutorial. But as the real world <strong>products</strong> are composed from a set of independent <strong>projects</strong> developed by teams that do not necessarily know about each other, have completely different schedules and build their projects independently, but still want to communicate among themselves there is a need for a <strong>stable</strong> <strong>contract</strong> that can be used <strong>for</strong> such <strong>communication</strong>.</p>
</div>
<div class="paragraph">
<p><em>Example: _'Linux'</em> distributions are done by Mandrake or RedHat, but their content is composed from a thousands of independent open source projects. The producer of the distribution cannot influence their work, it just takes what is available and stable at given time, makes sure that everything works together and creates the release._</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="What_is_an_API"><a class="anchor" href="#What_is_an_API"></a>What is an API?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As the reason why API is used is to allow communictation between teams and applications in order to allow separated and distributed development the answer to question what is API shall include everything that influences such kind of development.</p>
</div>
<div class="paragraph">
<p><em>The API is everything that another team or application can depend on</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>method and field signatures</strong> - communication between applications is usally about calling functions and passing data structures between each other. If there is a change in the names of the methods, in their arguments or in structure of exchanged data, the whole program often does not even link well, nor it can run.</p>
</li>
<li>
<p><strong>files and their content</strong> - many applications read various files and their content can influence their behaviour. Imagine application relying on the other one to read its configuration file and modifying its content prior to invoking the application. If the format of the file changes or the file is completely ignored, the communication between those applications gets broken.</p>
</li>
<li>
<p><strong>environment variables</strong> - for example behaviour of <code>cvs</code> can be influenced by the variable <code>CVSEDITOR</code>.</p>
</li>
<li>
<p><strong>protocols</strong> - opening a socket and being prepared to interpret streams sent there, or putting or reading a data to clipboard or during drag and drop again establishes an API that others can depend on.</p>
</li>
<li>
<p><strong>behaviour</strong> - a bit harder to grip, but important for the separation as well is the the dynamic behaviour. How the program flow looks like - what is the order of execution, what locks are being held during calls, in which threads a call can happen, etc.</p>
</li>
<li>
<p><strong>L10N messages</strong> - because the localization to a certain language is usually developed and distributed by somebody other than the person that writes the code, yet both of them have to use the same keys (<code>NbBundle.getMessage ("CTL_SomeKey")</code>), there is inherently a contract between the writer of the code and the translator - an API of sorts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The important thing with respect to distributed development is to be aware of possible APIs - of possible things other code can depend on. Only by identifying such aspects of own application one can develop it in a way that will not hurt cooperation with seperately developed applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="The_Importance_of_Being_Use_Case_Oriented"><a class="anchor" href="#The_Importance_of_Being_Use_Case_Oriented"></a>The Importance of Being Use Case Oriented</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is often not hard to decide whether a program is good or bad - if it crashes without doing anything useful, it is bad. If the program cannot compile, it is even worse. But if it runs, helps to get a work done, just sometimes crashes, it is hardly good, but also it does not need to completely bad. The decision depends on the perception of the evaluator. The <em>subjective feeling</em> does matter. And the same applies when one tries to judge a design. It does not matter whether it is a UI design or API design. Again the personal perception is important.</p>
</div>
<div class="paragraph">
<p>On the other hand software engineering is (or at least should be) done by engineers and important part of engineering is its measurability. So the ultimate goal for reasoning about design is to make it measurable, to suppress the subjective opinions and define set of requirements that will be used to measure the quality of the design. Of course defining the requirements might need some personal opinions, but as soon as they are written down, one can become pure engineer and use pure scientific methods to measure how much they are satisfied.</p>
</div>
<div class="paragraph">
<p>But as shown on the example of a good/bad program, the users <em>subjective feeling</em> is important. And it is important in design as well. But in case of <em>API</em>, which stands for the interface between the internals of an application and a programatic usage of its functionality, the person that will have the <em>subjective feeling</em> is the programmer using the <em>API</em>. He is the <em>API</em> user. He is the one that will judge the design and represent opinions whether it is good or bad. Of course, such opinions will be absolutely personal, based on personal experience gain during learning the desing and using the API. The easier is for the <em>API</em> users to make their job done, the better perception of the design they will get.</p>
</div>
<div class="paragraph">
<p>The external programmer is more concerned by the time needed to learn the API, by the amount of code needed to get his tasks done and by the stability of the contract. The art of making good API lays exactly in meeting these opposite requirements.</p>
</div>
<div class="paragraph">
<p>As usually one shall optimize for larger audience, for bigger effect. Usually the amount of people using an API is a way larger than those coding it, and that is why one shall take a special care to simplify the life of these users. Little uneasiness in implementing the application is acceptable, if the life of majority of users is simpler. To better address user needs it is necessary to know and understand their requirements. If an API allows easy implementation of the common tasks, it is a good API.</p>
</div>
<div class="paragraph">
<p>That is why the initial step in API design is to investigate and collect the scenarios for possible uses of the application. Having these use cases written down allows evaluation of each aspect of the API and validation of the design. The use cases serve as a fixed point to which one validates the design of API. It is practically impossible to jugde the quality of a design, but it is relatively easy to check whether the design satisfies required use cases or not.</p>
</div>
<div class="paragraph">
<p>Once a usecase becomes supported, it should stay supported until the end of the world (e. g. until it is not interesting anymore).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Life-cycle_of_an_API"><a class="anchor" href="#Life-cycle_of_an_API"></a>Life-cycle of an API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There seems to be two ways a feature can become an <em>API</em> (defining <em>API</em> as a stable interface that others can use over time without unpleasant surprises). An <em>API</em> can be evolved</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>spontaneously</strong> - someone is developing a feature, and another person finds it useful and starts to use it. Later they find out about each other, share their experiences and very likely find that the original design of the feature is not general enough or that it was never intended to be treated as an <em>API</em> In order to evolve it toward being an <em>API</em> they discuss changes to make the feature better and after few iterations it can become a useful and stable contract.</p>
</li>
<li>
<p><strong>by design</strong> - there is a known need for a contract between two components of the system. The requirements are collected, the problem area investigated, the use cases understood, and then someone designs and writes the <em>API</em>. Now others can use it in real world, comment, file bugs and enhancements which results in improvements to the <em>API</em> and finally evolve it into a state where it is a useful and stable contract.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In spite that these cases start differently they share the same attributes: Both of them need some time for feedback and evaluation before the <em>API</em> can be known to work and suit its purpose. Not every effort ends as its life as a stable API; sometimes it may turn out that the chosen way leads nowhere and then it is better to abandon the work.</p>
</div>
<div class="sect2">
<h3 id="_api_stability"><a class="anchor" href="#_api_stability"></a>API Stability</h3>
<div id="categories" class="paragraph">
<p>In order to clearly communicate what stage an <a href="./" class="xref page">API</a> is
in, whether it is still being evolved, whether it is expected to ever be real
<em>API</em> or whether it is stable and ready to use, let us introduce a system of
<a href="../API_Stability/" class="xref page">stability clasification for APIs</a>. The aim is to
give the code authors way how to communicate their intention with particular
feature and others to find out such information.</p>
</div>
<div class="sect3">
<h4 id="private"><a class="anchor" href="#private"></a>Private</h4>
<div class="paragraph">
<p><strong>Private</strong> is a category for features that are accessible but are not intended
for use outside of their component (module). Such features are subject to
change with every release and depending on them is risky and should be avoided.</p>
</div>
</div>
<div class="sect3">
<h4 id="friend"><a class="anchor" href="#friend"></a>Friend</h4>
<div class="paragraph">
<p><strong>Friend</strong> <a href="./" class="xref page">API</a> is used for features accessible to
specific components in the system, that help to overcome the lack of a real
stable <a href="./" class="xref page">API</a>, but are intended only for use between
these <em>friend</em> components and nobody else. Often friend components are
developed by the same group of people. A change to this contract can be done
every release, but owners of those <em>friend</em> components must be notified in
advance. No one else should depend on such features - the author of this API
does not have the intent to create a general purpose API.</p>
</div>
</div>
<div class="sect3">
<h4 id="devel"><a class="anchor" href="#devel"></a>Devel</h4>
<div class="paragraph">
<p><strong>Under development</strong> is a name for a contract that is expected to become a
stable API, but that has not yet been finished. The current state serves as a
proof of concept, and others are encourage to try it and comment on a dedicated
mailing list. Incompatible changes may be done between releases, but should be
rare, not radical and properly announced on the mailing list.</p>
</div>
</div>
<div class="sect3">
<h4 id="stable"><a class="anchor" href="#stable"></a>Stable</h4>
<div class="paragraph">
<p><strong>Stable</strong> interfaces are those that have received a final state and the
maintainers are ready to support it forever and never change them incompatibly.
The "forever" and "never" should not be taken as absolute: It is possible to
change the contract, but only in major versions and only after a careful
considerations and in cases where it is imperative that a change be made.
Stable contracts should <strong>preserve the investments</strong> of those entering into
them (users of an <a href="./" class="xref page">API</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="official"><a class="anchor" href="#official"></a>Official</h4>
<div class="paragraph">
<p><strong>Official</strong> are <a href="#stable">stable</a> ones and also packaged into one of NetBeans
official namespaces: <code>org.netbeans.api</code> or <code>org.netbeans.spi</code> or <code>org.openide</code>.
By packaging a contract into this package (and making it part of a release) one
notifies others that the contract is
<a href="../APIDevelopment/#Official_APIs_Restrictions" class="xref page">stable - with all the
consequence</a> (except the conditional support for
<a href="../APIDevelopment/#Support_for_Early_Adoption" class="xref page">early adoptions</a> - such
modules has code base name that ends with with /0). Also, the impact of
possible incompatible changes to <em>official</em> API should be minimized by
providing compatibility bridges and keeping binary compatibility even when
source one is droped (see the <a href="#Preservation_of_Investments">preservation</a>
section).</p>
</div>
</div>
<div class="sect3">
<h4 id="third_party"><a class="anchor" href="#third_party"></a>Third Party</h4>
<div class="paragraph">
<p><strong>Third party</strong> interfaces are provided by other parties that do not follow the
<em>NetBeans</em> rules and thus are hard to classify. It is prefered not to expose
such interfaces as part of own contracts, in order to insulate users of
NetBeans APIs from unexpected changes made in the imported interfaces.</p>
</div>
</div>
<div class="sect3">
<h4 id="standard"><a class="anchor" href="#standard"></a>Standard</h4>
<div class="paragraph">
<p><strong>Standard</strong> is similar to the <em>third party</em> classification. Also provided by
someone out of <em>NetBeans</em>, but by someone expected to evolve the interface in
compatible way (for example <a href="http://www.jcp.org">JSRs</a>). The standard is
expected to not change frequently.</p>
</div>
</div>
<div class="sect3">
<h4 id="deprecated"><a class="anchor" href="#deprecated"></a>Deprecated</h4>
<div class="paragraph">
<p><strong>Deprecated</strong>. After a while, nearly every <em>API</em>, regardless of what state it
is, becomes obsoleted. Usually a new, better support for the same task has been
developed which replaces the old <em>API</em>. In such case, mark the old <em>API</em>
<code>deprecated</code>. A previously stable <em>API</em> that changed its stability
to <code>deprecated</code> shall be supported for reasonable amount of time (a
release) to communicate to users that they shall migrate from it to the new
replacement. After that time the API can be removed from the product, while
trying to preserve it for old clients by making it available in alternative
ways (e. g. autoupdate centers).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The content in this page was kindly donated by Oracle Corp. to the Apache Software Foundation.</p>
</div>
<div class="paragraph">
<p>This page was exported from <a href="http://wiki.netbeans.org/API%20Stability">http://wiki.netbeans.org/API%20Stability</a> , that was last modified by NetBeans user Jtulach on 2012-01-07T22:32:21Z.</p>
</div>
<div class="paragraph">
<p>This document was automatically converted to the AsciiDoc format on 2020-03-12, and needs to be reviewed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>At the beginning of this chapter two different ways have been mentioned how an
API can be developed. Doing that <strong>spontaneously</strong> means in the light of the
above <a href="../API_Stability/" class="xref page">API Stability</a> categories to introduce a
<em>private</em> or <em>friend</em> <a href="./" class="xref page">API</a>, that is discovered by
someone else, found useful and than evolves into <em>stable</em> one as described. An
<a href="./" class="xref page">API</a> developed by design is more likely to begin its
life with <em>under development</em> <a href="../API_Stability/" class="xref page">API Stability</a> status
and after a bit of work can turn into <em>stable</em> API.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Preservation_of_Investments"><a class="anchor" href="#Preservation_of_Investments"></a>Preservation of Investments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the most important things for NetBeans is fair treatment of our partners. Module authors, platform extenders, contributors and others have to be sure that their work will not vanish or break whenever a new release of NetBeans is announced. Their work has a right to be respected and admired. As long as NetBeans succeeds at that we can be sure that our partners will describe their experience to others and evangelize and evolve the NetBeans community.</p>
</div>
<div class="paragraph">
<p>Because different parts of the system communicate with each other using public contracts (API, SPI, registration places, defined functional behavior), the way to preserve participants' investments is to always evolve these contracts in compatible ways. Each new version of NetBeans should make sure that it allows existing modules to execute and work in reasonable way, or, failing that, that it is easy to update existing sources to compile and use the contracts of the new release.</p>
</div>
<div class="sect2">
<h3 id="Maintained_.26amp.3B_unmaintained"><a class="anchor" href="#Maintained_.26amp.3B_unmaintained"></a>Maintained &amp; unmaintained</h3>
<div class="paragraph">
<p>Another reason why it is necessary that previous versions of modules continue to work is that often there is a module that works well and does an excellent job for its users, but in reality it is unmaintained. This can happen because the owner has left, works on different project or the company that created it does not exist anymore. There are even some projects on netbeans.org which are unmaintain but still serving their users well. If a new NetBeans version is released and introduces serious incompatibilities so the module fails to work, it is the authors of NetBeans who get blamed and shamed. That is why support for previously compiled modules is a necessary step: We must respect work that has been done and is currently unmaintained.</p>
</div>
<div class="paragraph">
<p>On the other hand, the owner may still be alive, and want to bring their code up to date - for example, one of the reasons for changes to APIs is to improve performance, something any module author would want to take advantage of. This should be easy to do, requiring no work in most cases. However, even if great attention is paid to evolving the APIs well, in some cases updating may require a bit of work. If someone is maintaining a module, they are expected to make the necessary updates to the code to bring keep it in line with the current API set.</p>
</div>
</div>
<div class="sect2">
<h3 id="Examples"><a class="anchor" href="#Examples"></a>Examples</h3>
<div class="paragraph">
<p>Even the biggest currently known change of behavior (the classpath change planned for 4.0) still allows a user to use a module developed against previous version of NetBeans and correctly use its functionality. If someone wants to use an old module, the only necessary thing is to setup the roots of filesystems to match the classpath.</p>
</div>
<div class="paragraph">
<p>On the other hand, APIs are designed by human beings, and the best of APIs may still contain things that turn out later to be mistakes. One example of such a mistake is the Node.Cookie marker interface, which restricts the usability of Cookies and forces a dependency on the nodes package that is not strictly necessary. This interface should be removed. As such the Node.Cookie Node.getCookie (Class) method will be changed to Object Node.getCookie (Class). Even after the change it can be guaranteed that old modules will continue to run. On the other hand, the originally correct source code cannot compile anymore. It is observed that 99% of all uses of that method will continue to compile - like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MyCookie c = (MyCookie)node.getCookie(MyCookie.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The remaining 1% of uses, which look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Node.Cookie c = node.getCookie(something);</code></pre>
</div>
</div>
<div class="paragraph">
<p>will have to be updated, but active module authors will do it gladly because they profit by having their classes become more flexible, and the change that must be done is very simple. Of course instruction for doing this update has to be prominent part of release migration guide.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Design_Practices"><a class="anchor" href="#Design_Practices"></a>Design Practices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s talk about actual Java design practices and patterns that help the writer and maintainer to achieve the general suggestions and rules that have been discussed in previous chapters and the make the user of an API feel comfortable, unsurprised and happy.</p>
</div>
<div class="sect2">
<h3 id="Do_not_expose_more_than_you_want"><a class="anchor" href="#Do_not_expose_more_than_you_want"></a>Do not expose more than you want</h3>
<div class="paragraph">
<p>Obviously the less of the implementation is expressed in the API, the more flexibility one can have in future. There are some tricks that one can use to hide the implementation, but still deliver the desired functionality. This section will discuss some of such tricks.</p>
</div>
<div class="sect3">
<h4 id="Method_is_better_than_Field"><a class="anchor" href="#Method_is_better_than_Field"></a>Method is better than Field</h4>
<div class="paragraph">
<p>It is better to use methods (usually getters and setters) to access fields than to expose them directly. The first reason is that a call to a method can do a lot of additional things, but in contrast an access to a field can only read or write the value. When using getters one can for example do lazy initialization, synchronize the access or compose the value using some computation algorithm. Setters on the other hand allow checks for correctness of assigned value or notification of listeners when the change happens.</p>
</div>
<div class="paragraph">
<p>The other reason why to prefer methods can be found in the <em>Java Virtual Machine</em> specification. It is allowed to move a method from a class to one of its superclasses and still remain binary compatible. So a method initially introduced as <code>Dimension javax.swing.JComponent.getPreferredSize(Dimension d)</code> can be deleted in new version and moved to <code>Dimension java.awt.Component.getPreferredSize(Dimension d)</code> as the <code>JComponent</code> is a subclass of <code>Component</code> (this really happened in JDK 1.2). Such operation is not allowed for fields. Once a field is defined in a class, it has to stay there forever in order to keep binary compatibility. That is another reason why it is better to keep fields private.</p>
</div>
</div>
<div class="sect3">
<h4 id="Factory_is_better_than_Constructor"><a class="anchor" href="#Factory_is_better_than_Constructor"></a>Factory is better than Constructor</h4>
<div class="paragraph">
<p>It is more flexible to expose a factory method than to expose constructor. Once a constructor is available as part of an API, it guarantees not only that an instance assignable to a given class will be created, but also that the instance will be of the <strong>exact class</strong> (no subclasses allowed) and also that a <strong>new instance</strong> is created every time.</p>
</div>
<div class="paragraph">
<p>If instead a factory method is provided (usually a static method that takes the same arguments as the constructor and returns instance of the same class the constructor is defined in), one has more possibilities. First of all one does not need to return the exact class, but some subclass - allows to use polymophism and possibly clean up the code. Second avantage is to cache instances. While in case of constructor new instance is created every time, the factory method can cache previously instantiated objects and reuse them in order to save the memory. Another reason is the possibility of proper synchronization when invoking the factory method which is not possible (at least is limited) in case of plain constructor. These are the reasons why one shall prefer factory methods over constructors.</p>
</div>
</div>
<div class="sect3">
<h4 id="Make_Everything_Final"><a class="anchor" href="#Make_Everything_Final"></a>Make Everything Final</h4>
<div class="paragraph">
<p>In a lot of cases people are not designing for subclassing and still they do
not prevent it. If you are writing an API and you explicitly do not want people
to subclass or implement your interfaces (also see paragraph about
[#design.apiandspi API vs. SPI]) it is better to disallow that.</p>
</div>
<div class="paragraph">
<p>Simplest solution is to make your class <code>final</code>. Other tricks include non-public constructors (one shall do it anyway in favor of [#design.less.factory factory methods]) or making all (or at least most) methods <code>final</code> or <code>private</code>.</p>
</div>
<div class="paragraph">
<p>Of course this works only for classes, if you decide to use interfaces you cannot forbid foreign implementations on the level of virtual machine, you can only ask people in JavaDoc not to do it.</p>
</div>
</div>
<div class="sect3">
<h4 id="Allow_access_only_from_a_friend_code"><a class="anchor" href="#Allow_access_only_from_a_friend_code"></a>Allow access only from a friend code</h4>
<div class="paragraph">
<p>Another useful technique to not expose too much in API is to give access to certain functionality (e. g. ability to instantiate a class or to call a certain method) just to a friend code.</p>
</div>
<div class="paragraph">
<p>Java by default restricts the friends of a class to those classes that are in the same package. If there is a functionality that you want share just among classes in the same package, use <em>package-private</em> modifier in definition of a constructor, a field or a method and then it will remain accessible only to friends.</p>
</div>
<div class="paragraph">
<p>Sometimes however it is more useful to extend the set of friends to a wider
range of classes - for example one wants to define a pure API package and put
the implementation into separate one. In such cases following trick can be
found useful. Imagine there is a class item (btw. also you can also check out
<a href="http://treefs.netbeans.org/source/browse/treefs/apidesign/friendpackage/">sources
from CVS</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class api.Item {
    /<strong> Friend only constructor <strong>/
    Item(int value) {
        this.value = value;
    }

    /</strong> API method(s) */
    public int getValue() {
        return value;
    }

    /</strong>* Friend only method */
    final void addListener(Listener l) {
        // some impl
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>that is part of the API, but cannot be instanitated nor listened on outside of the friend classes (but these classes are not only in api package). Then one can define an <code>Accessor</code> in the non-API package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public abstract class impl.Accessor {
    public static Accessor DEFAULT;

    public static Accessor getDefault() {
        if (DEFAULT != null) {
            return DEFAULT;
        }

        // invokes static initializer of Item.class
        // that will assign value to the DEFAULT field above
        Class c = api.Item.class;
        try {
            Class.forName(c.getName(), true, c.getClassLoader());
        } catch (ClassNotFoundException ex) {
            assert false : ex;
        }
        assert DEFAULT != null : "The DEFAULT field must be initialized";
        return DEFAULT;
    }

    /<strong> Accessor to constructor */
    public abstract Item newItem(int value);
    /</strong> Accessor to listener */
    public abstract void addListener(Item item, Listener l);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with abstract methods to access all friend functionality of the <code>Item</code> class and with a static field to get the accessor&#8217;s instance. The main trick is to implement the <code>Accessor</code> by a (non-public) class in the <code>api</code> package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final class api.AccessorImpl extends impl.Accessor {
    public Item newItem(int value) {
        return new Item(value);
    }
    public void addListener(Item item, Listener l) {
        item.addListener(l);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and register it as the default instance first time somebody touches <code>api.Item</code> by adding a static initializer to the <code>Item</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class Item {
    static {
        impl.Accessor.DEFAULT = new api.AccessorImpl();
    }

    // the rest of the Item class as shown above
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the <em>friend</em> code can use the accessor to invoke the hidden functionality from any package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">api.Item item = impl.Accessor.getDefault().newItem(10);
impl.Accessor.getDefault().addListener(item, this);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please note that in <em>NetBeans</em> this is very useful in combination with specifying publicly accessible packages in module manifest (<code>OpenIDE-Module-Public-Packages: api.**</code>) and thus disallowing on the class loading level other modules from accessing the <code>impl.Accessor</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Separate_API_for_clients_from_support_API"><a class="anchor" href="#Separate_API_for_clients_from_support_API"></a>Separate API for clients from support API</h3>
<div class="paragraph">
<p>Are there really more types of API? If so, how do they differ? Do the users of those types differ? Do they have different expectations? Those are questions that shall be answered in the first part of this section. Then we will try to define the restrictions on evolution of different types of API, and present some tips, tricks and lessons learned, which one can use to achieve and enforce such restrictions.</p>
</div>
<div class="sect3">
<h4 id="The_Client_vs._Provider_API"><a class="anchor" href="#The_Client_vs._Provider_API"></a>The Client vs. Provider API</h4>
<div class="paragraph">
<p>Before we start, we should ask a question: Who is the client and who is the provider? Let us do it on an example of <em>XMMS</em>, the media player for _UNIX_es (called WinAmp on another platform).</p>
</div>
<div class="paragraph">
<p>The player can play audio files, can skip to next song, return to previous one, offers a playlist with possibility to add, remove and reorder songs. The functionality is provided for users, but accessible to other programs as well. So a program can call <code>xmms.pause()</code> or <code>xmms.addToPlaylist(filename)</code>. As can be seen, the communication is initiated by the other program that uses the player&#8217;s API to instruct it to perform an action. After the execution of the command ends, the control returns back to the caller. Let&#8217;s name the caller a client and such an API a <em>client API</em>.</p>
</div>
<div class="paragraph">
<p>On the other hand, the <em>XMMS</em>' APIs also allows third parties to register <em>output plugin_s. The functionality of the default player can be extended by providing a utility method that writes the played data to a disk, broadcasts it over a network, etc. The communication is in this case initiated by the player itself. After collecting enough data for playback, the program locates the current output plugin and sends it the data to process: <code>plugin.playback (data)</code>. After finishing the playback the execution is returned back to the player that can continue in gathering more data and the whole process continues. Is the plugin a client? Well, it is in completely different position than the client in previous paragraph. It does not instruct _XMMS</em> to do something, it increases the list of things <em>XMMS</em> can do. So no, the plugin is not a client. <em>XMMS</em> ability to register plugins is a <em>Service Provider Interface</em>, or SPI.</p>
</div>
</div>
<div class="sect3">
<h4 id="Expressing_API.2FSPI_in_C_and_Java"><a class="anchor" href="#Expressing_API.2FSPI_in_C_and_Java"></a>Expressing API/SPI in C and Java</h4>
<div class="paragraph">
<p>In this section we will discuss the actual implementation of the API in two sample languages - procedural C and object oriented Java.</p>
</div>
<div class="paragraph">
<p>The C language is ready and suitable for expressing (client) API. One just writes the methods and announces them in the header files, so others can compile agaist them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void xmms_pause();
void xmms_add_to_playlist(char *file);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Java way is not much different:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class XMMS {
    public void pause();
    public void addToPlaylist(String file);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but one has more choices. It is possible to declare these methods static, to leave them as instance methods, make them abstract, final, etc. But generally speaking, the way C and Java handle client APIs is nearly similar. However the situation is a far different when writing an SPI.</p>
</div>
<div class="paragraph">
<p>In order to write own plugin for <em>XMMS</em> in C one has to start with a method that will do the playback. So the a plugin must define:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void my_playback(char *data) {
    // do the playback
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the player itself has to have some registration method, for example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void xmms_register_playbackvoid)(f*)(char*;</code></pre>
</div>
</div>
<div class="paragraph">
<p>that the plugin should call to register itself. ` xmms_register_playback(my_playback)` and its playback function is then called by the <em>XMMS</em> whenever necessary. In Java the contract starts with a definition of playback interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface XMMS.Playback {
    public void playback(byte[] data);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>then my plugin has to implement that interface <code>MyPlayback implements XMMS.Playback</code> and register that instance to the player:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">XMMS.registerPlayback(new MyPlayback());</code></pre>
</div>
</div>
<div class="paragraph">
<p>and that is all. The player can do its calls to the plugin as it could in case of C. The major difference is that writing this kind of code is taught in Java courses without a proper explanation of what it really means.</p>
</div>
<div class="paragraph">
<p>In the C case, the amount of work to produce an SPI (for example callback) is high enough to prevent beginner from even trying it. One&#8217;s knowledge has to grow significantly to get to state when one can (or will need to) design an SPI. But in Java any declared method that is not private, final or static is defacto an invitation for someone to provide a callback and thus an accidental SPI. This is often not well understood by programmers, teachers, and is not part of conventional wisdom. Any Java book introduces public, non-static and non-final methods in one of the first chapters (at least as soon as it starts to talk about Applets) without a proper warning of all consequences. That may be fine for simple development, but when one starts to design APIs, all habits learned at the begining turn into mistakes.</p>
</div>
</div>
<div class="sect3">
<h4 id="Evolution_of_API_is_a_different_process_than_evolution_of_SPI"><a class="anchor" href="#Evolution_of_API_is_a_different_process_than_evolution_of_SPI"></a>Evolution of API is a different process than evolution of SPI</h4>
<div class="paragraph">
<p>Evolution is a natural part of any contract. After a time everything gets obsoleted, insufficient or broken. APIs and SPIs are not exceptions. So it is better be prepared for evolution at the begining, plan for it and avoid mistakes that would otherwise be hard to undo.</p>
</div>
<div class="paragraph">
<p>In case of an API that is offering methods to clients, there is no problem with additions. Extending the functionality to offer more functionality to clients cannot hurt them - if they do not want they do not need to use it.</p>
</div>
<div class="paragraph">
<p>In the cas of an SPI, the situation is exactly the oposite. Adding new method into an interface that others must provide effectively breaks all existing implementations, because they do not implement it!  On the other hand it acceptable and valid to stop calling (de facto removal) a method from an SPI. If the operation flow is not part of the contract, not calling one method should not break anything.</p>
</div>
<div class="paragraph">
<p>So the way of evolution depends on the type of the interface: API additions are fine but removing functionality is not; SPI de-facto removals are allowed, but additions are not. At the begining of producing a contract, one should realize and understand which parts will be API that clients will call, and what will be SPI that will extend the functionality one is writing. The biggest mistake that one can make is to <em>mix API and SPI together</em> into one class. Then there is no room for evolution. Adding a method is forbidden because of the contract for SPIs and removing because of the contract for APIs. <em>Always separate API and SPI</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="Example"><a class="anchor" href="#Example"></a>Example</h4>
<div class="paragraph">
<p>As an example let us choose <code>DataObject</code> class, a part of the
<a href="https://bits.netbeans.org/dev/javadoc/org-openide-loaders/org/openide/loaders/DataObject.html">Data
System API</a>. It is used for by clients to obtain a logical, representation of a
file or set of files, and logically manipulate their contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// locate a data object
DataObject obj = DataObject.find(fo);
// move it to different place
obj.move(destination);
// try to open it if supported
OpenCookie o = (OpenCookie)obj.getCookie(OpenCookie.class);
if (o != null) {
    o.open();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But the problem is that this client API is mixed together with a lot of methods
provided just for subclasses (those that are protected in
<a href="https://bits.netbeans.org/dev/javadoc/org-openide-loaders/org/openide/loaders/DataObject.html">javadoc</a>).
They pointlessly clutter the API and moreover prevent the API from being
extended in future.  Moreover not only do the API and SPI conflict and make
evolution difficult, but the execution flow between API and SPI resulted in a
lot of flow clashes - deadlocks.</p>
</div>
<div class="paragraph">
<p>That is why during design of
<a href="http://openide.netbeans.org/proposals/loaders/">new data systems</a> the
<code>DataObject</code> has been reserved just for the API. It is supposed to be final and
fully controlled by the implementation. The actual behaviour is provided by a
separate SPI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface DataObjectOperator {
     // delegated to from DataObject.move(DataFolder df)
    public void move(DataObject obj, DataFolder target);
    // delegated to from DataObject.rename(String name)
    public void rename(DataObject obj, String name);
    // delegated to from DataObject.getCookie(Class clazz)
    public Object getCookie(DataObject obj, Class clazz);
    // etc.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By separating the API from SPI and fully controlling the flow between them we can evolve the API and SPI independently and moreover add various pre-condition and post-condition checks between the actual client and provider. For example it is simple to add a new method <code>DataObject.move(DataFolder df, String newName)</code> to the API that should move the object and rename it at once and bridge it as <code>move</code> and <code>rename</code> calls into the <code>DataObjectOperator</code> by default and (in case of of new improved operators) to the new method <code>moveAndRename(DataObject obj, DataFolder df, String name)</code> if provided.</p>
</div>
<div class="paragraph">
<p>The new data systems should be an example of good design that is aware that <em>what&#8217;s good for SPI implementors isn&#8217;t necessarily good for API clients</em>, tries to give the API a chance to evolve and also <em>restrict SPI implementors as little as possible</em>.</p>
</div>
<div class="paragraph">
<p>Another example in case you are not yet convinced:
<a href="https://bits.netbeans.org/dev/javadoc/org-netbeans-modules-project-ant/org/netbeans/api/project/ant/AntArtifact.html">AntArtifact</a>
was originally made an abstract class, rather than an interface, so that some
final methods like <code>getArtifactFile</code> and <code>getScriptFile</code> could be added for
clients, and <code>getID</code> could be defaulted. It seemed reasonable at the time. Of
course, it turned out that later the SPI part had to be extended to support
multiple artifacts and properties. Adding support for properties was easy
enough to do compatibly, but adding support for multiple artifacts was messier:
we had to deprecate the old single-artifact getters and introduce new getters,
while preserving compatibility for old implementations. It would have been
simpler to do had there been a final class <code>AntArtifact</code> with a factory method
accepting an SPI interface <code>AntArtifactImpl</code> (or the like), since we could have
produced a new SPI interface and a new factory method.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Interfaces_vs._abstract_classes"><a class="anchor" href="#Interfaces_vs._abstract_classes"></a>Interfaces vs. abstract classes</h3>
<div class="paragraph">
<p>There seems to be long, never-ending flame war between those who prefer the strict use of interfaces and those who like abstract classes. Such discussions continue forever, starting usually every few months again and leading nowhere, because people tend to hold to their opinions. Often such discussions start with no common ground - no agreement on use cases or requirements. Below we will look at the problem from use case point of view.</p>
</div>
<div class="sect3">
<h4 id="The_Advantages_of_Interfaces"><a class="anchor" href="#The_Advantages_of_Interfaces"></a>The Advantages of Interfaces</h4>
<div class="paragraph">
<p>The most obvious one is that <em>usage of the type</em>, if implemented as an abstract class, is limited as java doesn&#8217;t allow multiple inheritance of classes. This only becomes a problem when a type is huge, or when it significantly enhances developer productivity to be able to subclass and reuse a base implementations. We will call these <em>support classes</em>, where one is expected to subclass and reuse a base class&#8217;s implementation.</p>
</div>
<div class="paragraph">
<p>The second advantage of interfaces is that there is an <em>enforced separation between the API and the implementation</em>. But this can be achieved with abstract classes too, with a bit of self control, while in interfaces that is enforced by the compiler.</p>
</div>
</div>
<div class="sect3">
<h4 id="The_Advantages_of_Abstract_Classes"><a class="anchor" href="#The_Advantages_of_Abstract_Classes"></a>The Advantages of Abstract Classes</h4>
<div class="paragraph">
<p>The main reason why people prefer to use abstract classes is their <em>ability to evolve in a time</em> - it is possible to add a new method with a default implementation without breaking existing clients or implementors (here we talk about runtime compatibility, not compile time one). Interfaces lack such functionality, so it is necessary to introduce another interface to provide future extensions. So you end up with a lot of interfaces such as <code>interface BuildTargetDependencyEx extends BuildTargetDependency</code> with additional methods. The original interface is still valid, the new one is available.</p>
</div>
<div class="paragraph">
<p>A second very useful feature of abstract classes is the possibility of <em>restricting access rights</em>. Every method in a public interface is public and everybody can implement the interface. That for example means anybody can implement such interface, but in real life, one often wants to restrict that and have the creation under control. Interfaces lack such restrictions.</p>
</div>
<div class="paragraph">
<p>Another thing that is possible with abstract classes is that they can contain static methods. Of course that with interface one can create separate classes with factory methods, but the truth is that a class is usually the most natural and reasonable place for factory methods that return instances.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Use_cases"><a class="anchor" href="#Use_cases"></a>Use cases</h3>
<div class="paragraph">
<p>Let&#8217;s now give few real world examples and discuss whether the use of one or the other approach has some benefits and why.</p>
</div>
<div class="sect3">
<h4 id="TopManager"><a class="anchor" href="#TopManager"></a>TopManager</h4>
<div class="paragraph">
<p>The <a href="https://github.com/apache/netbeans/tree/master/platform/openide/src/org/openide/TopManager.java?content-type=text/plain"> TopManager </a> is one of the oldest types in the NetBeans Open APIs and was designed to bridge between the <code>org.openide.*</code> packages and their implementation in <code>org.netbeans.core</code>. There is just one instance of the manager (provided by the core) and clients of the API are not at all expected to extend/implement that type.</p>
</div>
<div class="paragraph">
<p>Analysis shows that this is a typical situation of providing a lot of utility
methods to clients with complete control over the implementation, where
attention is be paid to ease of use for clients of such API, while permitting
dynamic discovery of the implementation (the API is in different compilation
unit [openide] than its implementation [core]).</p>
</div>
<div class="paragraph">
<p>This is a situation where one cannot gain any advantage by using interfaces
over using abstract classes. One needs a factory method, one can add new
methods, separation between API and implementation is in the right hands and
there is also the possibility to prevent instantiation of other instances than
the default one. If you happen to be in similar situation, it is best to use an
abstract class.</p>
</div>
<div class="paragraph">
<p>An example what can happen if one chooses to use an interface is located next
to <code>TopManager</code> in the same package - the
<a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/Places.java?content-type=text/plain">
Places </a> interface. In reality it is the same singleton as the <code>TopManager</code>, it
is accessed via the factory method <code>TopManager.getDefault().getPlaces()</code>. All
its methods could be part of the <code>TopManager</code> as well. We just wanted to
logically separate them and we did it using an interface. As a result, as newer
"places" that might be useful API were created, we were afraid to add a method
there after a time. Since we decided creating a <code>Places2</code> interface would be
overkill, the interface started to be less and less used and now is nearly
obsolete.</p>
</div>
</div>
<div class="sect3">
<h4 id="Cookies"><a class="anchor" href="#Cookies"></a>Cookies</h4>
<div class="paragraph">
<p>The <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/"> cookies </a> are a coding pattern that allows any object to provide a specific feature (called cookie) by calling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">OpenCookie openCookie = (OpenCookie)anObject.getCookie(OpenCookie.class);
if (openCookie != null) {
    openCookie.open();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Should the <code>OpenCookie</code> be interface or abstract class? Simple analysis can show that there is a lot of clients, users of the API, and also a lot of providers, often wanting to provide more cookies at once. Moreover the cookie itself contains just one method <code>open</code>. All of the that leads to answer that the type should be an interface. We have the ability for multiple inheritance, and there is no fear of evolving the interface because it has just one method that does it all, no need for static factory methods, no need to prevent subclassing. Thus an interface is the right choice.</p>
</div>
<div class="paragraph">
<p>Very similar, but also very different example can be shown on another cookie - the <a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/cookies/InstanceCookie.java?content-type=text/plain"> InstanceCookie </a>. It is also an interface and it used to have three methods but after few releases we realized a need for another to improve performance. So we were forced to introduced a subclass <code>InstanceCookie.Of</code> extending <code>InstanceCookie</code> and adding method <code>instanceOf</code>. This of course works, but adds a lot of pressure to users of the interface. Everyone using the API has to code as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean doIAccept;
InstanceCookie ic = (InstanceCookie)obj.getCookie(InstanceCookie.class);
if (ic instanceof InstanceCookie.Of) {
    doIAccept = InstanceCookie.Of)ic).instanceOf(myRequiredClass); } else {     doIAccept = ic != null &amp;&amp;         myRequiredClass.isAssignableFrom(ic.instanceClass(;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code is not too simple and moreover is spread over the whole codebase. How much simpler it would be if we could just add a new method into the cookie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean isInstanceOf(Class c) {
    return c.isAssignableFrom(instanceClass());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but because java does not allow default methods in interfaces, we are out of luck. Should we have used abstract class? No, we should not, the use cases are similar as with <code>OpenCookie</code>, but there is another trick that (very likely) should have been used.</p>
</div>
<div class="paragraph">
<p>Instead of adding three methods into the interface we could add just one that would return a class with all necessary information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface InstanceCookie {
    public Info instanceInfo();

    public static class Info extends Object {
        public String intanceName();
        public Class instanceClass();
        public Object instanceCreate();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This solution seems to combine the best of both worlds. Clients have simple API, providers can implement instead of extend and in the <code>instanceInfo</code> method instantiate the info either with some provided constructor or factory methods or lazily using subclassing. Also when we need to add the <code>instanceOf</code> after few releases, we can. <code>InstanceCookie.Info</code> is a class and as such can be extended by a method with a default implementation.</p>
</div>
<div class="paragraph">
<p>Of course to make such methods additions safe, it is better to make the class final and provide factory methods that implementors of <code>InstanceCookie</code> could use. Those factory methods could either be simple, e.g. take values for <code>instanceName</code>, <code>instanceClass</code> and <code>instanceCreate</code> methods. Or the factory methods could take another interface with a methods that would be called to lazily handle the invocations of for example <code>Info.instanceCreate</code>. The actual solution depends on the needs of the users of the API.</p>
</div>
<div class="paragraph">
<p>Please notice that similar pattern is used by java listeners. Every listener is an interface and as such it has a constant (often one) number of methods. But each method takes a subclass of <a href="https://docs.oracle.com/javase/1.4/docs/api/java/util/EventObject.html">EventObject</a> which is a class and if necessary can be enhanced with a <a href="https://docs.oracle.com/javase/1.4/docs/api/java/awt/dnd/DragGestureEvent.html#startDrag(java.awt.Cursor,">java.awt.datatransfer.Transferable)  new method</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="FileObject"><a class="anchor" href="#FileObject"></a>FileObject</h4>
<div class="paragraph">
<p>Another example from NetBeans is the <a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/filesystems/FileObject.java?content-type=text/plain"> FileObject </a> (part of the <a href="https://bits.netbeans.org/dev/javadocorg-openide-filesystems/org/openide/filesystems/doc-files/api.html">filesystem API</a>). This type usage seems very close to the TopManager example (but is not as obvious): There are very few people directly subclassing <code>FileObject</code> (javadoc&#8217;s HttpFileSystem, Kyley and Niclas) and tons of client API users (every NetBeans module).</p>
</div>
<div class="paragraph">
<p>The amount of people directly subclassing <a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/filesystems/FileSystem.java?content-type=text/plain"> FileSystem </a> is the same as those doing that for <code>FileObject</code>, so it seems fine to choose abstract class for both types, but it is true that the filesystem would probably work as interface too.</p>
</div>
<div class="paragraph">
<p>Moreover there is a support class, the <a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/filesystems/AbstractFileSystem.java?content-type=text/plain"> AbstractFileSystem </a> that most of the people providing filesystem implementations are subclass. Because it is a support class, it needs to be a concrete class or at least a factory method, but it offers five interfaces (Info, Change, Attr, List, Transfer) that are not exposed in the client API for users of filesystems, but users of it may implement to write an filesystem implementation. People who write the own filesystem implement these interfaces most of the time and can use multiple interface inheritance. And because AbstractFilesystem implements the client API contract, anyone subclassing it can be sure they are implementing the full API, but only that API.</p>
</div>
</div>
<div class="sect3">
<h4 id="CloneableEditorSupport"><a class="anchor" href="#CloneableEditorSupport"></a>CloneableEditorSupport</h4>
<div class="paragraph">
<p>Can support <a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/text/CloneableEditorSupport.java?content-type=text/plain"> class</a>es be provided as interfaces? It is not easy. What kind of support would it be if one would have to provide implementation of each method! So, often abstract classes are used as base for support classes.</p>
</div>
<div class="paragraph">
<p>But one should carefully separate the support classes from the actual API (as the <code>CloneableEditorSupport</code> is in different package than the <a href="https://github.com/apache/netbeans/tree/master/platform//openide/src/org/openide/cookies/EditorCookie.java?content-type=text/plain"> EditorCookie </a> which it implements). Such separation ensures basic quality of design and prevents cheating - one needs to use just API methods even in the implementation and cannot rely on non-public hooks.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Interfaces_or_Classes"><a class="anchor" href="#Interfaces_or_Classes"></a>Interfaces or Classes?</h3>
<div class="paragraph">
<p>Is it better to use interfaces or a classes? None, could be simple answer to such general question. But if try to get down to the roots of the question we can get a better answers.</p>
</div>
<div class="paragraph">
<p>First of all only those people that are designing an API that will be maintained for a while, have to care. Those who are writing code to pass an exam do not need to. They can choose whatever they wish.</p>
</div>
<div class="paragraph">
<p>Second necessary thing is to treat users of your API well. If you do not care about them, do not care about the <em>interfaces or classes</em> question.</p>
</div>
<div class="paragraph">
<p>If these conditions are satisfied then, from the discussion above, one can see that classes are better for <em>client API</em> and interfaces for <em>service provider API</em>. So if you know that most of the users of an API will just make calls to it, it is better to use classes (and the best thing is to make them unsubclassable, that way one prevents accidental subclasses at all). If you want people just to subclass. Then choose interfaces, they are more safe and easy to use when subclassing. If your case is somewhere in between (which should be prevented according to [#design.apiandspi separation] paragraph) the choice is up to you, but carefully judge what people will do more often. You will not be sorry.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Case_Study_of_client_API_and_SPI_separation"><a class="anchor" href="#Case_Study_of_client_API_and_SPI_separation"></a>Case Study of client API and SPI separation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The previous example with <code>CloneableEditorSupport</code> claims that it is not easy to write support without classes, but the truth is it is not that complicated and moreover it really separates the SPI from the client API and allows easier and safe future evolution. Here is a sample rewrite of <code>CloneableEditorSupport</code> stuff using interfaces:</p>
</div>
<div class="paragraph">
<p>The main goal of <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/text/CloneableEditorSupport.java?rev=1.92&amp;content-type=text/x-cvsweb-markup&amp;showattic=1">CloneableEditorSupport</a> is to implement some interfaces <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/OpenCookie.java?rev=1.7&amp;content-type=text/x-cvsweb-markup&amp;showattic=1">OpenCookie</a>, <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/EditCookie.java?rev=1.6&amp;content-type=text/x-cvsweb-markup&amp;showattic=1">EditCookie</a> and <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/EditorCookie.java?rev=1.15&amp;content-type=text/x-cvsweb-markup&amp;showattic=1">EditorCookie</a> while letting the subclasses override abstract methods like <code>String messageName ()</code>, <code>String messageModified ()</code> and <code>String messageOpen ()</code> and provide and modify the behaviour of the abstract class. For implementation these methods the subclass can call some support functions like <code>protected final UndoRedo.Manager getUndoRedo()</code> and communicate with the superclass implementation using for example <code>protected Task reloadDocument()</code>. The whole already enough complex situation is additionally complicated by a fact that <em>nearly every method can be overriden by a subclass</em> which creates operating environment so wild that nobody can guess what combinations are possible and makes future evolution nearly impossible.</p>
</div>
<div class="sect2">
<h3 id="Move_Protected_Methods_Into_Interface"><a class="anchor" href="#Move_Protected_Methods_Into_Interface"></a>Move Protected Methods Into Interface</h3>
<div class="paragraph">
<p>The situation might be simplified by separating all methods that should be overriden in subclasses into own interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface CloneableEditorProvider {
    // methods that have to be overridden
    // in order for the functionality to work
    public String messageName();
    public String messageSave();

    // additional stuff described below
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and having a factory method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EditorCookie EditorFactory.createEditor(CloneableEditorProvider p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>that would convert the service provider interface into the desired client API (this is a bit simplified, the real API would have to support creation of multiple cookies <code>OpenCookie</code>, <code>EditCookie</code>, etc. for example by having additional argument of type <code>Class[]</code> that would specify all cookies the returned value should implement). Functionally this is equivalent to providing a class with abstract methods that should be implemented in subclasses, however in addition, it guarantees that nobody will be able to cast <code>EditorCookie</code> to <code>CloneableEditorProvider</code> and call some special methods on it because the <code>createEditor</code> method has to create new object for its result that bridges its functionality to the provider.</p>
</div>
</div>
<div class="sect2">
<h3 id="Passing_Notifications_to_Implementation"><a class="anchor" href="#Passing_Notifications_to_Implementation"></a>Passing Notifications to Implementation</h3>
<div class="paragraph">
<p>But the current state does not yet fully emulate the functionality of the old <code>CloneableEditorSupport</code> - the provider is not able to invoke <code>reloadDocument</code> or any similar one. In order to address this, let&#8217;s enhance the interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface CloneableEditorProvider {
    // the getter methods as in previous example
    public String messageSave();

    // the support for listeners
    public void addChangeListener(ChangeListener l)
        throws TooManyListenersException;
    public void removeChangeListener(ChangeListener l);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the factory methods will not just build an implementation of <code>EditorCookie</code>, but will also attach such implementation as a listener to the provider. As there will always be at most one listener, the method signagure throws <code>TooManyListenersException</code> to signal that the provider can implement the method in the most simple way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private ChangeListener listener;
public void addChangeListener(ChangeListener l)
        throws TooManyListenersException {
    if (listener != null) throw new TooManyListenersException();
    listener = l;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and does not need to bother with support for multiple listeners, while following the <strong>JavaBeans</strong> conventions. Whenever the provider needs to reload the document, it can just fire <code>listener.stateChanged (ev)</code> and the listening implementation will know that the reload of the document is requested.</p>
</div>
</div>
<div class="sect2">
<h3 id="Callbacks_to_Implementation"><a class="anchor" href="#Callbacks_to_Implementation"></a>Callbacks to Implementation</h3>
<div class="paragraph">
<p>The listener approach allows simple communication flow from the provider to the implementation when needed, but there is still something missing - ability to obtain <code>UndoRedo</code> via <code>CloneableEditorSupport.getUndoRedo</code>. In order to achieve that we might change the interface once more:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface CloneableEditorProvider {
    // the getter methods as in previous example
    public String messageSave();

    // the support callbacks
    public void attach(Impl impl) throws TooManyListenersException;

    // the class with methods for communication with the implementation
    public static final class Impl extends Object {
        public void reloadDocument();
        public UndoRedo getUndoRedo();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have replaced the listener with a special <code>Info</code> that contains all the methods that the provider can call on the implementation and added a method <code>attach</code> to allow registration of that class to any provider.</p>
</div>
<div class="paragraph">
<p>This is the final state. Everything that is supposed to be called from the implementation is in the <code>CloneableEditorProvider</code> interface, everything that is supposed to be called by a clients is not avaible as <code>EditorCookie</code> and is completelly under control of the <code>EditorFactory</code> and the callback communication from the provider to the factory is separated into the <code>CloneableEditorProvider.Impl</code>. This state can at first sight look more complex than the original <code>CloneableEditorSupport</code>, but it is much clearer and separates the concerns comparing to the original mess in the support.</p>
</div>
</div>
<div class="sect2">
<h3 id="Extensible_Client_Behaviour"><a class="anchor" href="#Extensible_Client_Behaviour"></a>Extensible Client Behaviour</h3>
<div class="paragraph">
<p>Anybody wants to add new user method or functionality into <code>EditorCookie</code>? Why not, just enhance the <code>EditorFactory</code> to create better implementation in its factory method. Is there a need to log requests from clients? Again, <code>EditorFactory</code> is the right place to do it. Necessary to provide some synchronization, deadlock prevention, etc? Where else then in <code>EditorFactory</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="Extensible_Communication_betwen_provider_and_implementation"><a class="anchor" href="#Extensible_Communication_betwen_provider_and_implementation"></a>Extensible Communication betwen provider and implementation</h3>
<div class="paragraph">
<p>As we have carefully choosen the <code>CloneableEditorProvider.Impl</code> to be final class, we can always add a new methods to it. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static final class CloneableEditorProvider.Impl extends Object {
    public void reloadDocument();
    public UndoRedo getUndoRedo();
    public void closeDocument();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>as far as we teach the implementation to understand what <code>closeDocument</code> means. Btw. actually the <code>Impl</code> acts as a client API for the <code>CloneableEditorProvider</code> and that is why it is better to make it class.</p>
</div>
</div>
<div class="sect2">
<h3 id="Extensible_Provider_Evolution"><a class="anchor" href="#Extensible_Provider_Evolution"></a>Extensible Provider Evolution</h3>
<div class="paragraph">
<p>It is often common that after a while the functionality of the <code>EditorCookie</code> might be improved, if the <code>CloneableEditorProvider</code> was a bit more capable. In the original <code>CloneableEditorSupport</code> example this would be solved by adding new (protected) method with default implementation in the <code>CloneableEditorSupport</code>, but as adding a method is always a bit dangerous (might introduce clashes - what used to compile in previous version need not compile anymore, or need not run anymore). The provider approach presented in this case study allows us to define</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface CloneableEditorProvider2 extends CloneableEditorProvider {
    /** Will be called when the document is about to be closed by user */
    public boolean canClose();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and (possibly) new factory method (possibly because the original method taking just <code>CloneableEditorProvider</code> could be enough)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EditorCookie EditorFactory.createEditor(CloneableEditorProvider2 p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>that will use the new interface for better implementation of the editor while keeping the same interface for client API.</p>
</div>
<div class="paragraph">
<p>Another example of this kind of evolution can be observed in a situation when the old provider interface is completely wrong and we want to replace it, or enhance the amount of choices be completely new:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface PaintProvider {
    public void paintImage(Image image);
}
/** Based on a ability to paint creates new EditorCookie */
EditorCookie EditorFactory.createEditor(PaintProvider p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In spite of that the service provider API has changed completely, the whole change is hidden in the factory that translates the calls between old client API to the new provider interface. Moreover there is no clash in evolution. Providers that really wishes to provide <code>CloneableEditorProvider</code> do that by implementing directly that interface, providers that want to handle the <code>closeDocument</code> call as well do that by implementing <code>CloneableEditorProvider2</code> and those that rely on the completely new paint style implement <code>PaintProvider</code>. Each of such providers explicitly specifies what SPI contract it wants to implement, this is much clearer than the possible mess with original evolution of <code>CloneableEditorSupport</code> based on adding methods to it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Using_games_to_Improve_API_Design_Skills"><a class="anchor" href="#Using_games_to_Improve_API_Design_Skills"></a>Using games to Improve API Design Skills</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Having good API design skills is very important for people who work and create an open source framework like NetBeans. It is indeed fine to read and study some [api-design.html API design guidelines], however there is no better learning approach than practicing the design in a situation simulating the reality. Read the [api-fest.html article about API Fest] to learn about the game called <em>API Fest</em> that the NetBeans core team created and played as part of improving their design skills.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The content in this page was kindly donated by Oracle Corp. to the Apache Software Foundation.</p>
</div>
<div class="paragraph">
<p>This page was exported from <a href="http://wiki.netbeans.org/API_Design">http://wiki.netbeans.org/API_Design</a>, that was last modified by NetBeans user Jtulach on 2012-01-07T22:30:47Z.</p>
</div>
<div class="paragraph">
<p>This document was automatically converted to the AsciiDoc format on 2020-03-12, and needs to be reviewed.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
      <section class='tools'>
    <ul class="menu align-center">
        <li><a title="Facebook" href="https://www.facebook.com/NetBeans"><i class="fa fa-md fa-facebook"></i></a></li>
        <li><a title="Twitter" href="https://twitter.com/netbeans"><i class="fa fa-md fa-twitter"></i></a></li>
        <li><a title="Github" href="https://github.com/apache/netbeans"><i class="fa fa-md fa-github"></i></a></li>
        <li><a title="YouTube" href="https://www.youtube.com/user/netbeansvideos"><i class="fa fa-md fa-youtube"></i></a></li>
        <li><a title="Atom Feed" href="https://netbeans.apache.org/blogs/atom"><i class="fa fa-mf fa-rss"></i></a></li>
        <li><a title="Slack" href="https://tinyurl.com/netbeans-slack-signup/"><i class="fa fa-md fa-slack"></i></a></li>
        <li><a title="Issues" href="https://github.com/apache/netbeans/issues"><i class="fa fa-mf fa-bug"></i></a></li>
    </ul>
    <ul class="menu align-center">
        <li><a href="https://github.com/apache/netbeans-antora-wiki/edit/main/modules/ROOT/pages/wiki/API_Design.adoc" title="See this page in github"><i class="fa fa-md fa-edit"></i> See this page in GitHub.</a></li>
    </ul>
</section>
      </article>
    </div>
        <div class='grid-container incubator-area' style='margin-top: 64px'>
      <div class='grid-x grid-padding-x'>
        <div class='large-auto cell text-center'>
          <a href="https://www.apache.org/">
            <img style="width: 320px" title="Apache Software Foundation" src="../../../../_/images/asf_logo_wide.svg" />
          </a>
        </div>
        <div class='large-auto cell text-center'>
          <a href="https://www.apache.org/events/current-event.html">
            <img style="width:234px; height: 60px;" title="Apache Software Foundation current event" src="https://www.apache.org/events/current-event-234x60.png"/>
          </a>
        </div>
      </div>
    </div>
    <footer>
      <div class="grid-container">
        <div class="grid-x grid-padding-x">
          <div class="large-auto cell">
            <h1><a href="../../../../front/main/about">About</a></h1>
            <ul>
              <li><a href="../../../../front/main/community/who">Who's Who</a></li>
              <li><a href="https://www.apache.org/foundation/thanks.html">Thanks</a></li>
              <li><a href="https://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li>
              <li><a href="https://www.apache.org/security/">Security</a></li>
            </ul>
          </div>
          <div class="large-auto cell">
            <h1><a href="../../../../front/main/community">Community</a></h1>
            <ul>
              <li><a href="../../../../front/main/community/mailing-lists">Mailing lists</a></li>
              <li><a href="../../../../front/main/community/committer">Becoming a committer</a></li>
              <li><a href="../../../../front/main/community/events">NetBeans Events</a></li>
              <li><a href="https://www.apache.org/events/current-event.html">Apache Events</a></li>
            </ul>
          </div>
          <div class="large-auto cell">
            <h1><a href="../../../../front/main/participate">Participate</a></h1>
            <ul>
              <li><a href="../../../../front/main/participate/submit-pr">Submitting Pull Requests</a></li>
              <li><a href="../../../../front/main/participate/report-issue">Reporting Issues</a></li>
              <li><a href="../../../../front/main/participate/#documentation">Improving the documentation</a></li>
            </ul>
          </div>
          <div class="large-auto cell">
            <h1><a href="../../../../front/main/help">Get Help</a></h1>
            <ul>
              <li><a href="../../../../front/main/help/#documentation">Documentation</a></li>
              <li><a href="../../../../wiki/main/wiki">Wiki</a></li>
              <li><a href="../../../../front/main/help/#support">Community Support</a></li>
              <li><a href="../../../../front/main/help/commercial-support">Commercial Support</a></li>
            </ul>
          </div>
          <div class="large-auto cell">
            <h1><a href="../../../../front/main/download">Download</a></h1>
            <ul>
              <li><a href="../../../../front/main/download">Releases</a></li>                    
              <li><a href="https://plugins.netbeans.apache.org/">Plugins</a></li>
              <li><a href="../../../../front/main/download/#_daily_builds_and_building_from_source">Building from source</a></li>
              <li><a href="../../../../front/main/download/#_older_releases">Previous releases</a></li>
            </ul>
          </div>
        </div>
      </div>
    </footer>
    <div class='footer-disclaimer'>
      <div class="footer-disclaimer-content">
        <p>Copyright &copy; 2017-2023 <a href="https://www.apache.org">The Apache Software Foundation</a>.</p>
        <p>Licensed under the Apache <a href="https://www.apache.org/licenses/">license</a>, version 2.0</p>
        <div style='max-width: 40em; margin: 0 auto'>
          <p>Apache, Apache NetBeans, NetBeans, the Apache feather logo and the Apache NetBeans logo are trademarks of <a href="https://www.apache.org">The Apache Software Foundation</a>.</p>
          <p>Oracle and Java are registered trademarks of Oracle and/or its affiliates.</p>
          <p>The Apache NetBeans website conforms to the <a href="https://privacy.apache.org/policies/privacy-policy-public.html">Apache Software Foundation Privacy Policy</a></p>
        </div>
      </div>
    </div>

    
<script src="../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css"></script>
<script async src="../../../../search-index.js"></script>
    <script src="../../../../_/js/vendor/jquery-3.7.1.min.js"></script>
    <script src="../../../../_/js/vendor/what-input.js"></script>
    <script src="../../../../_/js/vendor/foundation.min.js"></script>
    <script src="../../../../_/js/vendor/jquery.colorbox-min.js"></script>
    <script src="../../../../_/js/netbeans.js"></script>
    <script>
       $(function(){ $(document).foundation(); });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
    <script>
      $(document).ready(function() { $("pre code").each(function(i, block) { hljs.highlightBlock(block); }); });
    </script>
  </body>
</html>
