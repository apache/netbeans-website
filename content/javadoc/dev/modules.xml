<?xml version="1.0" encoding="UTF-8"?>
            <apis>
        <module name="Ant" target="org-apache-tools-ant-module/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        
            The Ant integration module recognizes Ant build scripts, facilitates
            editing them as text or structurally, lets the user run targets or
            create shortcuts to them, etc.
        
    </description><deploy-dependencies>
        Nothing.
    </deploy-dependencies><arch-usecases>
        <p>
            The principal use cases for the API are covered in the overall API architecture.
        </p>
    </arch-usecases><api name="AntLogger" type="export" category="stable" url="org-apache-tools-ant-module/org/apache/tools/ant/module/spi/AntLogger.html" group="java">
                    <p>
                        Permits customization of the way Ant output is displayed.
                    </p>
                </api><api name="register-defs" type="export" category="stable" url="org-apache-tools-ant-module/org/apache/tools/ant/module/spi/package-summary.html#register-defs" group="java.io.File">
                    <p>
                    Registering custom Ant task and type definitions (when these
                    can be run inside the NetBeans JVM only). Typically used to
                    add special tasks which somehow script the IDE, such as
                    connecting the JPDA debugger to a process launched by Ant.
                    </p>
                </api><api name="AutomaticExtraClasspathProvider" type="export" category="stable" url="org-apache-tools-ant-module/org/apache/tools/ant/module/spi/AutomaticExtraClasspathProvider.html" group="java">
                    <p>
                        Permits additions to the default Ant classpath.
                    </p>
                </api><api name="IntrospectedInfo" type="export" category="stable" url="org-apache-tools-ant-module/org/apache/tools/ant/module/api/IntrospectedInfo.html" group="java">
                    <p>
                    Examining cached and introspected data about which tasks and
                    types are known to be defined in the user's Ant scripts, and
                    what their design-time structure is. Used by XML code
                    completion, for example.
                    </p>
                </api><api name="AntTargetExecutor" type="export" category="stable" url="org-apache-tools-ant-module/org/apache/tools/ant/module/api/AntTargetExecutor.html" group="java">
                    <p>
                    Running named targets in specified Ant scripts. Can be used
                    by modules which provide a different UI for initiating Ant
                    execution. <code>ActionUtils</code> provides a more convenient
                    wrapper around this functionality.
                    </p>
                </api><api name="logger.max.line.length" type="export" category="private" group="systemproperty">
                    <p>
                        If a longer message is logged the ant logger will handle the message as plain text and will not try to hyperlink, color, fold, etc. 
                        If not set by the user a default value of <b>3000</b> will be used.
                    </p>
                </api><api name="layer-actions" type="export" category="devel" group="layer">
            <p>
                Context menu actions are read from the layer folder
                <code>Loaders/text/x-ant+xml/Actions</code>.
            </p>
        </api></module><module name="Common Annotations" target="org-netbeans-api-annotations-common/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides common annotations serving as a documentation element and for
   static code analysis.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="check-return-value" name="CheckReturnValue annotated method">
   <p>
    When the method return value is important value to check (or the only effect
    the method has) the method can be annotated with
    <a href="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/CheckReturnValue.html" shape="rect">CheckReturnValue</a>.
    Annotation servers as documentation as well as a hint for static code analysis.
   </p>
  </usecase>
  <usecase id="check-for-null" name="CheckForNull annotated method">
   <p>
    Method annotated with
    <a href="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/CheckForNull.html" shape="rect">CheckForNull</a>
    may return <code>null</code> value. Annotation servers as documentation
    as well as a hint for static code analysis.
   </p>
  </usecase>
  <usecase id="non-null" name="NonNull annotated element">
   <p>
    When the field, parameter, local variable or return value of the method
    must not be <code>null</code> the
    <a href="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/NonNull.html" shape="rect">NonNull</a>
    annotation can be used to clearly express this. It servers as documentation
    as well as a hint for static code analysis.
   </p>
  </usecase>
  <usecase id="null-allowed" name="NullAllowed annotated element">
   <p>
    Field, parameter or local variable annotated with
    <a href="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/NullAllowed.html" shape="rect">NullAllowed</a>
    can contain <code>null</code> value so <code>null</code> check should
    occur before any dereference. Annotation servers as documentation
    as well as a hint for static code analysis.
   </p>
  </usecase>
  <usecase id="null-unknown" name="NullUnknown annotated element">
   <p>
    Annotation
    <a href="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/NullUnknown.html" shape="rect">NullUnknown</a>
    complementing other nullness annotations servers for cases where
    the element may or may not be <code>null</code> under certain
    <i>defined</i> circumstances (usage).
   </p>
  </usecase>
  <usecase id="suppress-warnings" name="SuppressWarnings annotated element">
   <p>
    When the analysis tool report false warning it is possible to use
    <a href="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/SuppressWarnings.html" shape="rect">SuppressWarning</a>
    annotation to suppress the warning.
   </p>
  </usecase>
 </arch-usecases><api name="CommonAnnotationsAPI" type="export" category="stable" url="org-netbeans-api-annotations-common/org/netbeans/api/annotations/common/package-summary.html" group="java"/></module><module name="Debugger Core API" target="org-netbeans-api-debugger/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The debuggercore/api module (Debugger Core API) allows to install different debugger implementation to one IDE. 
It allows to share some common UI components. 
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<h2>UseCase I. - Install
and use CPP debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">CPP debugger plug-in installs support
for debugging of some new language to the NetBeans IDE, and some new
debugging engine. This implementation of debugger should share UI
components (actions, Debugger Views, ...) with default NB Java
Debugger. It should share basic debugger model too - notion of current
context, current session, thread, call stack line, ...</span><br/>
<br/>
CPP debugger plug-in installs:<br/>
<ul>
  <li>New set of breakpoint types - CPPLineBreakpointType,
CPPMethodBreakpointType...
  <ul>
    <li>This set of breakpoint types will have special cathegory in Add
Breakpoint Dialog called "CPP". Each breakpoint type will install a new
JPanel to Add Breakpoint Dialog.</li>
    <li>ToggleBreakpointAction on CPP files will create / remove a
instance of CPPLineBreakpointType.</li>
  </ul>
  </li>
  <li>Install some watches evaluator for CPP language.</li>
  <li>Some new View to Debugger Window</li>
  <li>Use Termilnal Emulator in Output Window as command line interface
to CPP debugger plug-in.</li>
  <li>Install / uninstall a columns to / from standard Debugger Window
Views.</li>
  <li>Redefine Nodes used for representation of CPP threads, watches,
variables, callstacks, sessions and breakpoints
  <ul>
    <li>Add / remove some properties<br/>
    </li>
    <li>Add / remove some actions</li>
    <li>change icons</li>
    <li>change display names</li>
  </ul>
  </li>
  <li>Register CPP Actions for:
  <ul>
    <li>Step Into, Over, Out, Continue, Pause, Start, Kill, Restart,
Finish</li>
  </ul>
  </li>
  <li>Some new CPP specific actions.</li>
</ul>
<br/>

<h2>UseCase II. -
Install and use JSP debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">JSP debugger plug-in installs support
for debugging of some new language to the NetBeans Java Debugger. It
does not contain a new debugger engine, but it delegates to standard NB
Java debugger. So it does not depends on Debugger Core API only, but it
depends on JavaDebugger API too.<br/>
<br/>
JSP debugger plug-in installs:<br/>
</span>
<ul>
  <li>New set of breakpoint types - JSPLineBreakpointType, ...
  <ul>
    <li>This set of breakpoint types will have special cathegory in Add
Breakpoint Dialog called "JSP". Each breakpoint type will install a new
JPanel to Add Breakpoint Dialog.</li>
    <li>ToggleBreakpointAction on JSP files will create / remove a
instance of JSPLineBreakpointType.</li>
    <li>JSPLineBreakpointType delegates all functionality to
JPDAClassBreakpoint and JPDALineBreakpoint<br/>
    </li>
  </ul>
  </li>
  <li>Some watches evaluator for JSP language expression. This
evaluator delegates evaluation of Java expressions to standard
JavaExpressionEvaluator.<br/>
  </li>
  <li>Redefine Nodes used for representation of JSP callstacks and
breakpoints
  <ul>
    <li>Add / remove some properties<br/>
    </li>
    <li>Add / remove some actions</li>
    <li>change icons</li>
    <li>change display names</li>
  </ul>
  </li>
  <li>Register JSP Actions for:
  <ul>
    <li>Step Into, Over, Out</li>
    <li>Implementation of this actions delegates to standard Java Step
actions - it redefines Java stepping functionality.</li>
  </ul>
  </li>
  <li>JSP debugger plug in adds support for new programming language
(JSP) to already running Java Session.<br/>
  </li>
</ul>
<br/>

<h2>UseCase III. -
Install and use J2EE debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">J2EE debugger plug-in installs some
enhancements to the standard Java Debugger. It
does not contain a new debugger engine or language support. So it does
not depends on Debugger Core API only, but it
depends on JavaDebugger API too.<br/>
<br/>
J2EE debugger plug-in installs:<br/>
</span>
<ul>
  <li>New set of breakpoint types</li>
  <li>Filter for Threads and Callstack Views. This filter should allow
to:<br/>
  <ul>
    <li>Add / remove / modify nodes in this views.</li>
  </ul>
  </li>
  <li>Redefine Stepping (Smart Stepping) behaviour of default Java
Debugger.</li>
  <li>Some new View to Debugger Window</li>
</ul>
<br/>
<h2>UseCase IV. -
Install and use DBX debugger plug-in to NetBeans.</h2>
<span style="font-style: italic;">DBX debugger plug-in installs support
for debugging of some new language (CPP) to the NetBeans IDE, and some
new
debugging engine. But it contains debugger engine for Java debugging
too. DBX debugger engine has its own session management (or will have
in the next versions). One debugger engine can manage more than one
sessions. One engine supports debugging in more than one language.<br/>
<br/>
</span>
<h2>UseCase V. -
Implement Debugger Core UI module on top of Debugger Core API / SPI.</h2>
<span style="font-style: italic;">Debugger Core UI needs:<br/>
</span>
<ul>
  <li>List all breakpoint types and all breakpoint cathegories.</li>
  <li>Visually customize all breakpoints - some panel.</li>
  <li>Add / remove breakpoints.</li>
  <li>Add / remove watches.<br/>
  </li>
  <li>Represent breakpoints, threads, thread groups, watches, sessions,
call stack frames, locales, and fields as Nodes in NB Explorer View.</li>
  <li>List all threads, thread groups, locales, watches, breakpoints,
callstack frames, and fields.</li>
  <li>Listen on changes of hierarchy of threads, thread groups,
locales, watches, breakpoints, callstack frames, and fields.</li>
  <li>Some current context definition. Current contet should define
current session, language, thread, and call stack line.</li>
</ul>
<br/>

</arch-usecases><api name="DebuggerCoreAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-debugger" group="java"/></module><module name="JPDA Debugger API" target="org-netbeans-api-debugger-jpda/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The debuggerjpda/api (Debugger JPDA API) defines API for NetBeans Java Debugger.
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
<h2>UseCase I. - Install
and use CPP debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">CPP debugger plug-in installs support
for debugging of some new language to the NetBeans IDE, and some new
debugging engine. This implementation of debugger should share UI
components (actions, Debugger Views, ...) with default NB Java
Debugger. It should share basic debugger model too - notion of current
context, current session, thread, call stack line, ...</span><br/>
<br/>
CPP debugger plug-in installs:<br/>
<ul>
  <li>New set of breakpoint types - CPPLineBreakpointType,
CPPMethodBreakpointType...
  <ul>
    <li>This set of breakpoint types will have special cathegory in Add
Breakpoint Dialog called "CPP". Each breakpoint type will install a new
JPanel to Add Breakpoint Dialog.</li>
    <li>ToggleBreakpointAction on CPP files will create / remove a
instance of CPPLineBreakpointType.</li>
  </ul>
  </li>
  <li>Install some watches evaluator for CPP language.</li>
  <li>Some new View to Debugger Window</li>
  <li>Use Termilnal Emulator in Output Window as command line interface
to CPP debugger plug-in.</li>
  <li>Install / uninstall a columns to / from standard Debugger Window
Views.</li>
  <li>Redefine Nodes used for representation of CPP threads, watches,
variables, callstacks, sessions and breakpoints
  <ul>
    <li>Add / remove some properties<br/>
    </li>
    <li>Add / remove some actions</li>
    <li>change icons</li>
    <li>change display names</li>
  </ul>
  </li>
  <li>Register CPP Actions for:
  <ul>
    <li>Step Into, Over, Out, Continue, Pause, Start, Kill, Restart,
Finish</li>
  </ul>
  </li>
  <li>Some new CPP specific actions.</li>
</ul>
<br/>

<h2>UseCase II. -
Install and use JSP debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">JSP debugger plug-in installs support
for debugging of some new language to the NetBeans Java Debugger. It
does not contain a new debugger engine, but it delegates to standard NB
Java debugger. So it does not depends on Debugger Core API only, but it
depends on JavaDebugger API too.<br/>
<br/>
JSP debugger plug-in installs:<br/>
</span>
<ul>
  <li>New set of breakpoint types - JSPLineBreakpointType, ...
  <ul>
    <li>This set of breakpoint types will have special cathegory in Add
Breakpoint Dialog called "JSP". Each breakpoint type will install a new
JPanel to Add Breakpoint Dialog.</li>
    <li>ToggleBreakpointAction on JSP files will create / remove a
instance of JSPLineBreakpointType.</li>
    <li>JSPLineBreakpointType delegates all functionality to
JPDAClassBreakpoint and JPDALineBreakpoint<br/>
    </li>
  </ul>
  </li>
  <li>Some watches evaluator for JSP language expression. This
evaluator delegates evaluation of Java expressions to standard
JavaExpressionEvaluator.<br/>
  </li>
  <li>Redefine Nodes used for representation of JSP callstacks and
breakpoints
  <ul>
    <li>Add / remove some properties<br/>
    </li>
    <li>Add / remove some actions</li>
    <li>change icons</li>
    <li>change display names</li>
  </ul>
  </li>
  <li>Register JSP Actions for:
  <ul>
    <li>Step Into, Over, Out</li>
    <li>Implementation of this actions delegates to standard Java Step
actions - it redefines Java stepping functionality.</li>
  </ul>
  </li>
  <li>JSP debugger plug in adds support for new programming language
(JSP) to already running Java Session.<br/>
  </li>
</ul>
<br/>

<h2>UseCase III. -
Install and use J2EE debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">J2EE debugger plug-in installs some
enhancements to the standard Java Debugger. It
does not contain a new debugger engine or language support. So it does
not depends on Debugger Core API only, but it
depends on JavaDebugger API too.<br/>
<br/>
J2EE debugger plug-in installs:<br/>
</span>
<ul>
  <li>New set of breakpoint types</li>
  <li>Filter for Threads and Callstack Views. This filter should allow
to:<br/>
  <ul>
    <li>Add / remove / modify nodes in this views.</li>
  </ul>
  </li>
  <li>Redefine Stepping (Smart Stepping) behaviour of default Java
Debugger.</li>
  <li>Some new View to Debugger Window</li>
</ul>
<br/>
<h2>UseCase IV. -
Install and use DBX debugger plug-in to NetBeans.</h2>
<span style="font-style: italic;">DBX debugger plug-in installs support
for debugging of some new language (CPP) to the NetBeans IDE, and some
new
debugging engine. But it contains debugger engine for Java debugging
too. DBX debugger engine has its own session management (or will have
in the next versions). One debugger engine can manage more than one
sessions. One engine supports debugging in more than one language.<br/>
<br/>
</span>

</arch-usecases><api name="JPDADebuggerAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-debugger-jpda" group="java"/><api name="SS_ACTION_STEPOUT" type="export" category="friend" group="property">
        When set to Boolean.TRUE, this option is causing step out during smart-stepping
        instead of step into. Thus it much faster skips code that is not selected
        for debugging, but it may also skip code that should be debugged if it's
        called from a source that has debugging disabled.
        This is advantageous when the speed is important (e.g. in J2ME).
        This property can be set through a map of properties that is passed to
        JPDADebugger.attach (), like J2ME_DEBUGGER property.
    </api><api name="netbeans.debugger.show_hidden_breakpoints" type="export" category="private" group="systemproperty">
        This system property is causing the breakpoints view to show also hidden
        breakpoints.
    </api><api name="org.netbeans.modules.debugger.jpda.breakpoints.level" type="export" category="private" group="systemproperty">
        Logging level for informational messages about breakpoint
        submission and hits. They use Level.FINE and Level.FINER levels and
        are printed into the NetBeans message log.
    </api><api name="netbeans.debugger.start" type="export" category="private" group="systemproperty">
        When this system property is set, informational messages about start of
        JPDA debugger are printed into standard output (console).
    </api><api name="netbeans.debugger.jditrace" type="export" category="private" group="systemproperty">
        This system property sets the debug mode of the debuggee virtual machine
        via <code>VirtualMachine.setDebugTraceMode()</code> method. See the javadoc
        of that method for the description and possible values.
    </api><api name="org.netbeans.modules.debugger.jpda.jdievents.level" type="export" category="private" group="systemproperty">
        Logging level for informational messages about received JDI events.
        They use Level.FINE level and are printed into the NetBeans message log.
    </api><api name="netbeans.debugger.smartstepping" type="export" category="private" group="systemproperty">
        When this system property is set, informational messages about the smart
        stepping process are printed into standard output (console).
    </api><api name="netbeans.debugger.noInvokeMethods" type="export" category="private" group="systemproperty">
        When this system property is set, methods invocation in debuggee is disabled.
    </api><api name="org.netbeans.modules.debugger.jpda.invokeMethod.level" type="export" category="private" group="systemproperty">
        Logging level for messages about method invocation.
        They use Level.FINE level and are printed into the NetBeans message log.
    </api><api name="org.netbeans.modules.debugger.jpda.getValue.level" type="export" category="private" group="systemproperty">
        Logging level for messages about variables evaluation.
        They use Level.FINE level and are printed into the NetBeans message log.
    </api><api name="netbeans.debugger.viewrefresh" type="export" category="private" group="systemproperty">
        When this system property is set, informational messages about the tasks
        that refresh debugger views are printed into standard output (console).
        The value of that property should contain 'w' for watches view, 'l' for
        local variables view, 'c' for call stack view, 's' for classes view and
        't' for threads view.
    </api></module><module name="HTML UI API" target="org-netbeans-api-htmlui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
  NetBeans Platform specific bindings over
   standard HTML for Java API.
  
 </description><deploy-dependencies>
  <p>
  The HTML for Java &amp; NetBeans API is a classical NetBeans module. However 
  it depends on other modules provided by the 
  <a href="http://bits.netbeans.org/html+java/" onclick="target='_blank'" shape="rect">HTML for Java</a>
  project and those are OSGi bundles. As such, when one decides to use this 
  module, one needs to turn on an OSGi container inside of the NetBeans Platform.
  It can be either <a href="http://felix.apache.org" onclick="target='_blank'" shape="rect">Felix</a> or 
  NetBeans version of <a href="http://wiki.apidesign.org/wiki/Netbinox" onclick="target='_blank'" shape="rect">Equinox</a>.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   Primary purpose of this API is to allow smooth use of HTML based UI
   in NetBeans Platform. To achieve that it provides specific annotatations
   like <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/OpenHTMLRegistration.html" shape="rect">@OpenHTMLRegistration</a>,
   but otherwise it builds on the same usecases as the
   <a href="http://bits.netbeans.org/html+java/" onclick="target='_blank'" shape="rect">HTML for Java</a> API.
  </p>
  <usecase id="window" name="Portable HTML based Window">
      <a name="use-window" shape="rect"/>
      Want to open a live HTML page as a 
      <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html" shape="rect">
        NetBeans window component</a>? Do you want
      to use Java to control enabled/disabled state of various HTML elements?
      Then have a look at
      <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/OpenHTMLRegistration.html" shape="rect">@OpenHTMLRegistration</a>
      annotation.
  </usecase>
  <usecase id="dialog" name="Portable HTML based Dialog">
      <a name="use-dialog" shape="rect"/>
      Want to open a modal dialog filled with an HTML page and block until user
      makes his choice? 
      Then have a look at
      <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/HTMLDialog.html" shape="rect">@HTMLDialog</a>
      annotation.
  </usecase>
  <usecase id="component" name="Embedding an HTML UI Component">
      Are you satisfied with your HTML UI as used in 
      <a href="org-netbeans-api-htmlui/architecture-summary.html#use-window" shape="rect">windows</a> and
      <a href="org-netbeans-api-htmlui/architecture-summary.html#use-dialog" shape="rect">dialogs</a>, but you'd like to use it
      at a different part of the overall NetBeans UI? Then check
      <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/HTMLComponent.html" shape="rect">@HTMLComponent</a>
      annotation.
  </usecase>
  <usecase id="wizard" name="HTML and Java Wizard">
      It is possible to use this technology to
      create a wizard. See 
      <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-templates/overview-summary.html#html-and-java" shape="rect">
      HTML and Java Wizard
      </a> howto.
  </usecase>
 </arch-usecases><api name="HTMLUI" type="export" category="official" group="java">
   NetBeans Platform specific bindings over
   standard <a href="http://bits.netbeans.org/html+java/" onclick="target='_blank'" shape="rect">HTML for Java</a> API.
   </api><api name="data-netbeans-css" type="export" category="official" group="property">
          Each browser component created by one of the
          annotations (
          <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/HTMLComponent.html" shape="rect">@HTMLComponent</a>,
          <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/HTMLDialog.html" shape="rect">@HTMLDialog</a>,
          <a href="org-netbeans-api-htmlui/org/netbeans/api/htmlui/OpenHTMLRegistration.html" shape="rect">@OpenHTMLRegistration</a>
          )
          is by default skinned with a CSS that makes it
          look like the the other Swing components. This can be disabled
          when defining your HTML page:
<pre xml:space="preserve">
&lt;html&gt;
&lt;head data-netbeans-html="false"&gt;
&lt;/head&gt;
&lt;/html&gt;
</pre>
          If there is the <code>data-netbeans-html</code> attribute equal to <code>"false"</code>,
          then no special NetBeans CSS tricks are applied.
      </api></module><module name="Intent API" target="org-netbeans-api-intent/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        
            This module provides a contract between API clients that can express
            some intention to invoke an operation and SPI providers that can
            handle that intention.
        
        
            This is useful in client-server environments, where the intention
            can be constructed on server-side, but handled on client-side. The
            objects that describe the intention should be easy to construct,
            transfer and interpret.
        
    </description><deploy-dependencies>
        <p>
            Standard module dependency is sufficient.
        </p>
    </deploy-dependencies><arch-usecases>
        <usecase id="execIntentBasic" name="Create an Intent, execute it and wait for result">
            <pre xml:space="preserve">
    Future&lt;Object&gt; result = new <a href="org-netbeans-api-intent/org/netbeans/api/intent/Intent.html" shape="rect">Intent</a>(Intent.ACTION_VIEW, new URI("scheme://path/")).execute();
    Object value = result.get();
            </pre>
        </usecase>

        <usecase id="execIntentCallback" name="Create an Intent and execute it with callback">
            <pre xml:space="preserve">
    new <a href="org-netbeans-api-intent/org/netbeans/api/intent/Intent.html" shape="rect">Intent</a>(Intent.ACTION_VIEW, new URI("scheme://path/")).execute(new <a href="org-netbeans-api-intent/org/netbeans/api/intent/Callback.html" shape="rect">Callback</a>() {
      void success(Object result) {
        // use the result somehow
      }
      void failure(Exception exception) {
        // report the failure somehow
      }
    });
            </pre>
        </usecase>

        <usecase id="handleIntentSync" name="Handle some Intent">
            <pre xml:space="preserve">
    @<a href="org-netbeans-api-intent/org/netbeans/spi/intent/IntentHandlerRegistration.html" shape="rect">IntentHandlerRegistration</a>(
                displayName = "Show my item in MyEditor",
                position = 800,
                uriPattern = "myscheme://.*",
                actions = {Intent.ACTION_VIEW, Intent.ACTION_EDIT}
    )
    public static Object handleIntent(<a href="org-netbeans-api-intent/org/netbeans/api/intent/Intent.html" shape="rect">Intent</a> intent) {
        SomeType result = parseAndPerformIntentSomehow(intent);
        return result;
    }
            </pre>
        </usecase>

        <usecase id="handleIntentAsync" name="Handle some Intent using Result object">
            <pre xml:space="preserve">
    @<a href="org-netbeans-api-intent/org/netbeans/spi/intent/IntentHandlerRegistration.html" shape="rect">IntentHandlerRegistration</a>(
                displayName = "Show my item in MyEditor",
                position = 800,
                uriPattern = "myscheme://.*",
                actions = "*"
    )
    public static void handleIntent(final <a href="org-netbeans-api-intent/org/netbeans/api/intent/Intent.html" shape="rect">Intent</a> intent, final <a href="org-netbeans-api-intent/org/netbeans/spi/intent/Result.html" shape="rect">Result</a> result) {
        // Move the execution to another thread. Do not wait for the result
        // here, just pass the result object.
        EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    Object result = doSomethingInEDT(intent);
                    result.setResult(e);
                } catch (Exception e) {
                    result.setException(e);
                }
            }
        });
    }
            </pre>
        </usecase>
    </arch-usecases><api name="IntentAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-intent/org/netbeans/api/intent/package-summary.html" group="java">
            <p>
                API for describing and executing intended operations.
            </p>
        </api><api name="IntentHandlerSPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-intent/org/netbeans/spi/intent/package-summary.html" group="java">
            <p>
                SPI for handlers that are able to invoke proper operation for
                specified intents.
            </p>
        </api></module><module name="I/O API and SPI" target="org-netbeans-api-io/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        
            The Input/Output API and SPI is a small module
            which contains InputOutput and related interfaces used in
            driving the Output Window.
        
        
            The normal implementation is org.netbeans.core.output2.
        
    </description><deploy-dependencies>
        <p>
            Normal module dependency is enough.
        </p>
        <p>
            Availability of some implementation of the SPI is guaranteed by
            "OpenIDE-Module-Needs: org.netbeans.spi.io.InputOutputProvider" in
            the manifest of this module.
        </p>
    </deploy-dependencies><arch-usecases>

        <usecase id="print" name="Print a simple output to a new output tab">
            <p>
                The basic use-case is printing a simple text, e.g. text output of an application,
                into a dedicated pane in the UI, e.g. a tab in Output Window in the IDE.
            </p>
            <pre xml:space="preserve">
    InputOutput io = InputOutput.get("UseCase1", true);
    io.getOut().println("This is a simple output");
    io.getOut().close();
            </pre>
        </usecase>

        <usecase id="printOnClickHyperlink" name="Print a line with hyperlink for invocation of arbitrary code">
            <p>
                Hyperlinks can be also used to invoke some code when clicked.
            </p>
            <pre xml:space="preserve">
    InputOutput io = InputOutput.get("UseCase3", true);
    io.getOut().print("A line containing a ");
    io.getOut().print("hyperlink", Hyperlink.from(new Runnable() {
        public void run() {
            System.gc();
        }
    }));
    io.getOut().println(" for invocation of custom code.");
    io.getOut().close();
            </pre>
        </usecase>

        <usecase id="printColor" name="Print color text">
            <p>
                Print a color text. Users can select a predefined color for
                common cases (debug, warning, failure, success), or custom
                color specified as RGB value.
            </p>
            <pre xml:space="preserve">
    InputOutput io = InputOutput.get("UseCase4", true);
    io.getOut().println("Let's print some info", OutputColor.debug());
    io.getOut().println("or warning with appropriate color", OutputColor.warning());
    io.getOut().println("Maybe also text with custom reddish color", OutputColor.rgb(255, 16, 16));
    io.getOut().close();
            </pre>
        </usecase>

        <usecase id="printAndReset" name="Reset an InputOutput to clear all previosly printed text">
            <p>
                It is possible to reuse already created output pane and clear
                all the previously printed text if it is not needed any more.
            </p>
            <pre xml:space="preserve">
    InputOutput io = InputOutput.get("UseCase5", true);
    io.getOut().println("Let's print some text");
    io.getErr().println("and reset the pane immediately.");
    io.reset();
    io.getOut().println("The pane is now empty and we can reuse it simply");
    io.getOut().close();
            </pre>
        </usecase>

    </arch-usecases><api name="NbInputOutputAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-io/org/netbeans/api/io/package-summary.html" group="java">
            <p>
                The module contains APIs for creating output panes (e.g. output tabs in Output Window in the IDE)
                and for writing data into them. It also supports some advanced techniques, e.g. color text,
                hyperlinks, code folding, scrolling to stored positions.
            </p>
        </api><api name="NbInputOutputSPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-io/org/netbeans/spi/io/package-summary.html" group="java">
            <p>
                SPI for providing custom implementations of output window is also included in this module, in package
                <code>org.netbeans.spi.io</code>
            </p>
        </api></module><module name="Java Support APIs" target="org-netbeans-api-java/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides java specific queries (javadc, source level) used by other modules like java language infrastructure.
   More information in the Javadoc.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The API is widely used by all sorts of IDE modules which need to work with
   Java sources. They can find Javadoc, unit tests, source level, etc.
   The SPI is intended mainly for Java platform and
   library providers, and project type providers, to declare all of this
   information.
  </p>
 </arch-usecases><api name="JavaSupportAPIs" type="export" category="official" group="java">
   The Java Support APIs provides basic facilities for getting or supplying
   information about Java-language source files. It is based on the query pattern
   so implementations can be supplied from other modules or projects.
  </api></module><module name="Classpath APIs" target="org-netbeans-api-java-classpath/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Models basic aspects of the metadata surrounding list of source roots, such as
   the classpath. More information in the Javadoc.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The API is widely used by all sorts of IDE modules which need to work with
   sources. The SPI is intended mainly for (java) platforms and
   library providers, and project type providers, to declare all of this
   information.
  </p>
 </arch-usecases><api name="ClassPathAPIs" type="export" category="official" group="java">
   The ClassPath APIs provides java classpath like ordered collection of (source)
   roots with ability to listen on changes and helper methods like finding the file
   under the roots, returning a path from root to given file. It also provides a
   registry where projects register their classpaths to make them visible to languages
   infrastructure.
  </api></module><module name="Knockout Model Provider API" target="org-netbeans-api-knockout/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
     <api-ref name="api.knockout"/>
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
     <usecase id="register" name="Register a provider">
<p>
This is the code to register a sample <a href="org-netbeans-api-knockout/org/netbeans/spi/knockout/BindingsProvider.html" shape="rect">provider</a>:
</p>
<pre xml:space="preserve">
{@code @}ServiceProvider(service = BindingsProvider.class)
public class SampleBindingsProvider implements {@link org.netbeans.spi.knockout.BindingsProvider} {
    {@code @Override}
    public void findBindings(FileObject htmlFile, Response r) {
        Bindings tweet = Bindings.create("Tweet").
                stringProperty("from_user", false).
                intProperty("from_user_id", false);

        Bindings tweeters = Bindings.create("Tweeters").
                stringProperty("name", false).
                stringProperty("userNames", true);

        Bindings twitterClient = Bindings.create("TwitterClient");
        twitterClient.
                stringProperty("activeTweetersName", false).
                stringProperty("activeTweeters", true).
                stringProperty("userNameToAdd", false).
                booleanProperty("loading", false).
                modelProperty("currentTweets", tweet, true).
                modelProperty("savedLists", tweeters, true);

        r.applyBindings(twitterClient);
    }
}
</pre>

<p>
This sample has been used when testing the module.
</p>
     </usecase>
 </arch-usecases><api name="api.knockout" type="export" category="official" group="java">
     API for registering additional <a href="org-netbeans-api-knockout/org/netbeans/spi/knockout/BindingsProvider.html" shape="rect">provider</a>s
     that help the HTML editor to offer better code completion for certain HTML
     files based on the produced description of a
     <a href="org-netbeans-api-knockout/org/netbeans/spi/knockout/Bindings.html" shape="rect">JSON-like structure</a>.
     </api></module><module name="Maven API" target="org-netbeans-api-maven/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   No special requirements here.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
    Start exploring use-cases related to Maven archetypes
    at the <a href="org-netbeans-api-maven/org/netbeans/api/maven/archetype/ArchetypeWizards.html" shape="rect">ArchetypeWizards</a> class.
  </p>
 </arch-usecases><api name="MavenArchetypeAPI" type="export" category="stable" group="java">
     <p> 
      provides miscellaneous APIs related to operations
      provided by maven-archetype-plugin. See <a href="org-netbeans-api-maven/org/netbeans/api/maven/archetype/package-summary.html" shape="rect">package description</a>
      for more details.
     </p>
    </api><api name="MavenArchetypes" type="export" category="official" group="layer">
     <p>
       "Projects/org-netbeans-modules-maven/Archetypes" folder contains fileobjects
       that represent archetypes. The archetypes are defined by the following file attributes:
     </p>
       <table>
           <tbody>
               <tr><td colspan="1" rowspan="1">groupId</td><td colspan="1" rowspan="1">mandatory</td><td colspan="1" rowspan="1"/></tr>
               <tr><td colspan="1" rowspan="1">artifactId</td><td colspan="1" rowspan="1">mandatory</td><td colspan="1" rowspan="1"/></tr>
               <tr><td colspan="1" rowspan="1">version</td><td colspan="1" rowspan="1">mandatory</td><td colspan="1" rowspan="1"/></tr>
               <tr><td colspan="1" rowspan="1">repository</td><td colspan="1" rowspan="1">optional</td><td colspan="1" rowspan="1">url of the archetype's repository</td></tr>
               <tr><td colspan="1" rowspan="1">nameBundleKey</td><td colspan="1" rowspan="1">optional</td><td colspan="1" rowspan="1">key in bundle file that holds localized name</td></tr>
               <tr><td colspan="1" rowspan="1">descriptionBundleKey</td><td colspan="1" rowspan="1">optional</td><td colspan="1" rowspan="1">key in bundle file that holds localized description</td></tr>
           </tbody>
       </table>
    </api></module><module name="Progress API" target="org-netbeans-api-progress/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
The progress API is good for tracking progress of long lasting tasks in the IDE.

  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
    <usecase id="basic" name="Basic usage">
<p>There are 3 types of progress indication:</p>
<ul>
<li>1. indefinite when it's not known how much time will be needed to complete</li>
<li>2. definite with time estimate for completion (UI shows time that remains)</li>
<li>3. definite without time estimate where the UI shows percentage completed.</li>
</ul>
<p>
The default location of the progress indication is the status bar which aggregates all
tasks running in the IDE that show progress. However it's possible to exclude the task from the default location 
and show the progress in one's custom dialog component. In such a case the same task should not appear in the status line component as well.
</p>
<p>
It's possible to request cancelling the task from status line progress aggregator if the task allows cancelling.
</p> 

<p>
Progress tasks that get started as a result of explicit user action takes precedence in the status line
docked component over tasks that are triggered by the system. (say filesystem refresh for example)
</p>
  <p> The most common usecase of the API looks like this: </p>
  <pre xml:space="preserve">
ProgressHandle handle = ProgressHandleFactory.creatHandle("My custom task");
...
// we have 100 workunits
// at this point the task appears in status bar.
handle.start(100);
...
handle.progress(10);
...
handle.progress("half way through", 50);
...
handle.progress(99);
// at this point the task is finished and removed from status bar
// it's not realy necessary to count all the way to the limit, finish can be called earlier.
// however it has to be called at the end of the processing.
handle.finish();
</pre>
</usecase>
   <usecase id="advanced" name="Advanced Usage">
<p>In case your usage of the API </p>
<ul>
<li>spans across multiple independent modules, </li>
<li>requires adjusting of number of workunits or </li>
<li>triggers additional action based on the current progress</li>
</ul>
<p>
then you should consider using the aggregating version of APIs which is similar to the 
simple APIs but has distinctive differences and additions that allow for more complex scenarios.
</p>
<p>
It allows to compose the progress bar from 1+ independent sources, all sharing proportional piece
of the progress bar. Additionally you can monitor the task's overall progress from one central place and possibly
add more contributing sources of the progress during processing.
</p>
<pre xml:space="preserve">
        // let's have a factory for client code that performs some part of the job to be done..
        Lookup.Result res = Lookup.getDefault().lookup(new LookupTemplate(MyWorkerFactory.class));
        Iterator it = res.allInstances().iterator();
        ProgressContributor[] contribs = new ProgressContributor[res.allInstances().size()];
        int i = 0;
        while (it.hasNext()) {
            MyWorkerFactory prov = (MyWorkerFactory)it.next();
            contribs[i] = AggregateProgressFactory.createProgressContributor("Module X contribution");
            MyWorker worker = prov.createWorker(contribs[i]);
            //... snip ... do something with the worker..
            i = i + 1;
        }
        AggregateProgressHandle handle = AggregateProgressFactory.createHandle("My Task", contribs, null, null);
        // non-cancellable and with out output link.
        
        // calling start() at the time when the actual long running task starts processing
        handle.start("here we go");
        // ...snip...
        // now the individual MyWorker instances log their progress.
        // possibly in other threads too..
        // ... snip...
        // 
        if (myConditionThatSpawnsAnotherContributor()) {
            ProgressContributor cont = AggregateProgressFactory.createProgressContributor("Additional exceptional contribution");
            handle.addContributor(cont);
            // ... snip ...
        }
        
        // the task is finished when all the ProgressContributors finish..
</pre>

   </usecase>
 </arch-usecases><api name="Progress" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-progress/index.html" group="java"/></module><module name="Progress API - Swing" target="org-netbeans-api-progress-nb/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="ProgressSwing" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-progress/index.html" group="java"/></module><module name="Search API" target="org-netbeans-api-search/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        
            This project is good for implementators of nodes to define how files
            under this node should be searched. For example, if you implement a
            custom project type, you can define which folders should be searched
            when the project is in the current search scope.
        
        
            It is also good for people who want to add a custom tab into the
            "Search in projects" dialog. For example, implementators of platform
            applications can add form with criteria for searching in a database.
        
    </description><deploy-dependencies>
        <p>
            No extra declaration is required.
        </p>
    </deploy-dependencies><arch-usecases>
        <usecase id="searchHistory" name="Search History">
            <p>
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/SearchHistory.html" shape="rect">SearchHistory</a></code>
                is synchronising history content through netbeans modules and it saves history to preferences.
            </p>
            <p>
                There are two separate histories. One for search and another for replace.
                When you add your propertyListener to
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/SearchHistory.html" shape="rect">SearchHistory</a></code>
                - you can listen for changes in histories.
            </p>
            <p>
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/SearchHistory.html" shape="rect">SearchHistory</a></code>
                has methods for adding new entries and getting whole history list.
            </p>

        </usecase>
        <usecase id="searchInfo" name="SearchInfo API &amp; SPI">
            <p>
                This use-case was formerly covered by module
                org.openidex.search.
            </p>
            <p>
                The SearchInfo API+SPI allows other modules to specify whether
                and how should nodes they define be searched.
            </p>
            <p>
                The definition is represented by objects extending class
                <code>
                    <a href="org-netbeans-api-search/org/netbeans/spi/search/SearchInfoDefinition.html" shape="rect">
                        SearchInfoDefinition</a>
                </code>. To customize searching on a custom node, a
                <code>SearchInfoDefinition</code> object must be added to the node's lookup.
                In most cases, there is no need to define own class extending the
                class - one can use factory methods of class
                <code>
                    <a href="org-netbeans-api-search/org/netbeans/spi/search/SearchInfoDefinitionFactory.html" shape="rect">
                        SearchInfoDefinitionFactory</a>
                </code>.
            </p>
            <p>
                In some cases implementators may need to apply the same set
                of SearchFilterDefinitions in the whole subtree of a node.
                If so, it is not needed to put <code>SearchInfoDefinition</code> to all
                nodes' lookups, but only one instance of <code>
                    <a href="org-netbeans-api-search/org/netbeans/spi/search/SubTreeSearchOptions.html" shape="rect">
                        SubTreeSearchOptions</a>
                </code> have to be put into the lookup of the root node.
            </p>

            <api category="stable" group="java" name="SearchInfoSPI" type="export" url="org-netbeans-api-search/org/netbeans/spi/search/package-summary.html">
                Defines abstract classes
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SearchInfoDefinition.html" shape="rect">SearchInfoDefinition</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SearchFilterDefinition.html" shape="rect">SearchFilterDefinition</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SubTreeSearchOptions.html" shape="rect">SubTreeSearchOptions</a></code>
                and a factory class
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SearchInfoDefinitionFactory.html" shape="rect">SearchInfoDefinitionFactory</a></code>
            </api>
        </usecase>
        <usecase id="SearchProvider" name="Enhance IDE searching features">
            <p>
                People that want to enhance IDE searching features (with custom
                search criteria or specialized algorithms) can add a new tab to 
                the "Search in Projects" dialog.
            </p>
            <p>
                They need to implement several classes:
            </p>
            <ul>
                <li>
                    <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchProvider.html" shape="rect">SearchProvider</a></code>
                    to register the new search feature to the IDE or platform application.
                </li>
                <li>
                    <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchProvider.Presenter.html" shape="rect">SearchProvider.Presenter</a></code>
                    that creates visual component for adding to the search dialog and that can interact with dialog buttons.
                </li>
                <li>
                    <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchResultsDisplayer.html" shape="rect">SearchResultsDisplayer</a></code>
                    to show search results to the user.
                </li>
                <li>
                    <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchComposition.html" shape="rect">SearchComposition</a></code>
                    that encapsulates setting and state of searches, provide access to result displayer, and is able to start
                    and terminate the search.
                </li>
            </ul>
            <api category="stable" group="java" name="SearchProviderSPI" type="export" url="org-netbeans-api-search/org/netbeans/spi/search/provider/package-summary.html">
                Defines abstract classes that need to be implemented when 
                creating custom providers:
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchProvider.html" shape="rect">SearchProvider</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchProvider.Presenter.html" shape="rect">SearchProvider.Presenter</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchResultsDisplayer.html" shape="rect">SearchResultsDisplayer</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchComposition.html" shape="rect">SearchComposition</a></code>
                and relative classes.
            </api>
            <api category="stable" group="java" name="SearchProviderAPI" type="export" url="org-netbeans-api-search/org/netbeans/api/search/provider/package-summary.html">

                Classes usually used by search providers.
                Contains class <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchInfo.html" shape="rect">SearchInfo</a></code>,
                that defines which files should be searched (it can be retrieved from methods in
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchInfoUtils.html" shape="rect">SearchInfoUtils</a></code>,
                or UI component controller <code><a href="org-netbeans-api-search/org/netbeans/api/search/ui/ScopeController.html" shape="rect">ScopeController</a></code>),
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchListener.html" shape="rect">SearchListener</a></code>
                that you should inform about events that happen during searching, and helper classes
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchInfoUtils.html" shape="rect">SearchInfoUtils</a></code>
                (getting SearchInfo objects for nodes) and
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/FileNameMatcher.html" shape="rect">FileNameMatcher</a></code>
                (filtering files by file name).
            </api>
            <api category="stable" group="java" name="SearchProviderUIAPI" type="export" url="org-netbeans-api-search/org/netbeans/api/search/ui/package-summary.html">

                Several UI components that can be used in presenters of search 
                providers, and factory method for creating them.
            </api>
        </usecase>
        <usecase id="SearchAPI" name="Search in Projects API">
            <p>
                This API enables other modules to open Find in Projects dialog 
                with some pre-defined criteria and to start searching 
                programatically.
            </p>
            <api category="stable" group="java" name="SearchAPI" type="export" url="org-netbeans-api-search/org/netbeans/api/search/package-summary.html">

                Contains classes for controlling search, passing search 
                criteria, and some helper classes.
            </api>
        </usecase>
    </arch-usecases><api name="SearchInfoSPI" type="export" category="stable" url="org-netbeans-api-search/org/netbeans/spi/search/package-summary.html" group="java">
                Defines abstract classes
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SearchInfoDefinition.html" shape="rect">SearchInfoDefinition</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SearchFilterDefinition.html" shape="rect">SearchFilterDefinition</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SubTreeSearchOptions.html" shape="rect">SubTreeSearchOptions</a></code>
                and a factory class
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/SearchInfoDefinitionFactory.html" shape="rect">SearchInfoDefinitionFactory</a></code>
            </api><api name="SearchProviderSPI" type="export" category="stable" url="org-netbeans-api-search/org/netbeans/spi/search/provider/package-summary.html" group="java">
                Defines abstract classes that need to be implemented when 
                creating custom providers:
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchProvider.html" shape="rect">SearchProvider</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchProvider.Presenter.html" shape="rect">SearchProvider.Presenter</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchResultsDisplayer.html" shape="rect">SearchResultsDisplayer</a></code>,
                <code><a href="org-netbeans-api-search/org/netbeans/spi/search/provider/SearchComposition.html" shape="rect">SearchComposition</a></code>
                and relative classes.
            </api><api name="SearchProviderAPI" type="export" category="stable" url="org-netbeans-api-search/org/netbeans/api/search/provider/package-summary.html" group="java">

                Classes usually used by search providers.
                Contains class <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchInfo.html" shape="rect">SearchInfo</a></code>,
                that defines which files should be searched (it can be retrieved from methods in
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchInfoUtils.html" shape="rect">SearchInfoUtils</a></code>,
                or UI component controller <code><a href="org-netbeans-api-search/org/netbeans/api/search/ui/ScopeController.html" shape="rect">ScopeController</a></code>),
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchListener.html" shape="rect">SearchListener</a></code>
                that you should inform about events that happen during searching, and helper classes
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/SearchInfoUtils.html" shape="rect">SearchInfoUtils</a></code>
                (getting SearchInfo objects for nodes) and
                <code><a href="org-netbeans-api-search/org/netbeans/api/search/provider/FileNameMatcher.html" shape="rect">FileNameMatcher</a></code>
                (filtering files by file name).
            </api><api name="SearchProviderUIAPI" type="export" category="stable" url="org-netbeans-api-search/org/netbeans/api/search/ui/package-summary.html" group="java">

                Several UI components that can be used in presenters of search 
                providers, and factory method for creating them.
            </api><api name="SearchAPI" type="export" category="stable" url="org-netbeans-api-search/org/netbeans/api/search/package-summary.html" group="java">

                Contains classes for controlling search, passing search 
                criteria, and some helper classes.
            </api></module><module name="File Templates" target="org-netbeans-api-templates/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   This utility standardizes the process to use files as blueprints to create new files.
  
 </description><deploy-dependencies>
  <p>
   No specific deploy dependencies.
  </p>
 </deploy-dependencies><arch-usecases>
     <usecase id="template" name="Use boilerplates">
         <p>
             An existing file can be used as a boilerplate for creation of a new file.
             The boiler plate can contain necessary skeleton, comments, content. As the
             boilerplate resides on config filesystem, it is also customizable by the user
             and the user can eventually develop custom templates.
         </p>
         <p>
             In previous NetBeans versions, templating system was built into 
             <api category="official" group="java" name="DataSystemsAPI" type="export" url="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/index.html"/>.
         </p>
     </usecase>
     <usecase id="templateHandler" name="Custom template handlers">
        <p>
            Often many people require ability to create a "clever" template - e.g.
            write piece of simple text and at the time of its 
            <a href="org-netbeans-api-templates/org/netbeans/api/templates/FileBuilder.html#createFromTemplate-org.openide.filesystems.FileObject-org.openide.filesystems.FileObject-java.lang.String-java.util.Map-org.netbeans.api.templates.FileBuilder.Mode-" shape="rect">
                processing
            </a> 
            do some advanced changes to it using either 
            <a name="scripting" shape="rect">scripting or templating</a> languages.
        </p>
        <p>
            This traditionally used to be a bit complicated task (hacking into DataObject implementation), however since 
            version 6.1 there are interface in 
            <api category="deprecated" group="lookup" name="org.openide.loaders.CreateFromTemplateHandler" type="export" url="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/CreateFromTemplateHandler.html">
                DataSystem API
            </api>
            and finally
            <api category="official" group="lookup" name="org.netbeans.api.templates.CreateFromTemplateHandler" type="export" url="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateHandler.html">
                that can be registered as a services in a lookup and it is reponsible
                for handling the whole copy of the template file(s) to the destination
                folder.
            </api>
        </p>
     </usecase>
     <usecase id="templateAttributes" name="Custom attributes for processing">
         <p>
            Runtime or project-related values may be supplied by 
           <api category="official" group="lookup" name="org.openide.loaders.CreateFromTemplateAttributes" type="export" url="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateAttributes.html">
               that can be registered as a services in a lookup and it is reponsible
               for providing "hints" - e.g. map mapping strings to various objects.
           </api> and these interfaces allow anyone to extend the behaviour during
           creation of new files.
         </p>
         <p>
             The <a href="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateAttributes.html" shape="rect">CreateFromTemplateAttribute</a> implementation
             knows which template is being used, where the outcome should be placed, so it can derive appropriate values for both 
             the template and the target location.
         </p>
     </usecase>
     <usecase id="script" name="Using Scripting and Templating Languages">
        <p>
        There is a built in support for scripting languages in
        the standard NetBeans IDE. If a template is annotated with
        <api category="official" group="property" name="javax.script.ScriptEngine" type="export">
            a property that can be associated to templates that either should
            return real instance of <code>ScriptEngine</code> interface or
            a <code>String</code> name of the engine that is then used to
            search for it in the <code>javax.script.ScriptEngineManager</code>.
            Usually the <a href="http://freemarker.sourceforge.net/" shape="rect">freemarker</a> engine is the one that is 
            supported by the NetBeans IDE - if your module wants to use it
            then include a token dependency <code>OpenIDE-Module-Needs: javax.script.ScriptEngine.freemarker</code>
            in your manifest file (also accessible through project customizer GUI)
            to indicate to the system that you need it.
        </api>
        then the scripting engine is then used to process the template and
        generate the output file. While running the engine one can rely
        on few predefined properties:
        </p>

        <ul>
            <li><api category="stable" group="property" name="name" type="export"> contains the name of the <a href="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a> that is being created</api></li>
            <li><api category="stable" group="property" name="user" type="export"> contains the name the user</api></li>
            <li><api category="stable" group="property" name="nameAndExt" type="export"> contains the name and extension of the file that is being created</api></li>
            <li><api category="stable" group="property" name="date" type="export"> contains <code>String</code> representing the current day like <code>23. 3. 2007</code></api></li>
            <li><api category="stable" group="property" name="time" type="export"> contains <code>String</code> the current time like <code>17:18:30</code></api></li>
            <li><api category="stable" group="property" name="dateTime" type="export"> contains <code>java.util.Date</code> representing current data and time like</api></li>
            <li><api category="stable" group="property" name="encoding" type="export"> contains <code>String</code> the file encoding of the template instance</api></li>
        </ul>
        
        <p>
        Other properties can indeed be provided by
        <a href="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateAttributes.html" shape="rect">CreateFromTemplateAttributes</a>s.
        After processing, the output is also sent to appropriate
        <code>org.openide.text.IndentEngine</code> associated
        with the mime type of the template, for formating.
        </p>

        <p style="margin-left: 0.2in; margin-right: 0.2in; margin-top: 0.2in; margin-bottom: 0.2in; border: 1.00pt solid #9999cc; padding: 0.1in; color: #666699">
            <b>Smart Templating Quick How-To</b>
            <br/>
            
            First of all create a file in your module layer located somewhere
            under the <code>Templates/</code> folder. Make it a template by
            adding &lt;attr name="template" boolvalue="true"/&gt;. Associate
            this template with a scripting language, for example by
            &lt;attr name="javax.script.ScriptEngine" stringvalue="freemarker"/&gt;.
            Now make sure that the scripting language integration is also available
            by requesting a token in standard format, for freemarker just put
            <code>OpenIDE-Module-Needs: javax.script.ScriptEngine.freemarker</code>
            in your manifest. This tells the NetBeans module system that a 
            module providing integration with such scripting engine has to be 
            enabled. Now you can use regular script language tags inside of
            your template file. When you write your <code>instantiate</code>
            method in your wizard, you can create a Map&lt;String,Object&gt; and
            fill it with parameters collected from your wizard and then pass it 
            to
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">                
                createFromTemplate(targetFolder, targetName, mapWithParameters)
            </a>. This will invoke the scripting language and make the 
            <code>mapWithParameters</code> values available to it. Beyond this 
            there is few standard parameters predefined including <code>name</code>, <code>user</code>, <code>date</code>, <code>time</code>, etc.
            and also additional parameters are collected from all registered
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/CreateFromTemplateAttributesProvider.html" shape="rect">CreateFromTemplateAttributesProvider</a>s.
        </p>
        
     </usecase>
    <usecase id="file-sets" name="Create sets of files">
        <p>
            A <a href="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateHandler.html" shape="rect">CreateFromTemplateHandler</a>
            should be able to create multiple files, one of them <i>important</i> so it will open after user 
            initiates the creation action. The template of set of related files may be represented by a folder with
            a handler attached, and the operation deploys multiple files in the target directory.
        </p>
    </usecase>
    <usecase id="js-wizard" name="Use HTML and JavaScript">
        <a name="html-and-js" shape="rect"/>
        <p>
            There is a way to create a portable wizard (e.g. one that can
            be executed inside of NetBeans as well as in a browser). The 
            most portable UI these days is written in HTML. To
            register such HTML based wizard with your file template, 
            use <a href="org-netbeans-api-templates/org/netbeans/api/templates/TemplateRegistration.html" shape="rect">@TemplateRegistration</a>
            annotation and include <code>page()</code> attribute referencing
            your own HTML page:
        </p>
        <pre xml:space="preserve">
<b>public class</b> X {
    {@code @TemplateRegistration}(
        page = "x.html",
        scriptEngine = "freemarker",
        displayName = "JS Wizard",
        folder = "Other",
        content = "x.fmk"
    )
    <b>public static</b> String jsWizard() {
        <b>return</b> "yourInitializationCode();";
    }
}            
        </pre>
        <p>
            the return value of the annotated method (named <code>jsWizard</code>)
            should be of type String and its content should be snippet of 
            JavaScript code to execute inside of your specified HTML page 
            (e.g. <code>x.html</code>) to create an instance of 
            <a href="http://knockoutjs.com" shape="rect">KnockoutJS model</a> to 
            drive the wizard. Here is a sample code for the model:     
        </p>        
        <pre xml:space="preserve">
<b>function</b> yourInitializationCode() {
    <b>var</b> ok = ko.observable(false);
    <b>var</b> msg = ko.observable('');
    <b>var</b> current = ko.observable('Init');
    <b>var</b> data = {
        'errorCode': ko.computed(function() {
            if ('Init' == current()) <b>return</b> 0;
            if (!ok()) <b>return</b> 1;
            if (msg()) <b>return</b> 0;
            <b>return</b> 2;
        }),
        'current': current,
        'ok': ok,
        'msg' : msg
    }
    ko.applyBindings(data);
    <b>return</b> data;
}
</pre>
    <p>
        The model defines wizard composed of few panels (defined in following
        HTML file) and a verification function (registered as <code>errorCode</code>) 
        to check if everything is OK. In addition to that it defines 
        proprietary text value <code>msg</code> which is 
        going to be filled by the wizard and cannot be empty. Each
        page of the wizard is registered using a custom
        <a href="http://knockoutjs.com" shape="rect">Knockout.js</a> binding called
        <code>step</code>. Here is an HTML page defining three steps:
    </p>
<pre xml:space="preserve">
&lt;<b>section</b> data-bind="step: { 'id' : 'init', text : 'Initial Page'}" &gt;
    &lt;<b>p</b>&gt;
        Write your UI in portable HTML and display it in NetBeans 
        or on web! Read more at &lt;a href="http://wiki.netbeans.org/HtmlUIForTemplates"&gt;our wiki&lt;/a&gt;...
    &lt;/<b>p</b>&gt;
&lt;/<b>section</b>&gt;

&lt;<b>section</b> data-bind="step: 'info'" &gt;
    &lt;<b>p</b>&gt;
        Use &lt;a href="http://knockoutjs.com"&gt;knockout.js&lt;/a&gt; bindings 
        to isolate your view model from the actual look of your HTML
        page. Bind your view to model written in Java or JavaScript.
    &lt;/<b>p</b>&gt;
    &lt;<b>h3</b>&gt;Is everything OK?&lt;/<b>h3</b>&gt;
    &lt;<b>input</b> type="checkbox" data-bind="checked: ok"/&gt;
    &lt;<b>h3</b>&gt;How do you feel?&lt;/<b>h3</b>&gt;
    &lt;<b>input</b> type='text' data-bind="textInput: msg"/&gt;
&lt;/<b>section</b>&gt;

&lt;<b>section</b> data-bind="step: { 'id' : 'summary' }" &gt;
    &lt;<b>p</b>&gt;
        You are feeling &lt;<b>span</b> data-bind="text: msg"&gt;&lt;/<b>span</b>&gt;!
        Let's proceed to create a file which will express your 
        feeling by using &lt;<b>a</b> href="http://freemarker.org/"&gt;Freemarker&lt;/<b>a</b>&gt;
        templating engine and values filled in this wizard.
    &lt;/<b>p</b>&gt;
&lt;/<b>section</b>&gt;
</pre>
<p>
    The Next/Finish buttons are controlled by the <code>errorCode</code> property. 
    If it is non-zero, there is an error and these buttons are disabled. 
    Also once can use that inside of the HTML page to display user related errors: 
</p>
<pre xml:space="preserve">
&lt;<b>div</b> data-bind="visible: errorCode() == 1"&gt;
    &lt;<b>span</b> style="color: red"&gt;Please check you are OK!&lt;/<b>span</b>&gt;
&lt;/<b>div</b>&gt;
 
&lt;<b>div</b> data-bind="visible: errorCode() == 2"&gt;
    &lt;<b>span</b> style="color: red"&gt;Tell us how do you feel!&lt;/<b>span</b>&gt;
&lt;/<b>div</b>&gt;    
</pre>
<p>
The L10N of the wizard is done on the level of HTML pages. 
The whole page gets translated into different language with appropriate 
suffix like <code>x_cs.html</code> and it is then 
selected instead of the default one, when user runs in such locale.
</p>
<p>
When the wizard is successfully finished, all the values 
specified in the model (except system ones like <code>current</code>,
<code>errorCode</code>, etc.) are transfered to the templating engine, 
so they can influence the content of created files. 
Here is a sample <code>x.fmt</code> content which reuses the <code>msg</code> 
value provided by the wizard:     
</p>
<pre xml:space="preserve">
Hi,
I am Freemarker.
I feel ${wizard.msg}.    
</pre>
<p>
    When such file is instantiated, the <code>${wizard.msg}</code> is
    replaced by the actual value taken from the wizard.    
</p>
    </usecase>
    
    <usecase id="java-html" name="Use HTML and Java">
        <a name="html-and-java" shape="rect"/>
        <p>
            Some people would rather use Java instead of Java script while
            getting the portability of the <em>HTML</em>. There is a simple
            way to rewrite the <a href="#html-and-js" shape="rect">HTML and JavaScript sample</a>
            to <b>Java</b>
            (and possibly run it in a plugin-less browser via 
            <a href="http://bck2brwsr.apidesign.org" onclick="target='_blank'" shape="rect">bck2brwsr VM</a>). Keep the
            same HTML, <a href="http://freemarker.org/" onclick="target='_blank'" shape="rect">Freemarker</a>, etc.
            files - just instead of encoding the logic in JavaScript use Java:
        </p>
<pre xml:space="preserve">
{@link net.java.html.json.Model @Model}(className = "JavaWizard", properties = {
    {@link net.java.html.json.Property @Property}(name = "current", type = String.<b>class</b>),
    {@link net.java.html.json.Property @Property}(name = "ok", type = <b>boolean</b>.<b>class</b>),
    {@link net.java.html.json.Property @Property}(name = "msg", type = String.<b>class</b>)
})
<b>public class</b> JavaWizardCntrl {
    {@link net.java.html.json.ComputedProperty @ComputedProperty} <b>static int</b> errorCode(
        String current, boolean ok, String msg
    ) {
        if ("Init".equals(current)) <b>return</b> 0;
        if (!ok) <b>return</b> 1;
        if (msg == null || msg.isEmpty()) <b>return</b> 2;
        <b>return</b> 0;
    }
 
 
    {@code @TemplateRegistration}(
        page = "x.html",
        scriptEngine = "freemarker",
        displayName = "HTML/Java Wizard",
        folder = "Java",
        content = "x.fmk"
    )
    <b>public static</b> JavaWizard javaWizardFactory() {
        return new JavaWizard("Init", false, "");
    }
}            
</pre>        
<p>
    The return value of the annotated method is now an
    <a href="http://bits.netbeans.org/html+java/" onclick="target='_blank'" shape="rect">HTML/Java</a>
    model class which can naturally represent the essential 
    <a href="http://knockoutjs.com" onclick="target='_blank'" shape="rect">Knockout.js</a> objects
    in Java. 
</p>
    </usecase>
    <usecase id="target-chooser" name="Selecting target location with HTML UI">
        <a name="targetchooser" shape="rect"/>
        <p>
        It is very common that the HTML file creation wizards (either 
        controled by <a href="#html-and-js" shape="rect">JavaScript</a> or by
        <a href="#html-and-java" shape="rect">Java</a>) need to allow user to specify 
        target location of their file. To simplify such common task and
        to ensure its UI is consistent with the rest of the environment,
        one can just include following code snippet in the HTML file and
        leave its actual rendering on the system:
        </p>
<pre xml:space="preserve">
&lt;<b>section</b> data-bind="step: 'targetChooser'" &gt;
&lt;/<b>section</b>&gt;
</pre>     
<p>   
        Such section will then be replaced by a panel which provides appropriate
        UI for choosing target directory as well as name for the newly created
        file.
</p>
<a name="javaTargetChooser" shape="rect"/>
<p>
        In case one prefers more Java-like chooser, it is possible to use
        <code>'targetChooser:java'</code> as name of the step. Then all 
        Java source groups in target project will be listed and presented
        in a typical Java package view selection mode. Once can use different
        suffix than <code>java</code> to list other types of source groups.
        This feature requires presence of <code>org.netbeans.modules.java.project.ui</code>
        module, otherwise the target chooser falls back to classical one. 
</p>
    </usecase>    
    <usecase id="maven-wizard" name="UI for Maven Archetypes">
        <a name="html-and-maven" shape="rect"/>
        <p>
            There is a way to create a portable wizard (with logic either
            in <a href="#html-and-js" shape="rect">JavaScript</a> or in 
            <a href="#html-and-java" shape="rect">Java</a>) to instantiate a <b>Maven</b>
            archetype. This way one merges the <em>project templating</em>
            functionality of <b>Maven</b> with flexible and tailored UI
            provided by HTML and JS/Java.
        </p>
        <p>
            The definition of the UI is the same as in 
            <a href="#html-and-js" shape="rect">previous</a>
            <a href="#html-and-java" shape="rect">cases</a>, just as a <a href="#targetchooser" shape="rect">target chooser</a>
            one can also use dedicated <b>Maven</b> one - just use
            <code>'targetChooser:archetype'</code> to get a panel 
            with options to select directory, <code>archetypeId</code>,
            <code>groupId</code> and <code>version</code> of the project to
            create.
            This feature requires presence of <code>org.netbeans.api.maven</code>
            module, otherwise the target chooser falls back to classical one. 
        </p>
        <p>
            The archetype registration is then a classical one. Here is an
            example of the UI being in <code>x.html</code> and the archetype
            described in <code>x.archetype</code> one:
        </p>
        <pre xml:space="preserve">
    {@code @TemplateRegistration}(
        page = "x.html",
        displayName = "HTML/Java Wizard",
        folder = "Java",
        content = "x.archetype"
    )
    <b>public static</b> MavenWizard mavenArchetype() {
        <b>return new</b> MavenWizard(<em>/*...*/</em>);
    }
        </pre>
        <p>
            The <code>x.archetype</code> file describes the archetype to use
            and has following properties-like syntax:
        </p>
        <pre xml:space="preserve">
archetypeGroupId=org.codehaus.mojo.archetypes
archetypeArtifactId=javafx
archetypeVersion=0.6
archetypeBuild=false # or true to build the project once created
archetypeOpen=src/main/java/.*/Main.java,src/main/resources/default.config # regexp to 
# find files that should be opened once the project is created
        </pre>
        <p>
            The values <code>archetypeArtifactId</code>,
            <code>archetypeGroupId</code> and <code>archetypeVersion</code>
            are by default taken from the archetype definition file, but the
            wizard model can define these properties as well and in such case
            they would take precedence. These values define what Maven 
            archetype will be used to initialized the project structure.
        </p>
        <p>
            Any properties defined by the model (in the above example
            the <code>MavenWizard</code>) are going to be passed into 
            <b>Maven</b> archetype execution and can thus influence the 
            the behavior of the archetype - this is the way to write an
            HTML UI for <b>Maven</b> archetype.
        </p>
    </usecase>
 </arch-usecases><api name="DataSystemsAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/index.html" group="java"/><api name="org.openide.loaders.CreateFromTemplateHandler" type="export" category="deprecated" url="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/CreateFromTemplateHandler.html" group="lookup">
                DataSystem API
            </api><api name="org.netbeans.api.templates.CreateFromTemplateHandler" type="export" category="official" url="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateHandler.html" group="lookup">
                that can be registered as a services in a lookup and it is reponsible
                for handling the whole copy of the template file(s) to the destination
                folder.
            </api><api name="org.openide.loaders.CreateFromTemplateAttributes" type="export" category="official" url="org-netbeans-api-templates/org/netbeans/api/templates/CreateFromTemplateAttributes.html" group="lookup">
               that can be registered as a services in a lookup and it is reponsible
               for providing "hints" - e.g. map mapping strings to various objects.
           </api><api name="javax.script.ScriptEngine" type="export" category="official" group="property">
            a property that can be associated to templates that either should
            return real instance of <code>ScriptEngine</code> interface or
            a <code>String</code> name of the engine that is then used to
            search for it in the <code>javax.script.ScriptEngineManager</code>.
            Usually the <a href="http://freemarker.sourceforge.net/" shape="rect">freemarker</a> engine is the one that is 
            supported by the NetBeans IDE - if your module wants to use it
            then include a token dependency <code>OpenIDE-Module-Needs: javax.script.ScriptEngine.freemarker</code>
            in your manifest file (also accessible through project customizer GUI)
            to indicate to the system that you need it.
        </api><api name="name" type="export" category="stable" group="property"> contains the name of the <a href="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a> that is being created</api><api name="user" type="export" category="stable" group="property"> contains the name the user</api><api name="nameAndExt" type="export" category="stable" group="property"> contains the name and extension of the file that is being created</api><api name="date" type="export" category="stable" group="property"> contains <code>String</code> representing the current day like <code>23. 3. 2007</code></api><api name="time" type="export" category="stable" group="property"> contains <code>String</code> the current time like <code>17:18:30</code></api><api name="dateTime" type="export" category="stable" group="property"> contains <code>java.util.Date</code> representing current data and time like</api><api name="encoding" type="export" category="stable" group="property"> contains <code>String</code> the file encoding of the template instance</api><api name="org.netbeans.api.templates.IndentEngine" type="export" category="friend" group="property">
    A special ScriptEngine type is required to perform indentation on the produced sources.
    The ScriptEngine must provide a name "<code>org.netbeans.api.templates.IndentEngine</code>". 
    The only attribute property passed to the ScriptContext is <code>mimeType</code> of the 
    text being formatted.
    </api><api name="freeFileExtension" type="export" category="stable" group="property">
          A parameter for template creation, possibly specified as a template file layer attribute that controls
          how the extension for the new file is computed. See <a href="org-netbeans-api-templates/org/netbeans/api/templates/CreateDescriptor.html#FREE_FILE_EXTENSION" shape="rect">
        CreateDescriptor javadoc </a> for the details.
      </api><api name="org-netbeans-modules-java-preformattedSource" type="export" category="stable" group="property">
          A parameter for template creation, possibly specified as a template file layer attribute that controls
          formatting of the produced text. See <a href="org-netbeans-api-templates/org/netbeans/api/templates/CreateDescriptor.html#PREFORMATTED_TEMPLATE" shape="rect">
        CreateDescriptor javadoc </a> for the details.
      </api></module><module name="Visual Library API" target="org-netbeans-api-visual/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      The Visual Library 2.0 is the next generation of the original Graph Library 1.0.
      It is designed for a general visualization with a support for graph-oriented modeling.
      Its focus is to become a part of the NetBeans platform and unify the visualization (UI and API) used in NetBeans-Platform-based applications.
      See http://graph.netbeans.org/ web-site for details.
      See documentation for complete set of use-cases and code-snippets.
  
 </description><deploy-dependencies>
  <p>
   No. Just set a normal project dependency on org.netbeans.api.visual (spec no.: 2.0) module.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
      See <a href="org-netbeans-api-visual/org/netbeans/api/visual/widget/doc-files/documentation.html" shape="rect">documentation</a> for complete set of use-cases.
  </p>
 </arch-usecases><api name="VisualLibraryAPI" type="export" category="official" group="java">
     <p>
      The API provides a set of reusable pieces - widgets. By composing them you are creating a visualization.
      Each widget has various properties including layout, border, assigned actions, ... The library contains a set of pre-defined widgets that can be extended.
      All pluggable pieces are declared as interfaces or abstract classes - WidgetAction, Anchor, AnchorShape, PointShape, Animator, Border,
      GraphLayout, LookFeel, Layout, SceneLayout, Router, CollisionsCollector.
      Also they all have their built-in implementation.
     </p>
   </api></module><module name="XML Tools API" target="org-netbeans-api-xml/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
It helps with editing XML files and supports leveraging XML in developed application.
</description><api name="XMLAPIs" type="export" category="official" url="index.html" group="java"/></module><module name="Bootstrap" target="org-netbeans-bootstrap/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        The NetBeans launcher starts the application. Different launchers are
        provided for different supported platforms - Unix/Linux, Windows, and
        others. There are also a handful of classes in the
        org.netbeans and org.netbeans.core packages
        which directly support early startup features, such as command-line
        options.
    </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
     <usecase id="invalidate.cache" name="Invalidating Caches">
        <a name="usecase-invalidate.cache" shape="rect"/>
        <p>
            NetBeans Module system is optimized to eliminate useless I/O
            operations on start (as a result the <a href="http://netbinox.apidesign.org" shape="rect">
            embedded OSGi container</a> is fastest on the planet -- with respect to 
            application start up time). This is achieved by caching information
            known to have been needed in previous starts and using it
            rather than obtaining it again from the module JAR files.
        </p>
        <p>
            There are various caches (like 
                <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-all-layers.dat" shape="rect">all-layers.dat</a>,
                <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-all-manifests.dat" shape="rect">all-manifests.dat</a>,
                <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-all-resources.dat" shape="rect">all-resources.dat</a>,
                <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-core-netigso/architecture-summary.html#java.io.File-netigso-bundles" shape="rect">netigso-bundles</a>,
                etc.
            ) provided by the module system or by other subsystems of the application.
            Together, working in orchestration, they eliminate the need to
            touch the disk (which is very slow operation especially during
            <a href="http://wiki.apidesign.org/wiki/Startup#Morning_Launch" shape="rect">morning launch</a>).
            Btw. there is a <a href="http://hg.netbeans.org/releases/file/cdbdc70050a8/core.startup/test/unit/src/org/netbeans/core/startup/layers/CachingPreventsFileTouchesTest.java" shape="rect">
            test which verifies</a> 
            the caching system really works
            -- it is recommended for each product built on top of NetBeans Platform
            to copy and adjust it to verify the caches are really used.
        </p>
        <p>
            Of course, the caches may get out of date, for example when an external
            tool modifies the installation layout. 
            How can the system detect whether the caches are valid and 
            still be usable? The only way to verify the
            caches are 100% correct is to regenerate them and compare whether the
            cached bits are the same. However that would be terribly slow and defeat 
            the whole purpose of using caches.
        </p>
        <p>
            As such we have the <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-.lastModified" shape="rect">lastModified API</a>.
            Every cluster (as enumerated by <a href="org-netbeans-bootstrap/architecture-summary.html#systemproperty-netbeans.dirs" shape="rect">netbeans.dirs</a>
            and <a href="org-netbeans-bootstrap/architecture-summary.html#systemproperty-netbeans.home" shape="rect">netbeans.home</a> properties)
            is supposed to contain such file. Whenever an external tool changes something
            inside some cluster, it is supposed to touch the file and change its 
            timestamp. That will tell the system that caches are invalid 
            (as their timestamps will become older than newest <code>.lastModified</code> file).
        </p>
     </usecase>
     <usecase id="shared.cache" name="Generating Shared Cache">
         <p>
             The caches (as introduced in <a href="org-netbeans-bootstrap/architecture-summary.html#usecase-invalidate.cache" shape="rect">
             invalidating caches</a> section) are optimized to reflect the state of 
             previous start. However that means, the very first start runs
             without them. This may not be a problem (if the start follows
             immediately after installation), however in <a href="http://wiki.apidesign.org/wiki/Startup#Multi_User_Initial_Launch" shape="rect">
             multi user environment</a> (when the installation is done by administrator), 
             the first start may be slow. 
         </p>
         <p>
             To mitigate that the system offers support for <em>shared caches</em>.
             As part of installation, one can also copy <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-installation.cache" shape="rect">
             certain cache files
             </a> into the shared location. Those files will then be used
             on a first start of the system (when the user directory is empty).
         </p>
         <p>
             To generate the shared cache files start NetBeans with an empty,
             temporary user directory and then copy the desired files into
             first cluster directory:
         </p>
         <pre xml:space="preserve">
$ netbeans --userdir /tmp/nb -J-Dnetbeans.close=true -J-Dorg.netbeans.core.WindowSystem.show=false
$ cd /tmp/nb
$ zip -r $INSTALL/$first_netbeans_dirs_dir/var/cache/populate.zip var/cache/netigso
$ cp var/cache/* $INSTALL/$first_netbeans_dirs_dir/var/cache
$ rm -r /tmp/nb/
         </pre>
         <p>
             The meaning of <code>populate.zip</code> and list of known cache
             files is described <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-installation.cache" shape="rect">here</a>.
             Additional modules and subsystems may add new files however. The 
             ultimate knowledge is available only to those who understand overall
             product installation structure.
         </p>
     </usecase>
     <usecase id="patch" name="Patch classes">
         <a name="usecase-patch" shape="rect"/>
         <p>
         In case one wants to modify other classes before they get loaded into
         the VM, one can register its own
         <code>Agent-Class</code> and then be called whenever another
         class is defined. The behavior matches as closely as possible the one
         provided by <a href="http://download.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html" shape="rect">
         JDK instrument package</a>. To patch bytecode of other classes
         register your class in manifest and in its static <code>agentmain</code> method
         add your own <a href="http://download.oracle.com/javase/8/docs/api/java/lang/instrument/ClassFileTransformer.html" shape="rect">ClassFileTransformer</a>
         which will then be consulted whenever new classes are loaded.
         </p>
         <pre xml:space="preserve">
# following line should be in manifest of your module
Agent-Class: your.pkg.Transformer             

// this should be your class
package your.pkg;
public class Transformer implements ClassFileTransformer {
    public static void agentmain(String args, Instrumentation i) {
        i.addTransformer(new Transformer());
    }
             
    public byte[] transform(
        ClassLoader loader, String className, Class classBeingRedefined, 
        ProtectionDomain protectionDomain, byte[] classfileBuffer
    ) {
        // do your transformation
    }
}
</pre>
        <p>
        The implementation tries to be as complient as possible with the
        original JDK's specification, but 
        some differences are inevitable. For example the <code>classBeingRedefined</code>
        parameter in the previous example is always <code>null</code>
        as NetBeans runtime container does not
        have access to the class instance that is being defined yet.
        </p>
     </usecase>
     
     <usecase id="modfrag" name="Module Fragments">
         <a name="usecase-modfrag" shape="rect"/>
         <p>
            This is a specific case of <a href="#usecase-patch" shape="rect">Patch Classes</a> use-case.
            To maintain binary compatibility when <b>removing</b> methods from API classes,
            the "removed" implementation is actually moved to a special class, which becomes
            a <i>superclass</i> of the original API class. Such special classes should be
            separated into a 'compat' module, which is only loaded in presence of old clients.
         </p>
         <p>
            The compat module should declare it is a fragment of the original API module in its
            <code>MANIFEST.MF</code>
         </p>
            <pre xml:space="preserve">
OpenIDE-Module-Fragment-Host: orignal.module.codename
            </pre>
        <p>
            which ensures contents of the compat module will be loaded using classloader
            of the 'fragment host' module. The compat module will not get its own classloader.
            The special class itself should be marked using <a href="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/PatchFor.html" shape="rect">PatchFor</a> annotation,
            which causes it will be patched as superclass and inserted into the inheritance
            chain.
         </p>
     </usecase>
 </arch-usecases><api name="nbexec" type="export" category="stable" url="http://platform.netbeans.org/articles/installation.html#launcher" group="java.io.File"/><api name="lock-file" type="export" category="private" group="java.io.File">
                    The lock file <samp>${netbeans.user}/lock</samp> will have file
                    permissions changed to <samp>go-rwx</samp> for safety on Unix
                    systems (requires presence of <code>chmod</code>)</api><api name="nbexec.exe" type="export" category="stable" url="http://platform.netbeans.org/articles/installation.html#launcher" group="java.io.File"/><api name="ClassPath-Composition" type="export" category="private" group="java.io.File">
            Bootstrap code creates a class loader to load the rest of the core from.
            The bootstrap code is loaded from the Java application class loader,
            using the classpath <samp>lib/*.jar</samp>.
        </api><api name="Dynamic-ClassPath-Composition" type="export" category="friend" group="java.io.File">
            After creating bootstrap classpath another low level set of JARs is loaded with a new
            classloader from <samp>core/*.jar</samp> directories in each clusters.
        </api><api name="java.util.logging.Level.1973" type="export" category="deprecated" group="property">
            LogRecords sent to registered logger may be marked as those intended
            for user. This can be done by logging with level which has intValue() == 1973.
            Localized message of such log records is then shown in a special 
            dialog. This behaviour is supported for backward compatibility, but
            in fact it is deprecated. The preferred way is to directly show
            dialog using <code>DialogDisplayer</code>.
        </api><api name="netbeans.exception.alert.min.level" type="export" category="devel" group="systemproperty">
            Minimum integer level that triggers the blinking icon signaling an
            exceptional state. By default 900 - e.g. WARNING.
        </api><api name="netbeans.exception.report.min.level" type="export" category="devel" group="systemproperty">
            Minimum integer level that triggers the dialog with exception.
            By default 900 with assertions on and 1001 without them.
        </api><api name="netbeans.mainclass" type="export" category="friend" group="systemproperty">
                    Main Java class for bootstrap code to start (currently <code>org.netbeans.core.startup.Main</code>).
                    Might be used by alternate launchers.
                </api><api name="NetBeans-IDE-Dev" type="export" category="private" group="property">
                    The registry key <code>Software\netbeans.org\NetBeans IDE\Dev</code>
                    Default user directory, unless <samp>--userdir</samp> is
                    given. The name of this registry key is brandable, as is its
                    default value. [Windows only]
                </api><api name="netbeans.home" type="export" category="devel" group="systemproperty">
                    NetBeans installation directory (where the launcher is).
                </api><api name="netbeans.user.dir" type="export" category="devel" group="systemproperty">
                    If this property is provided, it is used as the current working
                    directory regardless of the value of <code>user.dir</code>.
                </api><api name="netbeans.dirs" type="export" category="friend" group="systemproperty">
                    Additional secondary NetBeans installation directories as proposed in <a href="https://platform.netbeans.org/articles/installation.html" shape="rect">installation structure</a>
                    design document.
                </api><api name="netbeans.fallback.cache" type="export" category="friend" group="systemproperty">
                    Alternative location of NetBeans fallback cache generated during
                    installation (see <a href="#java.io.File-installation.cache" shape="rect">installation cache</a>
                    for description of the files layout). 
                    If the property is set to <code>none</code>,
                    then the fallback cache check is completely disabled.
                </api><api name="netbeans.classpath" type="export" category="friend" group="systemproperty">
                    Classpath to prepend to core loader (normally just
                    <samp>lib/*.jar</samp>). Possibly useful for testing
                    infrastructure etc.
                </api><api name="netbeans.systemclassloader.patches" type="export" category="devel" group="systemproperty">
                    By setting this system property
                    to a classpath (list of directories and JARs separated by the normal
                    path separator) you may append to the system class loader.
                </api><api name="netbeans.patches.cnb" type="export" category="devel" group="systemproperty">
                    By setting a system property to <code>"netbeans.patches." + module.getCodeNameBase()</code>
                    one can influence installed modules without changing the build.
                    Format is <code>-Dnetbeans.patches.org.nb.mods.foo=/path/to.file.jar:/path/to/dir</code>.
                </api><api name="org.netbeans.ProxyClassLoader" type="export" category="private" group="logger">
                    This logger logs at <code>WARNING</code> level about accessing resources from the default package.
                </api><api name="netbeans.importclass" type="export" category="friend" group="systemproperty">
                    There is a special support for importing the settings from previous
                    versions. As only the product itself knows about what to import and
                    where this cannot be done directly in the launcher, but we need at 
                    a well defined moment (user directory is missing and no modules
                    have been initialized yet) to call the product to ask the user 
                    and do the actual copy of userdir. 
                    <p/>
                    After all <code>core/*.jar</code> files has been initialized
                    and the user dir has not yet been updated (see bellow) the 
                    launcher checks for value of <code>netbeans.importclass</code>
                    system property and if provided it loads that class and invokes
                    its main method (in AWT thread) and if no exception is thrown it 
                    marks the userdir as already upgraded.
                </api><api name="imported-marker" type="export" category="friend" group="java.io.File">
                    <samp>${netbeans.user}/var/imported</samp> is used to identify whether a userdir has already been updated
                    or it still needs an update. Can be created by installer if no update
                    check should be performed, no other code is supposed to realy on 
                    this file.
                </api><api name="netbeans.accept_license_class" type="export" category="friend" group="systemproperty">
                    Before first usage of IDE user must accept license. If user does not install IDE
                    by installer (user must accept license during installation) user must accept license
                    during IDE first start.
                    <p>Launcher calls method <code>showLicensePanel</code> of <code>netbeans.acceptlicenseclass</code>
                    if license was not yet accepted by user and it is necessary to show license
                    in dialog to user.</p>
                </api><api name="license-check-marker-file" type="export" category="friend" group="java.io.File">
                    <samp>${netbeans.user}/var/license_accepted</samp> and <samp>${nbcluster.dir}/var/license_accepted</samp>
                    are used to identify whether user accepted license.
                </api><api name="netbeans.logger.console" type="export" category="friend" group="systemproperty">
                    <p>
                        Controls whether to log messages to the console, or just to the log file.
                    </p>
                </api><api name="org.netbeans.CLIHandler" type="export" category="private" group="systemproperty">
                    <p>
                        Setting this property to less than zero value enables logging of what is
                        going on in the CLIHandler - e.g. in the code that locks user directory and
                        handles processing of command line options. Use <code>-J-Dorg.netbeans.CLIHandler=-1</code>
                        to send the logging to <code>System.err</code>.
                    </p>
                </api><api name="org.netbeans.CLIHandler.server" type="export" category="devel" group="systemproperty">
                    <p>
                        One can disable the CLI server (listening on commands
                        from subsequent invocations) by setting property
                        <code>org.netbeans.CLIHandler.server</code> to <code>false</code>.
                    </p>
                </api><api name="org.netbeans.core.systemfilesystem.custom" type="export" category="friend" group="systemproperty">
                    <p>
                        Contains class name of a class that can serve as provider of the writable layer of the
                        system file system. The class must be a subclass of 
                        <code>org.openide.filesystems.FileSystem</code> and have public default constructor.
                        Morevoer the class denoted by the property must be on the classpath.
                    </p>
                </api><api name="netbeans.security.nocheck" type="export" category="devel" group="systemproperty">
                    By default NetBeans prevent certain operations like <code>System.exit</code>. 
                    One can disable this behavior by providing <code>-Dnetbeans.security.nocheck=true</code>.
                    Since version 2.47 such property also allows the <code>SecurityManager</code>
                    to be replaced by another.
                </api><api name="sun.awt.datatransfer.timeout" type="export" category="devel" group="systemproperty">
                    Specifies the amount of milliseconds the call to
                    <code>getContent()</code> method of <code>ExClipboard</code>
                    waits to synchronize with system clipboard. Defaults to 1000ms.
                </api><api name="netbeans.ignore.dupmodule" type="export" category="devel" group="systemproperty">
                    By default ModuleManager throws <code>DuplicateException</code> when an attempt is made
                    to load an already loaded module.
                    One can change this behavior by providing <code>-Dnetbeans.ignore.dupmodule=true</code>
                    since version 2.63. When <code>-Dnetbeans.ignore.dupmodule=true</code> is provided,
                    attempt of duplicate loading is logged instead of throwing <code>DuplicateException</code>.
                </api><api name="org.netbeans.PatchByteCode.disable" type="export" category="friend" group="systemproperty">
                    For backward compatibility, the NetBeans startup code performs bytecode manipulation such as 
                    making marked methods <i>public</i> or injecting code that was deprecated and removed from
                    the NetBeans codebase. For debugging, or simply in order to disable preprocessing, patching
                    may be disabled. Note that older modules, which were not recompiled against the released version's sources may
                    become broken, if bytecode patching is disabled.
                </api><api name="--jdkhome" type="export" category="devel" group="cli">
                    JDK (or perhaps JRE) installation directory.
                </api><api name="--clusters" type="export" category="devel" group="cli">
                    The list of clusters to intialize the system from. Is
                    used to set the value of <code>netbeans.dirs</code>.
                </api><api name="--userdir" type="export" category="devel" group="cli">
                    User directory, if not the default.
                </api><api name="-JWHATEVER" type="export" category="devel" group="cli">
                    Pass option <samp>WHATEVER</samp> to the JVM.
                </api><api name="--cp" type="export" category="devel" group="cli">
                    <samp>-cp:a</samp> and <samp>-cp:p</samp> append and prepend
                    to the startup classpath; deprecated except for special
                    purposes such as installing a custom look &amp; feel.
                </api><api name="--ui" type="export" category="devel" group="cli">
                    Specify a look &amp; feel. The same as --laf.
                    To make human life easier simple translation was added to convert L&amp;F ID to
                    L&amp;F class name for known L&amp;Fs.
                    <ul>
                    <li>Metal is translated to javax.swing.plaf.metal.MetalLookAndFeel</li>
                    <li>GTK is translated to com.sun.java.swing.plaf.gtk.GTKLookAndFeel</li>
                    <li>Nimbus is translated to com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel</li>
                    <li>Windows is translated to com.sun.java.swing.plaf.windows.WindowsLookAndFeel</li>
                    <li>Aqua is translated to apple.laf.AquaLookAndFeel</li>
                    </ul>
                    
                </api><api name="--laf" type="export" category="devel" group="cli">
                    Specify a look &amp; feel. The same as --ui.
                </api><api name="--bootclass" type="export" category="devel" group="cli">
                    Alternative main class used to initialize the system.
                </api><api name="--fontsize" type="export" category="deprecated" group="cli">
                    Specify base fontsize. Deprecated in favor of using <a href="http://ui.netbeans.org/docs/ui/themes/themes.html" shape="rect">themes</a>
                    which is much more general. But this is a convenient quick
                    settings, handy for projection screens and so on.
                </api><api name="--locale" type="export" category="devel" group="cli">
                    Specify system locale.
                </api><api name="--branding" type="export" category="devel" group="cli">
                    Specify application branding.
                </api><api name="--nologging" type="export" category="private" group="cli">
                    Do not write a log file.
                </api><api name="--nosplash" type="export" category="friend" group="cli">
                    Do not show the splash screen.
                </api><api name="--nogui" type="export" category="friend" group="cli">
                    Do not show any GUI at all.
                </api><api name="--reload" type="export" category="devel" group="cli">
                    Reload a test module.
                </api><api name="SplashOnByDefault" type="export" category="devel" group="property">
                    can be <code>true</code> or <code>false</code>, allows
                    some applications build on top of the platform to disable
                    splash by default
                </api><api name="lookup.org.netbeans.CLIHandler" type="export" category="friend" group="lookup">
            <p>
                Instances of <code>org.netbeans.CLIHandler</code> are found using
                services lookup in the "dynamic classpath loader" (i.e. startup
                classpath plus <samp>${netbeans.home}/core/*.jar</samp>).
            </p>
        </api><api name="org.netbeans.ModuleFactory" type="export" category="friend" group="lookup">
            <p>
                Instances of <code>org.netbeans.ModuleFactory</code> are found using
                services lookup in the "dynamic classpath loader" (i.e. startup
                classpath plus <samp>${netbeans.home}/core/*.jar</samp>). ModuleFactory
                can be used to create alternative module implementations.
            </p>
        </api><api name="CoreBridge" type="export" category="private" group="lookup">
            <p>
                The communication between <code>core.jar</code> and rest of the platform code
                in <code>org-netbeans-core.jar</code> is handled thru 
                handled thru <code>CoreBridge</code> calls.
            </p>
        </api><api name="RunLevel" type="export" category="friend" group="lookup">
            <p>
                Additional callbacks from <code>core.jar</code> after the module system is started
                are done using <code>RunLevel</code> interface. Currently it starts window system.
            </p>
        </api><api name="java.util.logging.Handler" type="export" category="friend" group="lookup">
            <p>
                There is a communication bridge between the default logging handler
                registered by core/startup and the UI handler in core that
                presents certain log records in the UI.
            </p>
        </api><api name=".lastModified" type="export" category="devel" group="java.io.File">
            <p>
            To speedup testing that module caches are up-to-date, the system
            recognizes special file inside of each cluster. If <code>.lastModified</code>
            file is present in a cluster, then the content of the cluster is not 
            scanned any more deeply and instead the time stamp of the file is
            used as last modification for the whole content of the cluster.
            </p>
            
            <p>
            This API is primarily intended for use by installer and RPM packagers
            and also autoupdate, that are supposed to create such file, as soon
            as they finish modifications to any cluster. 
            </p>
            
            <p>
            This file is ignored when accessing user directory, as it is expected
            that user can modify it, while the user usually does not have access
            permision or need to modify the shared installation clusters.
            </p>
        </api><api name="cached.lastModified" type="export" category="private" group="java.io.File">
            <p>
            If the <code>.lastModified</code> file is not present in cluster
            directory, it is recomputed on startup and stored in
            <code>$userdir/var/cache/lastModified/$clustername</code>. This
            file and its content is meant just for private consumption of the
            IDE.
            </p>
        </api><api name="installation.cache" type="export" category="friend" group="java.io.File">
            <p>
                Installer can speed NetBeans IDE start by generating caches when the
                installation is over. Such caches are stored in the installation,
                in first cluster listed by <a href="#systemproperty-netbeans.dirs" shape="rect">
                netbeans.dirs</a> 
                (or in a location specified by <a href="#systemproperty-netbeans.fallback.cache" shape="rect">
                netbeans.fallback.cache</a> property, if available)    
                and have the same layout as user caches 
                (including here in described caches like <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-all-resources.dat" shape="rect">all-resources.dat</a>, 
                as well as caches provided by other subsystems like 
                <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-core-netigso/architecture-summary.html#java.io.File-netigso-bundles" shape="rect">
                netigso-bundles</a>)
                in the user directory - e.g. they are under <code>var/cache</code>.
            </p>
            <p>
                If a file <code>var/cache/populate.zip</code> is found, its 
                content is unzipped into user directory (if it is empty).
            </p>
        </api><api name="all-resources.dat" type="export" category="friend" group="java.io.File">
            <p>
            To speedup class loading during startup, the system keeps a cache
            of resources needed during startup in var/cache/all-resources.dat.
            If the cache is valid, it is loaded during startup and class
            and resource loading requests are redirected there.
            </p>
                        
            <p>
            The file is binary and shouldn't be modified by other code than
            <code>org.netbeans.Archive</code>. The file content uses magic header
            and versioning to allow evolution of its (private) format.
            The location is however well known for 
            <a href="org-netbeans-bootstrap/architecture-summary.html#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="all-files.dat" type="export" category="friend" group="java.io.File">
            <p>
            Rather than seeking on disk and using <code>access</code> OS call uselessly
            to find that some file is not present, the layout of files under
            the clusters is recorded in <code>var/cache/all-files.data</code>.
            </p>
                        
            <p>
            The file is binary and its format is <em>private</em>. The location
            is however well known for 
            <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="all-layers.dat" type="export" category="friend" group="java.io.File">
            <p>
            Modules register their functionality into the system using 
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#how-layer" shape="rect">layers</a>.
            To avoid parsing and merging of content of these files on each start, 
            the system creates a cached, binary representation of the layers
            structure in <code>var/cache/all-layers.dat</code> and
            <code>var/cache/all-local-layers.dat</code>.
            </p>
                        
            <p>
            The file is binary and its format is <em>private</em>. The location
            is however well known for 
            <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="all-clusters.dat" type="export" category="friend" group="java.io.File">
            <p>
                Lists relative paths of clusters (those defined by
                <a href="#systemproperty-netbeans.home" shape="rect">netbeans.home</a> and
                <a href="#systemproperty-netbeans.dirs" shape="rect">netbeans.dirs</a>)
                for which the cache has been created. This is an important file
                in the 
                <a href="#java.io.File-installation.cache" shape="rect">shared cache</a> as
                it helps to ensure the set of clusters has not changed since
                the cache has been generated.
            </p>
            <p>
                The file is binary and its format is <em>private</em>. The location
                is however well known for 
                <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="all-installer.dat" type="export" category="friend" group="java.io.File">
            <p>
                Additional information about modules (like <em>deprecation message</em>, etc.)
                is stored in <code>var/cache/all-installer.dat</code> to avoid the need
                to parse it out on each start.
            </p>
                        
            <p>
                The file is binary and its format is <em>private</em>. The location
                is however well known for 
                <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="all-manifests.dat" type="export" category="friend" group="java.io.File">
            <p>
                Graph of dependencies between modules, sorted startup order,
                state of modules 
                is stored in <code>var/cache/all-manifests.dat</code> to avoid the need
                to compute this information on every start.
            </p>
                        
            <p>
                The file is binary and its format is <em>private</em>. The location
                is however well known for 
                <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="all-modules.dat" type="export" category="friend" group="java.io.File">
            <p>
                Pre-parsed content of <code>config/Modules/*.xml</code>
                is cached in <code>var/cache/all-modules.dat</code>.
            </p>
                        
            <p>
                The file is binary and its format is <em>private</em>. The location
                is however well known for 
                <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="package-attrs.dat" type="export" category="friend" group="java.io.File">
            <p>
                Cache of various attributes of packages (vendor, spec &amp; impl version, etc.)
                is stored in <code>var/cache/package-attrs.dat</code>. This
                file is often almost empty to signal such information 
                is not provided by any module.
            </p>
                        
            <p>
                The file is binary and its format is <em>private</em>. The location
                is however well known for 
                <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
        </api><api name="localeVariants" type="export" category="friend" group="java.io.File">
            <p>
                File <code>var/cache/localeVariants</code> contains information
                about used branding and L10N files for each module. Avoids checking
                for <code>locale/xyz_cs_CZ.jar</code> files when (for example) only English
                L10N are present.
            </p>
                        
            <p>
                The file is binary and its format is <em>private</em>. The location
                is however well known for 
                <a href="#java.io.File-installation.cache" shape="rect">purposes of installer</a>.
            </p>
            
            <p>
            One can control creation of the <code>all-resources.dat</code> file in
            the user directory via 
            <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-core-startup/architecture-summary.html#systemproperty-org.netbeans.core.update.all.resources" shape="rect">
                org.netbeans.core.update.all.resources
            </a> property.
            </p>
        </api><api name="ExceptionAnnotatableUsingLogRecords" type="export" category="friend" group="java">
               To support classification of exceptions and also annotation of
               exceptions with logging levels and additional localized messages,
               logged exceptions and their initCause's are searched for 
               implementation of <code>Callable&lt;LogRecord[]&gt;</code>. 
               If an exception implements this interface, the <code>call()</code>
               method is called and returned <code>LogRecords</code> then
               scanned for messages, levels, etc.
            </api></module><module name="Core" target="org-netbeans-core/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
   No special APIs exported beyond few friend contracts:
   <ul>
    <li><api category="friend" group="java" name="org.netbeans.core.modules.AutomaticDependencies" type="export" url="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#refactoring"/></li>
    <li><api category="friend" group="java" name="org.netbeans.core.WindowSystem" type="export"/></li>
   </ul>
 </arch-usecases><api name="NetBeansCore" type="export" category="friend" group="java">
   The heart of NetBeans. It contains basic implementation of all necessary
   interfaces, takes care of the startup sequence and the whole lifecycle
   of any NetBeans based application.
   </api><api name="org.netbeans.core.modules.AutomaticDependencies" type="export" category="friend" url="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#refactoring" group="java"/><api name="org.netbeans.core.WindowSystem" type="export" category="friend" group="java"/><api name="org.netbeans.core.actions.OptionsAction.additionalActionName" type="export" category="private" group="property">
        Creates button with given string in bottom left corner of Options Dialog.
   </api><api name="org.netbeans.core.actions.OptionsAction.additionalActionListener" type="export" category="private" group="property">
        Given ActionListener is notified when custom button is pressed.
   </api><api name="org.netbeans.core.actions.OptionsAction.optionsDialogTitle" type="export" category="private" group="property">
        Allows to redefine default title of Options Dialog.
   </api><api name="USE_Authentication" type="export" category="devel" group="branding">
        One can use branding to disable installation of NetBeans own
        <code> java.net.Authenticator</code>. Just brand 
        <code>org.netbeans.core.Bundle</code>
        to say <code>USE_Authentication=false</code>
   </api><api name="StaticNonProxyHosts" type="export" category="devel" group="branding">
        Some applications may want to proxy connections to 
        localhost (which by default uses direct connection in NetBeans Platform).
        One can change the default by branding
        <code>org.netbeans.core.Bundle</code>
        specify something else than <code>StaticNonProxyHosts=localhost|127.0.0.1</code>.
   </api><api name="NbKeymap.context" type="export" category="friend" url="http://www.netbeans.org/source/browse/editor/src/org/netbeans/core/NbKeymap.html" group="java">
        The <code>context</code> field is accessed from editor module by reflection
        from <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib/org/netbeans/editor/MultiKeymap.html" shape="rect">MultiKeymap</a>.
    </api><api name="ErrorNotification" type="export" category="private" group="property">
       <p>
        Enabling assertions (either global -ea or for class org.netbeans.core.NotifyException only) 
        changes the default error notification behavior. When assertions are enabled
        an error window pops up each time an error is encountered. Otherwise a small
        icon start flashing in the main status bar and clicking the icon then brings
        up the error dialog.
       </p>
       <ul>
            <li>The status bar notification shows a small icon starts flashing 
                at the rightmost part of the main status bar when an 
                exception occurs</li>
            <li>The icon is flashing for 5 seconds, then it stays
                visible for another 30 seconds. Positioning the mouse pointer 
                over the icon changes the default mouse cursor to 'hand' 
                and stops the flashing. Icon's tooltip provides the exception 
                message or the exception class name when no message is available. 
                Single-clicking the icon brings up the exception dialog and 
                the icon disappers. The exception dialog shows all exceptions 
                encountered since the icon started flashing. When the exception 
                dialog is closed via the Ok button, the exception list is cleared. 
             </li>
            <li>The exception dialog window 'remembers' (per IDE session) the 
            status of the 'Show Details' flag. So when the dialog is 
            displayed again, the last user's settings are reused. 
            </li>
            <li>When another exception is encountered while the icon is 
            already flashing or visible, the flashing timer and the hide 
            icon timer will restart. </li>
            <li>When another exception is encountered while the exception 
            dialog is visible, the exception message is displayed in 
            the current dialog and the icon does not appear.</li>
            <li>There's no tooltip nor any indication on status bar when the 
            icon is not visible. Only a part of status bar area is reserved 
            for the icon.</li>
            <li>It is possible to switch the status bar notification 
            off, e.g. for beta releases, by enabling assertions in JVM (-ea).
            Then each exception shows the exception dialog.</li>    
       </ul>
   </api><api name="netbeans.hack.50423" type="export" category="private" url="http://www.netbeans.org/issues/show_bug.cgi?id=50423" group="systemproperty">
        Set this property to <q>true</q> to workaround the bug #50423 which
        appears on some linuxes on JDK 1.5.
   </api><api name="netbeans.close.no.exit" type="export" category="friend" group="systemproperty">
        Set this property to <q>true</q> if you do want to cleanup the module system,
        but not call System.exit at the end. Used from <code>NbModuleSuite</code> from
        nbjunit library.
   </api><api name="TimableEventQueue.install" type="export" category="friend" group="branding">
        By default NetBeans based applications install their own <code>EventQueue</code>.
        One can suppress that since versiong 3.27 of <code>org.netbeans.core</code> module
        by branding key <code>TimableEventQueue.install</code> in
        <code>org/netbeans/core/Bundle</code> to <code>false</code>.
    </api><api name="uihandler-hooks" type="export" category="friend" group="java">
       This module exports an API that allows the UI Gestures Collector module
       to plug and enhance the behaviour of exception dialog by own buttons.
       The behaviour is like this: If any of <code>Handler</code>s of
       <code>Logger.getLogger("")</code> implements <code>Callable&lt;JButton&gt;</code>
       then such button is going to be inserted to the exception dialog and
       can react and change the behaviour of that dialog. Such a button is
       going to be a "closing" one - e.g. the dialog will close as soon as
       the button is pressed.
   </api><api name="org.netbeans.core.TimeableEventQueue" type="export" category="private" group="systemproperty">
   This module contains a hook to identify long running tasks inside the AWT
   dispatch thread. It observers the AWT event queue and if a task takes longer
   than expected, it invokes a sampler that creates a profiling snapshot of the IDE
   until the task returns back to the event queue. Time limits can be
   configured via system properties (in milliseconds):
   <ul>
    <li><code>org.netbeans.core.TimeableEventQueue.quantum=xyz</code> - for how long the event queue must be blocked to start the self-sampler (by default 100ms),</li>
    <li><code>org.netbeans.core.TimeableEventQueue.report=xyz</code> - total time of blocked event queue to report a problem (by default 3s),</li>
    <li><code>org.netbeans.core.TimeableEventQueue.waitcursor=xyz</code> - time for which a problem is not reported if mouse wait cursor is in place (by default 15s),</li>
    <li><code>org.netbeans.core.TimeableEventQueue.pause=xyz</code> - time after reporting a problem for which the detection is disabled (by default 15s).</li>
   </ul>
   In production builds the default time limits are different (10s to start sampler, 20s to report a problem).
   </api><api name="Keymaps" type="export" category="devel" group="layer">
   Keymaps folder contains subfolders for individual keymaps (Emacs, JBuilder, NetBeans).
   The name of keymap can be localized. Use "SystemFileSystem.localizingBundle" attribute of your folder 
   for this purpose. Individual keymap folder contains shadows to actions. Shortcut is mapped to the name of file. 
   Emacs shortcut format is used, multikeys are separated by space chars ("C-X P" means Ctrl+X followed by P).
   "currentKeymap" property of "Keymaps" folder contains original (not localized) name of current keymap.
   </api><api name="Shortcuts" type="export" category="devel" group="layer">
   This folder contains registration of shortcuts. Its supported for backward compatibility purpose only.
   All new shortcuts should be registerred in "Keymaps/NetBeans" folder. Shortcuts installed ins Shortcuts folder 
   will be added to all keymaps, if there is no conflict. It means that if the same shortcut is mapped to different 
   actions in Shortcut folder and current keymap folder (like Keymap/NetBeans), the Shortcuts folder mapping 
   will be ignored.
   </api><api name="org.netbeans.core" type="export" category="friend" group="preferences">
          <table>
              <tbody>
                  <tr>
                      <th colspan="1" rowspan="1">key</th>
                      <th colspan="1" rowspan="1">description</th>
                      <th colspan="1" rowspan="1">read</th>
                      <th colspan="1" rowspan="1">write</th>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyHttpHost</td>
                      <td colspan="1" rowspan="1">Host name of HTTP Proxy</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyHttpPort</td>
                      <td colspan="1" rowspan="1">Port of HTTP Proxy</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyHttpsHost</td>
                      <td colspan="1" rowspan="1">Host name of HTTPS Proxy</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyHttpsPort</td>
                      <td colspan="1" rowspan="1">Port of HTTPS Proxy</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxySocksHost</td>
                      <td colspan="1" rowspan="1">Host name of Socks server</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxySocksPort</td>
                      <td colspan="1" rowspan="1">Port of Socks server</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyNonProxyHosts</td>
                      <td colspan="1" rowspan="1">Ignore host list</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyType</td>
                      <td colspan="1" rowspan="1">Type of Proxy Setting (DIRECT_CONNECTION, AUTO_DETECT_PROXY, MANUAL_SET_PROXY</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">useProxyAuthentication</td>
                      <td colspan="1" rowspan="1">Proxy Server requires user authentication</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyAuthenticationUsername</td>
                      <td colspan="1" rowspan="1">Username for authentication on Proxy Server</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
                  <tr>
                      <td colspan="1" rowspan="1">proxyAuthenticationUsername</td>
                      <td colspan="1" rowspan="1">Password for authentication on Proxy Server</td>
                      <td colspan="1" rowspan="1">Y</td>
                      <td colspan="1" rowspan="1">Y</td>
                  </tr>
              </tbody>
          </table>
      </api></module><module name="Core - IDE" target="org-netbeans-core-ide/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  <api-ref name="core.ide"/>
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="services-tab-node" name="Register Node in Services tab">
        Use <a href="org-netbeans-core-ide/org/netbeans/api/core/ide/ServicesTabNodeRegistration.html" shape="rect">
        ServicesTabNodeRegistration</a> to register your nodes into <em>Services</em> in the IDE.
   </usecase>
  </p>
 </arch-usecases><api name="core.ide" type="export" category="stable" group="java">
  Right now this module provides handy
  <a href="org-netbeans-core-ide/org/netbeans/api/core/ide/ServicesTabNodeRegistration.html" shape="rect">
    ServicesTabNodeRegistration</a>
    accompanied with few UI elements.
  </api></module><module name="Multi-tabs" target="org-netbeans-core-multitabs/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Allow easy customization of editor tabs.
  
 </description><deploy-dependencies>
  <p>
   No other dependencies.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
      <usecase id="tabdecorator" name="Tab Decorator">
          <p>To customize the rendering of (some) editor tabs one needs subclass
              <code>TabDecorator</code> class and register it in the global <code>Lookup</code>.</p>
              <p>The example below shows a decorator that removes file extension
              from Java source files to have shorter tabs to show more file names
              without the need for scrolling.</p>
              <pre xml:space="preserve">
ServiceProvider(service = TabDecorator.class, position = 1000)
public class MyTabDecorator extends TabDecorator {

    public String getText( TabData tab ) {
        String res = tab.getText();
        if( null != res )
            res = res.replace( ".java", "");
        return res;
    }
}
              </pre>
      </usecase>
      <usecase id="customdisplayer" name="Custom Tab Displayer">
          <p>If one needs a custom editor tab displayer for example to have special
          tab layout or special layout of scrolling buttons etc it is necessary
              to subclass <code>TabDisplayer</code> class and register an instance
              of <code>TabDisplayerFactory</code> in the global <code>Lookup</code>.
          </p>
          <pre xml:space="preserve">

public class MyTabDisplayer extends TabDisplayer {

    public MyTabDisplayer( TabDataModel model ) {
        super( model );
    }

    ServiceProvider(service = TabDisplayerFactory.class)
    public static class MyTabDisplayerFactory extends TabDisplayerFactory {
        public TabDisplayer createTabDisplayer( TabDataModel tabModel, int orientation ) {
            return new MyTabDisplayer( tabModel );
        }
    }

    //implement all abstract methods here
}
          </pre>
      </usecase>
  </p>
 </arch-usecases><api name="multitabs" type="export" category="devel" group="java"/></module><module name="MultiView Windows" target="org-netbeans-core-multiview/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Multi views are general mechanism for displaying several perspectives, or views of data,
which will be used consistently across whole IDE window system. Using multi views
will enable modules to visually represent data document or object in unified manner
at one specific place in the system, yet still allowing for different perspectives
of data viewing.
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
    There is an introduction to MultiView and its usage in its 
    <a href="org-netbeans-core-multiview/overview-summary.html" shape="rect">javadoc</a>. It covers the major part 
    of available usecases.
    Here is just
    a list of frequently asked or interesting questions slowly expanding as
    people ask them:
    <h3>MultiView faq:</h3>
    
    <usecase id="serialization" name="How does serialization work?">
<em><b>Q:</b>
How does serialization of multiviews work and what needs to be serializable?
</em>
<p>
First of all, you don't need to worry about serialization if all your <code>MultiViewDescription</code> instances
contained in the multiview state to be non serializable.
Meaning they all return <code>TopComponent.PERSISTENCE_NEVER</code> in <code>MultiViewDescription.getPersistenceType()</code>.
</p>
<p>
If at least one of the views requires serialization, you have no choice but to make all
<code>MultiViewDescription</code> implementors serializable. 
You also can persist the MultiViewElement instances that the multiview contains. The algorithm here is a bit complicated for
performance reasons. Only those Elements are stored that were created during the session and which are Serializable.
So if the user never switches to the 4rd tab, and it's corresponding element and visual component never get created, then
it won't be stored. (We would have to create it just for the sake of persistance).
So if your visual component needs some inital context for creation, you should store it in the description instance, and if the visual component
wants to store it's state (location of cursor, selected field, something else that makes sense for the opened component) you should store it in the MultiViewElement.
So basically if you are always able create the Element from Description without any persisted data, you don't need to persist anything.
</p>
<p>
If you define your own <code>CloseOperationHandler</code> implementation for the multiview component, then you also ought to define it
Serializable. Otherwise it will be silently replaced by the default handler on restoration of the multiview component.
</p>
</usecase>

    <usecase id="displayName" name="How to set the display name?">
<em><b>Q:</b>
 How do I set the display name for the multiview component?
</em>
<p>
Each <code>MultiViewDescription</code> defines display name and icon. While the icon 
is meant for the whole document/view tab, the display name is just for the inner switching button.
So how does one set the name for the whole MultiView component? It can be done when creating the component.
</p>
<pre xml:space="preserve">
    TopComponent mvtc = MultiViewFactory.createMultiView(myDescriptions);
    mvtc.setDisplayName("My static mvtc displayName");
</pre>
<p>
Later in the lifecycle of the component, it can be also influenced from within the individual
multiview visual elements using the <code>MultiViewElementCallback.updateTitle()</code> method.
</p>
</usecase>
</arch-usecases><api name="MultiView" type="export" category="stable" url="org-netbeans-core-multiview/overview-summary.html" group="java">
                 Provides support for creation of editors composed from
                 multiple (independent) elements. One can either specify
                 the <a href="org-netbeans-core-multiview/org/netbeans/core/spi/multiview/MultiViewFactory.html" shape="rect">
                 elements directly</a> 
                 or read them from a 
                 <a href="org-netbeans-core-multiview/org/netbeans/core/api/multiview/MultiViews.html" shape="rect">
                 declarative registration</a> for a particular mime type.
        </api><api name="multiview.toolbarVisible" type="export" category="devel" group="preferences">
    <p>
    The visibility of 
    <a href="org-netbeans-core-multiview/org/netbeans/core/spi/multiview/MultiViewElement.html#getToolbarRepresentation--" shape="rect">toolbar</a>
    is controlled by a preference shared with editor module.
    The multiview implementation listens and uses following property:
    </p>
    <pre xml:space="preserve">
    MimeLookup.getLookup(MimePath.EMPTY).lookup(Preferences.class).getBoolean("toolbarVisible", true);    
    </pre>
    <p>
    to find out whether all toolbars in all multiviews should be visible or not. Also,
    since 1.25, the toolbar is hidden completely. There is a tab switching action
    in multi view component popup menu to compensate this.
    </p>
</api><api name="MultiViewElement.Spliting.Enabled" type="export" category="devel" group="branding">
	    By default a MultiViewElement allows the containing TopComponent to split it.
	    Some systems may however find this not of any use. Then they should brand the
	    <code>MultiViewElement.Spliting.Enabled</code> to <code>false</code>. NetBeans IDE
	    by default does allow spliting.
	</api></module><module name="NetBeans OSGi Integration" target="org-netbeans-core-netigso/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="archive" name="Share NetBeans Resource Cache">The only supported usecase right now is to
   allow any framework to obtain access to internal cache and load classes
   from it. See <a href="org-netbeans-core-netigso/org/netbeans/core/netigso/spi/NetigsoArchive.html" shape="rect">NetigsoArchive</a>.
   </usecase>
  </p>
 </arch-usecases><api name="Netigso" type="export" category="devel" group="java">
  the heart of NetBeans integration with
  OSGi with NetBeans module
  system is contained in this module. This module locates the OSGi framework
  implmentation and is then responsible for finding,
  registering and starting OSGi bundles provided by the NetBeans module system.</api><api name="netigso.archive" type="export" category="devel" group="property">
   Inside of your <code>FrameworkFactory</code> you can use
   <code>map.get("netigso.archive")</code> to get instance of
   <a href="org-netbeans-core-netigso/org/netbeans/core/netigso/spi/NetigsoArchive.html" shape="rect">NetigsoArchive</a>.
   </api><api name="netigso-bundles" type="export" category="friend" group="java.io.File">
       <p>
       List of registered OSGi bundles as well as mapping of their packages
       to individual bundles is stored in <code>var/cache/netigso-bundles</code>.
       This file works in orchestration with content of <code>var/cache/netigso</code>
       directory where the OSGi framework usually stores its own information
       about bundles.
       </p>
       <p>
       The content of the cache file is <em>private</em>, but the location 
       is well known (including its relation with <code>netigso</code> directory),
       so <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-bootstrap/architecture-summary.html#java.io.File-installation.cache" shape="rect">
       the installer</a> can store necessary data and speed first start of
       the application up.
       </p>
   </api><api name="Netigso-Export-Package" type="export" category="stable" group="property">
   If a NetBeans module's manifest contains tag <code>Netigso-Export-Package</code>,
   then it is used as a value of <code>Export-Package</code> OSGi tag, when
   re-exporting the module as OSGi bundle.
   </api><api name="org.netbeans.core.netigso.FRAMEWORK_START_LEVEL" type="export" category="devel" group="branding">
   One can influence the initial OSGi framework start level by rebranding
   the <code>FRAMEWORK_START_LEVEL</code> key in <code>org/netbeans/core/netigso/Bundle.properties</code>.
   By default the key is empty, which means no change to default OSGi start level of <code>1</code>.
   </api><api name="org.netbeans.core.netigso.MODULE_START_LEVEL" type="export" category="devel" group="branding">
   The meaning of enabled module (a NetBeans terminology) and started bundle
   (an OSGi terminology) is not the same. Although in general we recommend
   to start all bundles that are marked as enabled, you may want to configure
   this. To do so, you can use various start levels
   and re-brand <code>MODULE_START_LEVEL</code> key in 
   <code>org/netbeans/core/netigso/Bundle.properties</code> to specify the
   start level of modules that are supposed to be started.
   Only modules with lower or equal start level than value of this 
   key will be started.
   </api><api name="org.netbeans.core.netigso.DEFAULT_BUNDLE_START_LEVEL" type="export" category="devel" group="branding">
   Bundles that don't provide own start level (via config/Modules/*.xml files),
   get no start level by default in the NetBeans Platform, 
   however that can be changed by branding the <code>DEFAULT_BUNDLE_START_LEVEL</code> key in 
   <code>org/netbeans/core/netigso/Bundle.properties</code>. NetBeans IDE 
   brands it to 4.
   </api><api name="org.netbeans.core.netigso.FIND_COVERED_PKGS" type="export" category="devel" group="branding">
   The <b>FIND_COVERED_PKGS</b> branding key defines method to find list of covered packages
   for an OSGi bundle. Currently it can be empty or <b>findEntries</b>, which
   means Netigso will use <code>bundle.findEntries("", null, true)</code>. As that method
   resolves the bundle, it may not always be appropriate. In such case brand
   this token to empty string and only "Export-Package" values will be used.
   Since version 1.23 there is also a chance to set the token to <b>exportedIfPresent</b>
   which will use the value of "Export-Package" tag when it is present, but
   when there is none, <code>bundle.findEntries("", null, true)</code> will be 
   used.
   </api><api name="felix_org.osgi.framework" type="export" category="devel" group="systemproperty">
       <code>System.getProperties()</code> that start with prefix <code>felix.</code>
       or <code>org.osgi.framework.</code> are read on initialization of the
       Netigso system and injected into configuration of OSGi container 
       before it starts.
   </api></module><module name="Core Network" target="org-netbeans-core-network/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      The Core Network module provide ProxySelector as well as utilities related
      to network connections.
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
      <usecase id="custom-proxyselector" name="Custom ProxySelector">
          You can provide your own ProxySelector instead of the one
          provided by this module. You do this by registering your 
          own {@link java.net.ProxySelector}
          in the Global Lookup. However, make sure you understand that
          the instantiation of the ProxySelector (i.e. executing its constructor)
          is part of the main startup path of a NetBeans application. For this
          reason the constructor better be fast. Defer as much work as possible to 
          later.
            <api category="standard" group="java" name="java.net.ProxySelector" type="import" url="http://download.oracle.com/javase/8/docs/api/java/net/ProxySelector.html"/>
      </usecase>
      <usecase id="custom-pac-evaluator" name="Custom PAC Evaluator">
          You can plug in your own PAC evaluator if you are unhappy with
          the {@link org.netbeans.core.network.proxy.pac.impl.NbPacScriptEvaluator  default one} 
          provided in this module. You do this by registering your 
          own {@link org.netbeans.core.network.proxy.pac.PacScriptEvaluatorFactory}
          in the Global Lookup. This factory must then in turn return an 
          instance of your custom {@link org.netbeans.core.network.proxy.pac.PacScriptEvaluator}.
            <api category="friend" group="java" name="org.netbeans.core.network.proxy.pac.PacScriptEvaluatorFactory" type="export" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacScriptEvaluatorFactory.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.proxy.pac.PacScriptEvaluator" type="export" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacScriptEvaluator.html"/>
      </usecase>
      <usecase id="custom-pac-evaluator-helpers" name="Customizing the default PAC Evaluator">
          Instead of replacing all of the {@link org.netbeans.core.network.proxy.pac.impl.NbPacScriptEvaluator  default PAC evaluator}
          you can replace only its implementation of the <i>PAC Helper Functions</i>.
          However, you have to play by rules set by the {@link org.netbeans.core.network.proxy.pac.impl.NbPacScriptEvaluator  default PacScriptEvaluator},
          namely that all the Helper Functions are implemented in Java (as opposed to JavaScript).
          Simply register your sub-class of {@link org.netbeans.core.network.proxy.pac.PacHelperMethods}
          in the Global Lookup and your implementation will automatically be picked
          up. When creating your own <code>PacHelperMethods</code> you may
          take benefit from the PAC utility functions provided by {@link org.netbeans.core.network.proxy.pac.PacUtils}
          and {@link org.netbeans.core.network.proxy.pac.datetime.PacUtilsDateTime},
          as well as the more general ones provided by {@link org.netbeans.core.network.utils network utils package}.
            <api category="friend" group="java" name="org.netbeans.core.network.proxy.pac.PacHelperMethods" type="export" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacHelperMethods.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.utils.HostnameUtils" type="export" url="org-netbeans-core-network/org/netbeans/core/network/utils/HostnameUtils.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.utils.IpAddressUtils" type="export" url="org-netbeans-core-network/org/netbeans/core/network/utils/IpAddressUtils.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.utils.LocalAddressUtils" type="export" url="org-netbeans-core-network/org/netbeans/core/network/utils/LocalAddressUtils.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.utils.SimpleObjCache" type="export" url="org-netbeans-core-network/org/netbeans/core/network/utils/SimpleObjCache.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.proxy.pac.PacUtils" type="export" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacUtils.html"/>
            <api category="friend" group="java" name="org.netbeans.core.network.proxy.pac.datetime.PacUtilsDateTime" type="export" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/datetime/PacUtilsDateTime.html"/>
      </usecase>
  </p>

 </arch-usecases><api name="org.netbeans.core.network.proxy.pac.PacScriptEvaluatorFactory" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacScriptEvaluatorFactory.html" group="java"/><api name="org.netbeans.core.network.proxy.pac.PacScriptEvaluator" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacScriptEvaluator.html" group="java"/><api name="org.netbeans.core.network.proxy.pac.PacHelperMethods" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacHelperMethods.html" group="java"/><api name="org.netbeans.core.network.utils.HostnameUtils" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/utils/HostnameUtils.html" group="java"/><api name="org.netbeans.core.network.utils.IpAddressUtils" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/utils/IpAddressUtils.html" group="java"/><api name="org.netbeans.core.network.utils.LocalAddressUtils" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/utils/LocalAddressUtils.html" group="java"/><api name="org.netbeans.core.network.utils.SimpleObjCache" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/utils/SimpleObjCache.html" group="java"/><api name="org.netbeans.core.network.proxy.pac.PacUtils" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/PacUtils.html" group="java"/><api name="org.netbeans.core.network.proxy.pac.datetime.PacUtilsDateTime" type="export" category="friend" url="org-netbeans-core-network/org/netbeans/core/network/proxy/pac/datetime/PacUtilsDateTime.html" group="java"/></module><module name="Startup" target="org-netbeans-core-startup/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="org.netbeans.log.startup" type="export" category="friend" group="systemproperty">
          <p>
          If started with <code>-J-Dorg.netbeans.log.startup=print</code> parameter, then
          times of various start operations are printed to console. If the value is
          <code>-J-Dorg.netbeans.log.startup=file</code> then the values are printed into
          file specified by <code>-J-Dorg.netbeans.log.startup.logfile=filename</code>.
          Since NetBeans 7.1 one can also fill in the file by standard XML format
          of log messages by using <code>-J-Dorg.netbeans.log.startup=xml</code>.
          </p>
          
          <p>
          Moreover if any module logs data to <code>Logger.getLogger("org.netbeans.log.startup")</code>
          with calls like <code>log(Level.FINE, "start", "msg")</code> and
          <code>log(Level.FINE, "end", "msg")</code> or
          <code>log(Level.FINE, "progress", "msg")</code>, then these messages
          are collected into the start log as well.
          </p>
      </api><api name="netbeans.logger.noSystem" type="export" category="friend" group="systemproperty">
          Allows unit tests to prevent changes to <code>System.err</code> and
          <code>System.out</code> by the logging infrastructure.
      </api><api name="org.netbeans.log.numberOfFiles" type="export" category="friend" group="systemproperty">
          Changes the number of files used for log rotation. If started with
          <code>-J-Dorg.netbeans.log.numberOfFiles=number</code> then the log files for
          <code>number-1</code> previous executions will be preserved. Default and
          minimum number is 3.
      </api><api name="org.netbeans.core.startup.ModuleList.firstModuleJarWins" type="export" category="friend" group="systemproperty">
          Disables #113341 so that the first version of a module JAR to be encountered is loaded,
          even if a later cluster contains a newer version of the same module.
      </api><api name="org.netbeans.core.systemfilesystem.custom" type="export" category="devel" group="systemproperty">
          <p>
          This property can contain name of a class implementing 
          <a href="http://netbeans.apache.org/javadoc/dev/org-openide-filesystems/org/openide/filesystems/FileSystem.html" shape="rect">FileSystem</a>
          with a public default constructor. Such filesystem is then used during
          initialization of writable layer of system file system (see 
          <a href="http://netbeans.apache.org/javadoc/dev/org-openide-filesystems/org/openide/filesystems/FileUtil.html#getConfigRoot--" shape="rect">getConfigRoot</a>).
          The filesystem may use or may ignore value of 
          <code>System.getProperty("netbeans.user")</code>.
          </p>
          <p>
          <em>Note:</em> The class is loaded sooner then modules are initialized,
          as such the class providing it must be from a JAR file placed in
          to <code>$cluster/core/</code> directory. Such JAR may have just a
          limited dependencies - e.g. only module system and filesystem API.
          </p>
      </api><api name="netbeans.bootdelegation" type="export" category="devel" group="systemproperty">
          <p>
          Similar to OSGi's <code>org.osgi.framework.bootdelegation</code> property.
          Allows unit tests (or even regular code) to prevent classloading from
          application classloader for other, then explicitly enumerated packages.
          </p>
          <p>
          This property shall contain a set of comma separated values of 
          package names. Classes from those packages will be loaded by the 
          classloader framework from application classloader. If the name of
          a package ends with <code>.*</code> suffix, all packages under the
          given package name are allowed for delegation (but not the package by itself).
          </p>
          <p>
          The classes from the <code>java.*</code> namespace are allowed
          and do not need to be enumerated at all. If this property is not
          specified at all, all classes visible by the application classloader
          can be accessed. Available since version 1.26.
          </p>
      </api><api name="netbeans.productversion" type="export" category="devel" group="systemproperty">
          <p>
          This property includes the display name presented to the user as Product Version
          in the About dialog box and in the log file.
          </p>
      </api><api name="org.netbeans.core.update.all.resources" type="export" category="devel" group="systemproperty">
          <p>
          Some applications built on top of NetBeans Platform expressed
          an option that certain files in caches, namely 
          <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-bootstrap/architecture-summary.html#java.io.File-all-resources.dat" shape="rect">
          all-resources.dat</a>
          can be too big and that this is not good for multi-user installation.
          To give such applications control over creation of this file, there
          is a property to (conditionally) disable the creation of the cache file.
          </p>
          <p>
          Change value of <code>org.netbeans.core.update.all.resources</code> property
          in launcher configuration file or provide it as a virtual machine
          parameter on command line.
          Set it to <code>never</code>, <code>always</code> or <code>missing</code>.
          The default is to regenerate and update the cache <em>always</em>. 
          Value <em>missing</em> means to generate
          the cache only if it has not been previously available (even in 
          installation location). Setting the value to <em>never</em> will
          disable the creation of the cache after start completely.
          </p>
          <p>
          Changing default value of the property may be particulary useful when there is a shared
          installation of the application, there are many users with a home
          (and cache) directory on a slow (network) file system and it is 
          expected most of them won't install additional modules into their
          own user directory.
          </p>
      </api></module><module name="UI Handler Library" target="org-netbeans-lib-uihandler/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="UIGestureCollectorLibrary" type="export" category="devel" group="java">
          Library with utilities for UI Gesture Collector module as well as 
          for the server processing the results.
      </api></module><module name="V8 Debugging Protocol Library" target="org-netbeans-lib-v8debug/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
   This library is a Java implementation of V8 debugging protocol.
   Provides <api-ref name="v8debugLib"/>
 </description><deploy-dependencies>
   This module does not have any additional dependencies.
 </deploy-dependencies><arch-usecases>
     <h2>Client Usage</h2>
     Use <code>org.netbeans.lib.v8debug.connection.ClientConnection</code> class
     to create a client debugger connection. The library does not contain any threads,
     call <code>ClientConnection.runEventLoop()</code> in an application thread
     to execute the event loop that distributes the debugger events via
     <code>ClientConnection.Listener</code> listener. Use <code>ClientConnection.send()</code>
     to send any debugger requests.
     
     <h2>Server Usage</h2>
     Use <code>org.netbeans.lib.v8debug.connection.ServerConnection</code> class
     to create a server debugger. The library does not contain any threads,
     call <code>ServerConnection.runConnectionLoop()</code> in an application thread
     to accept a client connection and receive debugging requests via
     <code>ServerConnection.Listener</code> listener. Use <code>ServerConnection.send()</code>
     to send any debugger event.
     
 </arch-usecases><api name="v8debugLib" type="export" category="devel" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-lib-v8debug/overview-summary.html" group="java"/></module><module name="Git Library API" target="org-netbeans-libs-git/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      The library provides a Java implementation of git client allowing you to work with and get information about Git repositories and run Git commands.
  
 </description><deploy-dependencies>
  <p>
   No additional setting is needed, direct dependency is enough.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="1" name="Get Git client">
   Before you can run preferred Git commands, you must get an instance of <a href="org-netbeans-libs-git/org/netbeans/libs/git/GitClient.html" shape="rect">GitClient</a> bound to a specific repository.<br/>
   Instances of <code>GitClient</code> are provided by <a href="org-netbeans-libs-git/org/netbeans/libs/git/GitRepository.html#createClient--" shape="rect">GitRepository</a>.
   <code>GitRepository</code> represents a concrete local Git repository and is always bound to a specific folder.
   <p/>
   The correct way to achieve this is to call <code><a href="org-netbeans-libs-git/org/netbeans/libs/git/GitRepository.html" shape="rect">GitRepository</a>.getInstance(repositoryRoot).createClient()</code>.
  </usecase>
  <usecase id="2" name="Run Git commands">
   To run a Git command simply call a method mapped to the command on an instance of GitClient.
  </usecase>
  <usecase id="3" name="Control Git command's workflow">
   You are able to control a Git command's work and listen for warning and error messages and informative messages indicating start and finish of the command via
   <a href="org-netbeans-libs-git/org/netbeans/libs/git/progress/ProgressMonitor.html" shape="rect">ProgressMonitor</a>. Every method of <code>GitClient</code> mapped to a Git command accepts an instance of
   <code>ProgressMonitor</code> as a parameter. Through an instance of this class you can cancel a command, an implementation of such a command periodically calls
   <a href="org-netbeans-libs-git/org/netbeans/libs/git/progress/ProgressMonitor.html#isCanceled--" shape="rect">isCanceled</a> and interrupts its work if the method returns <code>true</code>.<br/>
   Its basic implementation at <a href="org-netbeans-libs-git/org/netbeans/libs/git/progress/ProgressMonitor.DefaultProgressMonitor.html" shape="rect">ProgressMonitor.DefaultProgressMonitor</a> supports canceling commands
   while implementing other methods as no-op.
  </usecase>
  <usecase id="4" name="Recieve notifications">
   Some Git commands may take a noticeable amount of time to finish and waiting that long for the full result returned by the command may not be sufficient. Git API provides a way
   to follow the process of building the result of such commands.<br/>
   Let's say you want to get all revisions from the Git history. The log command is expensive especially on large repositories and you do not want to wait for it to finish but want to
   be notified when a single revision from the history is fetched and added to the result. This way you can <em>incrementally</em> present the result in the UI without the need for 
   waiting indefinitely for the command to finish.
   <p>
   Package <a href="org-netbeans-libs-git/org/netbeans/libs/git/progress/package-summary.html" shape="rect">org.netbeans.libs.git.progress</a> offers
   a set of listeners extending the <a href="org-netbeans-libs-git/org/netbeans/libs/git/progress/NotificationListener.html" shape="rect">NotificationListener</a> interface which you can attach to an instance of
   <code>GitClient</code> via <a href="org-netbeans-libs-git/org/netbeans/libs/git/GitClient.html#addNotificationListener-org.netbeans.libs.git.progress.NotificationListener-" shape="rect">addNotificationListener()</a>
   and through which you can closely monitor building of the result.
   </p>
  </usecase>
 </arch-usecases><api name="GitlibraryAPI" type="export" category="devel" group="java">
      Allows clients to work with local Git repositories and invoke a set of Git commands affecting a Git repository.
    </api></module><module name="Auto Update Services" target="org-netbeans-modules-autoupdate-services/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        <api-ref name="org.netbeans.api.autoupdate"/>
        <api-ref name="org.netbeans.spi.autoupdate"/>
    </description><deploy-dependencies>
        <defaultanswer generate="here"/>
    </deploy-dependencies><arch-usecases>
        <p>
            <usecase id="browse" name="Browse all available units">
                Give overview of IDE installation to users, it involve overview of installed modules (grouped together as feature), 
                overview of available updates, overview of available new features.
                The API can return list of <code>UpdateUnit</code> which describes all instances of unit, e.g. installation in IDE,
                all its available updates, optionlly its backup instance.
                <code>UpdateUnit</code> can represent either a feature (e.g. group
                of modules), a single module or a localization.
                <p/>
                <i>Proposed usage of API:</i> Call <code>List&lt;UpdateUnit&gt; UpdateManager.getDefault().getUpdateUnits()</code>
                <!-- JST:UpdateManager cannot be singleton because it has mutable 
                  state with apply method. Imho, there should be UpdateManager.create(...).
                  The arguments could handle various requirements, like
                  create(FEATURE_LEVEL) or create(DETAILED_LEVEL), etc.
                  -->
            </usecase>
            <usecase id="browse-by-style" name="Browse all units by chosen style (e.g. modules, features, localization)">
                Sometimes there can be a need to get overview of units 
                by chosen style, e.g. feature, module or localization.
                <p/>
                <i>Proposed usage of API:</i> Call <code>List&lt;UpdateUnit&gt; UpdateManager.getDefault().getUpdateUnits(UpdateStyle style)</code>
            </usecase>
            <usecase id="browse-installed" name="Browse installed modules">
                When an API client needs to get overview of installed modules.
                <p/>
                <i>Proposed usage of API:</i> Call <code>List&lt;UpdateUnit&gt; UpdateManager.getDefault().getUpdateUnits(UpdateStyle style)</code>
                and filter units which haven't been installed yet.
                <!-- JST: The comment by Tonda was that this may be too slow.
                  This may turn true, then I suggest to have another argument
                  to the UpdateManager.create(...) method - "correctness":
                    - LOCAL - only return what is available locally
                    - PREFER_CACHES - if caches exists read from them, but 
                       if not, go and connect to the websites
                    - EXACT - always try to get the most up-to-date info available,
                       e.g. do not use caches, connect to the web site
                 -->
            </usecase>
            <usecase id="search-by-attribute" name="Search for new functionality">
                Someone is searching for some functionality which can be 
                installed into IDE. It needs a set of available <code>UpdateUnit</code>s
                which are applicable to active IDE. <code>UpdateManager</code> will 
                search all available <code>UpdateUnit</code> given attribute.
            </usecase>
            <a name="install-new-functionality" shape="rect"/>
            <usecase id="install-new-functionality" name="Install new functionality">
                An client needs to install new functionality into the IDE installation. 
                She knows what unit and what version wants to install.
                Needs to identify if the functionality is ready to install, 
                resolve its dependencies, identify possible problems and locate
                other unit what have to be installed together with asked functionality.
                <p/>
                <i>Proposed usage of API:</i>
                <ul>
                    <li>Client needs install NetBeans module in required minimal specification version.</li>
                    <li>Find corresnponing <code>UpdateUnit</code> by module's code name and finds <code>UpdateElement</code> what fits the required version.</li>
                    <li>So, the client now have <code>UpdateElement</code> which wants to install.</li>
                    <li>Take the <code>OperationContainer</code> for install, e.g. <code>OperationContainer.createForInstall</code></li>
                    <li>Adds the element into container <code>OperationContainer.add(UpdateElement)</code> and gets <code>OperationInfo</code> for that operation.</li>
                    <li>Identify other required elements: <code>OperationInfo.getRequiredElements()</code></li>
                    <li>Check if there is no broken dependencies: <code>OperationInfo.getBrokenDependency()</code> Note: if there are some broken dependencies then operation cannot continue.</li>
                    <li>If all okay, then install the unit: <code>OperationContainer.doOperation()</code></li>
                </ul>
            </usecase>
            <usecase id="update-installed" name="Update of installed unit">
                A client needs to update some unit of functionality which is 
                already installed. She knows what unit and what update element (by version) wants to install.
                Needs to identify possible problems with update install, resolve its dependencies, identify possible problems and locate
                other unit what have to be installed together with asked functionality.
                <p/>
                <i>Proposed usage of API:</i> See above <a href="#install-new-functionality" shape="rect">Install new functionality</a>
            </usecase>
            <usecase id="uninstall-unit" name="Uninstall functionality">
                An client needs to uninstall some functionality from IDE installation. She knows what unit wants to uninstall.
                Needs to identify if the functionality is ready to uninstall, resolve its dependencies, identify possible problems and locate
                other unit what will be disabled together.
                <p/>
                <i>Proposed usage of API:</i>
                <ul>
                    <li>Client knows <code>UpdateElement</code> which wants to uninstall.</li>
                    <li>Take the <code>OperationContainer</code> for uninstall, e.g. <code>OperationContainer.createForUninstall</code></li>
                    <li>Adds the element into container <code>OperationContainer.add(UpdateElement)</code> and gets <code>OperationInfo</code> for that operation.</li>
                    <li>Identify other required elements: <code>OperationInfo.getRequiredElements()</code></li>
                    <li>If all okay, then uninstall the unit: <code>OperationContainer.doOperation()</code></li>
                </ul>
            </usecase>
            <a name="disable-unit" shape="rect"/>
            <usecase id="disable-unit" name="Switch off functionality">
                An client needs to switch off (disable) some functionality in IDE installation. Needs to resolve its dependencies,
                identify possible problems and locate other unit what will be disabled together.
                <p/>
                <i>Proposed usage of API:</i>
                <ul>
                    <li>Client knows <code>UpdateElement</code> which wants to uninstall.</li>
                    <li>Take the <code>OperationContainer</code> for disable, e.g. <code>OperationContainer.createForDisable</code></li>
                    <li>Adds the element into container <code>OperationContainer.add(UpdateElement)</code> and gets <code>OperationInfo</code> for that operation.</li>
                    <li>Identify other required elements: <code>OperationInfo.getRequiredElements()</code></li>
                    <li>If all okay, then disable the unit: <code>OperationContainer.doOperation()</code></li>
                </ul>
            </usecase>
            <usecase id="enable-unit" name="Switch on functionality">
                Like <a href="#disable-unit" shape="rect">Switch off functionality</a> An client needs to switch on (enable) some functionality in IDE installation.
            </usecase>
            <usecase id="rollback-of-update" name="Rollback of previous update">
                Sometimes an client needs to rollback of installed update of unit to previous version.
                Needs to resolve its dependencies, identify possible problems and locate
                other unit what are affected by rollback.
                <p/>
                <i>Proposed usage of API:</i> Like above  <a href="#disable-unit" shape="rect">Switch off functionality</a>
                <ul>
                    <li>Client knows <code>UpdateElement</code> which wants to uninstall.</li>
                    <li>Take the <code>OperationContainer</code> for enable, e.g. <code>OperationContainer.createForEnable</code></li>
                    <li>Adds the element into container <code>OperationContainer.add(UpdateElement)</code> and gets <code>OperationInfo</code> for that operation.</li>
                    <li>Identify other required elements: <code>OperationInfo.getRequiredElements()</code></li>
                    <li>If all okay, then enable the unit: <code>OperationContainer.doOperation()</code></li>
                </ul>
            </usecase>
            <usecase id="resolve-problems" name="Resolve problems what accrued while processing operation">
                <code>OperationContainer</code> and <code>OperationInfo</code> identifies some problems,
                i.e. broken dependencies, needs to install more units, the operation causes disable some
                other modules and so on. The client can use this information to consult these with end-user.
            </usecase>
            <usecase id="make-ide-up-to-date" name="Make IDE up-to-date">
                Sometimes need to make whole IDE installation up-to-date. Find all available updates of installed units and install the latest available version.
                It is covered by previous use-cases.
            </usecase>
            <usecase id="browse-update-providers" name="Get all subscriptions to Update Center">
                Show me all registered subscriptions to Update Center, e.g. get me list of <code>UpdateUnitProvider</code>.
                <i>Proposed usage of API:</i> Call <code>UpdateUnitProviderFactory.getUpdateUnitProviders()</code>
            </usecase>
            <usecase id="add-update-provider" name="Subscribe new Update Center">
                If there is a new Update Center which is not already subscribed into IDE user wants to subscribe new one Update
                Center which will be connected from that time in periodically checks.
                There should be a factory where subscribe new one Update Center, known types of Update Center have own factory method.
                <i>Proposed usage of API:</i> Simply call <code>UpdateUnitProviderFactory.create()</code> which creates and registered
                new one subscription in the system and will be used from that time in the future.
            </usecase>
            <usecase id="custom-update-provider" name="Customization of Update Center subscription">
                An user wants to enable or disable of Update Center subscription.
                <i>Proposed usage of API:</i> Simply call <code>UpdateUnitProviderFactory.setEnable(UpdateUnitProvider, boolean)</code>.
            </usecase>
            <usecase id="remove-update-provider" name="Unsubscribe of some Update Center">
                Simple unsubscribe a chosen Update Center from the system. Need to know of chosen Update Provider Id.
                This Update Center won't be checked anymore.
                <i>Proposed usage of API:</i> Simply call <code>UpdateUnitProviderFactory.remove(Id)</code>.
            </usecase>
            <usecase id="refresh-content" name="Refresh content of subscribed Update Center">
                The content of Update Provider is cached and the system works across there caches. There is a cache per each
                Update Center subscription. The caches are refreshed periodically by the system. But, sometime an user wants to 
                call refresh manually.
                <i>Proposed usage of API:</i> Simply call <code>UpdateUnitProvider.refresh()</code>.
            </usecase>
            <usecase id="specify-target-cluster" name="Specify the cluster where to install">TBD</usecase>
            <usecase id="get-installed-files" name="Get all installed files of given unit">TBD</usecase>
        </p>
    </arch-usecases><api name="org.netbeans.api.autoupdate" type="export" category="official" url="org-netbeans-modules-autoupdate-services/overview-summary.html" group="java"/><api name="org.netbeans.spi.autoupdate" type="export" category="official" url="org-netbeans-modules-autoupdate-services/overview-summary.html" group="java"/><api name="catalog-dtd" type="export" category="stable" url="org-netbeans-modules-autoupdate-services/org/netbeans/spi/autoupdate/doc-files/autoupdate-catalog-2_4.dtd" group="dtd"/><api name="info-dtd" type="export" category="stable" url="org-netbeans-modules-autoupdate-services/org/netbeans/spi/autoupdate/doc-files/autoupdate-info-2_4.dtd" group="dtd"/><api name="unique-id" type="export" category="stable" group="preferences"/><api name="enable-update-provider" type="export" category="private" group="preferences"/><api name="last-check-of-provider" type="export" category="private" group="preferences"/><api name="InitialTab" type="export" category="friend" group="property">
            <p>
            The associated module autoupdate.ui provides possibility to open plugin manager dialog (<code>PluginManagerUI</code>) with the specified tab.
            That is controlled by setting this string property to one of the following values:
            </p>
            <ul>
                <li>update</li>
                <li>available</li>
                <li>local</li>
                <li>installed</li>
            </ul>
            <p>
            If property is not set (as default) then default tab is choosen due to the UI spec.
            </p>
            <i>Proposed usage of API:</i>
            <pre xml:space="preserve">
final FileObject fo = FileUtil.getConfigFile("Actions/System/org-netbeans-modules-autoupdate-ui-actions-PluginManagerAction.instance");
CallableSystemAction action = (CallableSystemAction) DataObject.find(fo).getCookie(InstanceCookie.class).instanceCreate();
action.putValue("InitialTab", "installed");
action.performAction();
            </pre>            
        </api><api name="Show-In-AutoUpdate-Client" type="export" category="stable" group="property">
            Each module can control whether it shall be visible in a UI 
            that presents updates, installed modules, etc. This can be done
            by defining <code>OpenIDE-Module-Show-In-AutoUpdate-Client: false</code>
            (or <code>true</code>) in its own 
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#how-manifest" shape="rect">manifest</a>. 
            This attribute shall take precedence over 
            any default deduced by the UI (e.g. don't show 
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#enablement" shape="rect">autoload modules</a>
            for example).
        </api><api name="plugin.manager.detail.view.selected" type="export" category="private" group="systemproperty">
            <p>
                Setting this property affects the associated module autoupdate.ui.
                Setting it to <code>true</code> results in the detailed view (all visible plugins) been selected
                when Installed tab is opened in Plugin Manager.
                Otherwise the simple view (high-level features) is selected.
            </p>
        </api></module><module name="Auto Update UI" target="org-netbeans-modules-autoupdate-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   <api-ref name="AutoUpdateUI"/>
  
 </description><deploy-dependencies>
  <p>
   You modules can use the <code>AutoUpdateUI</code> API directly (of course
   you almost certainly need also <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-autoupdate-services/architecture-summary.html" shape="rect">
   Autoudate Services</a>), just be aware that this module comes with a UI.
   It is not always practical to depend on modules that provide a UI from 
   low level infrastructure modules - if that is your case, consider separating
   calls to <code>AutoUpdateUI</code> into separate 
   <a href="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#enablement" shape="rect">bridge module</a>.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="PluginManager.openInstallWizard" name="Download and Install">
  Primary purpose of the API is to share classical UI for downloading and
  installing additional modules. Read about 
  <a href="org-netbeans-modules-autoupdate-ui/org/netbeans/modules/autoupdate/ui/api/PluginManager.html" shape="rect">PluginManager.openInstallWizard</a>.
  </usecase>
 </arch-usecases><api name="AutoUpdateUI" type="export" category="stable" group="java">
       this module exposes bits of its UI and user related workflow actions
       (related to installing, upgrading, etc.) by providing an API calls
       for other modules to invoke bits of here-in available functionality.
   </api><api name="org.netbeans.modules.autoupdate.ui.actions.PluginManagerAction.initialTab" type="export" category="devel" group="property">
   There is an action registered with
   <code>@ActionID(id = "org.netbeans.modules.autoupdate.ui.actions.PluginManagerAction", category = "System")</code>
   that opens the plugin manager dialog and reacts to a special event:
   <code>new ActionEvent(this, 100, nameOfTabToOpen)</code>. The tab names
   include <code>{ "update", "available", "local", "installed" }</code>.
   </api></module><module name="Issue Tracking" target="org-netbeans-modules-bugtracking/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The module allows to integrate Bugtracking systems into the IDE workflow. 
  
 </description><deploy-dependencies>
  <p>
   No special requirements here.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
      The main Bugtracking SPI and API Use Cases are based on:<br/>
      - the <a href="http://xdesign-tools.cz.oracle.com/projects/netbeans/IssueTracking/" shape="rect">Bugtracking UI spec.</a><br/>      
      - the <a href="http://wiki.netbeans.org/TaskManagementUseCases" shape="rect">Issue Management Use Cases</a>. 
      For additional information see also <a href="http://wiki.netbeans.org/TaskDashboardDesignSpec" shape="rect">Tasks Dashboard UI spec</a><br/>
  </p>    
      
    <usecase id="1" name="Registration and setup">
        The Bugtracking SPI provides a way to register bugtracking plugins and 
        to setup remote Repository configurations of one kind.
    </usecase>
    
    <usecase id="2" name="Accessing Issues">
        All registered plugins provide the capability to access Issues from a Repository via:<br/>
            - their ID<br/>
            - based on a simple text criteria<br/>
            - the capability to create, edit and execute more complex Queries
    </usecase>
    
    <usecase id="3" name="Issue management">
        For the needs of Issue Management all registered plugins provide:
        - the capability to create and edit Issues<br/>
        - basic Issue information like id, summary, priority, scheduling ...
    </usecase>
    
    <usecase id="4" name="Automated Issue Operations">
        All registered plugins provide bugtracking functionality (if available)
        to other IDE workflows via the Bugtracking API.
        - e.g. attaching files, closing Issues, etc. 
    </usecase>
    
    <p>    
        See also the more detailed <a href="http://wiki.netbeans.org/BugtrackingAPISPIUseCases" shape="rect">API/SPI requirements.</a>      
    </p>
    
 </arch-usecases><api name="BugrackingSPI" type="export" category="devel" group="java">
          Enables Bugtracking modules to fully integrate into Bugtracking Issue Management facilities 
          and other IDE workflow.
      </api><api name="BugrackingAPI" type="export" category="devel" group="java">
          Provides Bugtracking functionality for other subsystems in the IDE.
      </api></module><module name="Classfile Reader" target="org-netbeans-modules-classfile/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The ClassFile API is designed as a fast, low memory-cost way to access classfile
   information.  It is useful for tools and modules that directly read classfiles,
   such as the clazz and javacore modules.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   The normal usecase is for a client wanting to inspect a classfile.  A <code>ClassFile</code> 
   instance is created with either a <code>String</code> path, <code>File</code> or 
   <code>InputStream</code> instance.  All attributes of the classfile are available as properties,
   such as <code>getSourceFileName</code> or <code>getMethods</code>.
  </p>
 </arch-usecases><api name="classfile" type="export" category="stable" group="java">
    </api></module><module name="Static Analysis Core" target="org-netbeans-modules-code-analysis/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="CodeAnalysis" type="export" category="friend" group="java">
          SPI for code analysis tools.
      </api></module><module name="Database Explorer" target="org-netbeans-modules-db/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   This project provides access to objects defined in the Database Explorer.
   Documentation is available in the Javadoc.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="register-drivers" name="Registering JDBC ../db.drivers">
   <p>
    An external module can register JDBC drivers. A typical example is a module
    which provides integration with a database server. In this case the module
    contains the JDBC driver for that database server and uses the Database
    Explorer API to add it do the Database Explorer.
   </p>
   <p>
    Another client of this API could be a module providing integration with a J2EE
    application server. Sometimes a J2EE application server bundles a database server
    for improving the out-of-the-box experience. When the server is registered
    in the IDE the JDBC drivers for the bundled database server are added to the Database
    Explorer.
   </p>
   <p>
    The drivers are registered by making calls on
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/JDBCDriverManager.html" shape="rect">JDBCDriverManager</a> or 
    by registering an XML file which describes the driver in the module layer.
    The XML file is described by the 
    <a href="http://www.netbeans.org/dtds/jdbc-driver-1_1.dtd" shape="rect">JDBC Driver DTD</a>. 
    An example of a registration file describing the JDBC driver for PostgreSQL follows:
   </p>
   <pre xml:space="preserve">
    &lt;?xml version='1.0'?&gt;
    &lt;!DOCTYPE driver PUBLIC '-//NetBeans//DTD JDBC Driver 1.0//EN' 'http://www.netbeans.org/dtds/jdbc-driver-1_0.dtd'&gt;
    &lt;driver&gt;
      &lt;name value='postgresql-7'/&gt;
      &lt;display-name value='PostgreSQL (v7.0 and later)'/&gt;
      &lt;class value='org.postgresql.Driver'/&gt;
      &lt;urls&gt;
        &lt;url value='file:/folder1/folder2/drivers/pg74.1jdbc3.jar'/&gt;
      &lt;/urls&gt;
    &lt;/driver&gt;
   </pre>
   <p>
    This file should be registered in the <code>Databases/JDBCDrivers</code> folder of the module layer.
    To addres a bundled JAR inside the IDE the nbinst protocol can be used in the URLs: 
    <code>nbinst:/modules/ext/bundled-driver.jar</code>.
   </p>
  </usecase>
  <usecase id="get-jdbc-driver" name="Get the underlying JDBC Driver instance for a JDBCDriver">
   <p>
      You can use the <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/JDBCDriver.html#getDriver--" shape="rect">JDBCDriver.getDriver()</a>
      method to obtain a reference to the underlying JDBC Driver instance.  This is useful if you want to use the registered
      drivers but create your own JDBC connections independent of the Database Explorer.

   </p>
  </usecase>
  <usecase id="retrieve-drivers" name="Retrieving the list of JDBC ../db.drivers">
   <p>
    When creating a new connection the JDBC driver which it should use can be specified.
    A list of all the registered JDBC drivers can be retrieved using 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/JDBCDriverManager.html#getDrivers--" shape="rect">JDBCDriverManager.getDrivers()</a>.
   </p>
  </usecase>
  <usecase id="register-runtimes" name="Registering database runtimes">
   <p>
    An external module can register new database runtimes. A database runtime
    is an abstraction of a database server instance 
    (usually bundled with the IDE, an integration module or with a J2EE server). It allows a database
    server instance to be started and stopped when a connection to this
    instance is made in the IDE. Database runtimes are represented by the
    <a href="org-netbeans-modules-db/org/netbeans/spi/db/explorer/DatabaseRuntime.html" shape="rect">DatabaseRuntime</a>
    SPI interface and are registered in the <code>Databases/Runtimes</code> of the module layer.
   </p>
  </usecase>
  <usecase id="create-connections" name="Creating database connections">
   <p>
    A module can create new database connections (for example to a bundled database).
    New connections can be added by calling 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/DatabaseConnection.html#create-org.netbeans.api.db.explorer.JDBCDriver-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-" shape="rect">DatabaseConnection.create()</a>
    to create a new DatabaseConnection instance and then 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#addConnection-org.netbeans.api.db.explorer.DatabaseConnection-" shape="rect">ConnectionManager.addConnection()</a> to
    add the connection to the Database Explorer.
   </p>
   <p>
    New connections can also be added by registering them in the module layer. 
    The format of the registration file is described by the 
    <a href="http://www.netbeans.org/dtds/connection-1_0.dtd" shape="rect">Database Connection DTD</a>. 
    An example of a registration file describing a connection to a PostgreSQL database follows:
   </p>
   <pre xml:space="preserve">
    &lt;?xml version='1.0'?&gt;
    &lt;!DOCTYPE connection PUBLIC '-//NetBeans//DTD Database Connection 1.1//EN' 'http://www.netbeans.org/dtds/connection-1_1.dtd'&gt;
    &lt;connection&gt;
      &lt;driver-class value='org.postgresql.Driver'/&gt;
      &lt;driver-name value='postgres-7'/&gt;
      &lt;database-url value='jdbc:postgresql:test'/&gt;
      &lt;schema value='public'/&gt;
      &lt;user value='test'/&gt;
      &lt;password value='cGFzc3dvcmQ='/&gt;
    &lt;/connection&gt;
   </pre>
   <p>
    This file should be registered in the <code>Databases/Connections</code> folder 
    of the module layer.  
    </p>
    <p>
    The password element is optional, but if it is included, 
    its value must be the Base64 encoding of the UTF-8 representation of the 
    password.  Note that the UTF-8 representation of passwords composed entirely of
    ASCII characters is the same as their ASCII representation, so for such 
    passwords all that needs to be done is to convert them to Base64.
    </p>
    <p>
    Base64 encoding serves as a simple scrambling to prevent 
    accidental revelation of the password.  It is not indended to offer any 
    real security.   You can protect the password by assigning appropriate
    file protections to the connection XML file.
   </p>
  </usecase>
  <usecase id="retrieve-connections" name="Retrieving and displaying the list of database connections">
   <p>
    Sometimes the list of connections needs to be displayed somewhere
    else in the IDE than the Runtime tab. A typical example is the SQL Editor,
    which allows the user to select the database connection which the SQL statement
    will be executed against in a combo box in the editor toolbar. 
    The list of connections can be obtained by calling
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#getConnections--" shape="rect">ConnectionManager.getConnections()</a>,
    which returns an array of 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/DatabaseConnection.html" shape="rect">DatabaseConnection</a>
    instances.
   </p>
   <p>
    The client usually needs to show the display name of the connection. The
    display name can be retrieved using the 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/DatabaseConnection.html#getDisplayName--" shape="rect">DatabaseConnection.getDisplayName()</a>
    method.
   </p>
  </usecase>
  <usecase id="retrieve-connection-props" name="Retrieving the properties of database connections">
   <p>
    Sometimes a client needs to retrieve the connection properties, such as the driver class.
    An example could be a module for a J2EE server creating a connection pool. The properties can
    be retrieved using the <code>getDriverClass()</code>, <code>getDatabaseURL()</code>, 
    <code>getSchema()</code>, <code>getUser()</code> and <code>getPassword()</code>
    methods of the 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/DatabaseConnection.html" shape="rect">DatabaseConnection</a>
    class.
   </p>
  </usecase>
  <usecase id="new-connection" name="Showing the New Database Connection dialog">
   <p>
    Usually when displaying a list of connections (usually in a combo box),
    the last item is "New Connection", which displays the standard New Database Connection 
    dialog of the Database Explorer. This can be achieved by calling one of the
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#showAddConnectionDialog-org.netbeans.api.db.explorer.JDBCDriver-" shape="rect">ConnectionManager.showAddConnectionDialog()</a> methods.
   </p>
  </usecase>
  <usecase id="remove-connection" name="Remove a database connection">
   <p>
       A user of this API may want to remove a connection from the list of connections
       registered by the Database Explorer.  This is done using 
       <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#removeConnection-org.netbeans.api.db.explorer.DatabaseConnection-" shape="rect">ConnectionManager.removeConnection()</a>
   </p>
  </usecase>
 <usecase id="connect-database" name="Connecting to a database">
   <p>
    A component which provides database functionality (such as the SQL Editor)
    will need to connect to a database. This can be achieved using the
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#showConnectionDialog-org.netbeans.api.db.explorer.DatabaseConnection-" shape="rect">DatabaseConnection.showConnectionDialog()</a>
    method and the <code>java.sql.Connection</code> instance can be retrieved using the 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/DatabaseConnection.html#getJDBCConnection--" shape="rect">getJDBCConnection()</a>
    method.
   </p>
   <p>
     If you want to connect to the database without showing a dialog or any kind of UI, you can use the
     <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#connect-org.netbeans.api.db.explorer.DatabaseConnection-" shape="rect">DatabaseConnection.connect()</a>
     method.
   </p>
  </usecase>
 <usecase id="test-connection" name="Test a database connection for validity">
   <p>
    You may want to test to make sure the underlying physical JDBC connection
    obtained from a DatabaseConnection is either valid or null.  This is done using the
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/DatabaseConnection.html#getJDBCConnection-boolean-" shape="rect">
        DatabaseConnection.getJDBCConnection(boolean test)</a>
    method, which validates the underlying connection before returning it.  If the
    connection is invalid, it marks the DatabaseConnection as disconnected and returns null.
   </p>
  </usecase>
  <usecase id="connections-combo-box" name="Displaying the database connections in the UI">
   <p>
    A component which provides database functionality (such as the SQL Editor
    or a module providing support for data sources) will need to let the user
    select the a database connection, usually through a combo box.
    This can be achieved using the
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/support/DatabaseExplorerUIs.html#connect-javax.swing.JComboBox-org.netbeans.api.db.explorer.ConnectionManager-" shape="rect">DatabaseExplorerUIs.connect()</a>
    method. The <code>JComboBox</code> passed to the method will be filled with the list of connections as returned by 
    <a href="org-netbeans-modules-db/org/netbeans/api/db/explorer/ConnectionManager.html#getConnections--" shape="rect">ConnectionManager.getConnections()</a>, followed by a separator
    and a <em>New Database Connection</em> item which will display the dialog for adding a new database connection when selected.
   </p>
  </usecase>
  <usecase id="metadata-transfer" name="Drag and drop support for database objects">
   <p>
    A component might need to allow database tables from the Database Explorer to 
    be dragged to a visual editor. An API is provided in <code>DatabaseMetaDataTransfer</code>
    containing <code>DataFlavor</code>s for database objects and nested classes
    encapsulating those database objects during a drag and drop transfer.
   </p>
  </usecase>
  <usecase id="sql-identifier-support" name="Get support for working with SQL identifiers">
   <p>
       A component might need support for working with SQL identifiers. In particular,
       it's important to know when to quote a SQL identifier.  The
       <a href="org-netbeans-modules-db/org/netbeans/api/db/sql/support/SQLIdentifiers.Quoter.html" shape="rect">
           SQLIdentifiers.Quoter</a> class is provided for this.
   </p> 
  </usecase>
 </arch-usecases><api name="DatabaseExplorerAPI" type="export" category="official" url="org-netbeans-modules-db/index.html" group="java"/><api name="DatabaseExplorerLayerAPI" type="export" category="official" url="org-netbeans-modules-db/index.html" group="layer"/><api name="Loaders-text-dbschema-Actions" type="export" category="devel" url="org-netbeans-modules-db/index.html" group="layer"/><api name="Loaders-text-sql-Actions" type="export" category="devel" url="org-netbeans-modules-db/index.html" group="layer"/><api name="SQLSupportAPI" type="export" category="official" url="org-netbeans-modules-db/org/netbeans/api/db/sql/support/package-summary.html" group="java"/></module><module name="Diff" target="org-netbeans-modules-diff/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The diff module provides the ability to visualize differences between source files.
It also has a graphical conflicts resolver tool and built-in patch algorithm.
List of the main features:

  Simple APIs, that provide access to registered diff and merge engines and visualizers.
  Built in and external diff engines defined.
  Graphical diff vizualizer and conflicts resolver.
  Extensible with additional diff and merge engines and vizualizers.
  Patch algorithm implemented for UNIX-style, unidiff and contextual diff formats.

</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

     
<usecase id="diff-action" name="Show a diff from action">
<p>
From an action or wherever you like you can call this:
</p>

<pre xml:space="preserve">
public void diff(final StreamSource local, final StreamSource remote){
    SwingUtilities.invokeLater(new Runnable() {
        public void run() {
            try {
                <a href="org-netbeans-modules-diff/org/netbeans/api/diff/DiffView.html" shape="rect">DiffView</a> view = <a href="org-netbeans-modules-diff/org/netbeans/api/diff/Diff.html" shape="rect">Diff</a>.getDefault().createDiff(local, remote);
                showDiff(view);
            } catch (IOException ex) {
                Logger.getLogger(ThisClass.class.getName()).throwing(ex);
            }
        }
    });
}
public void showDiff(final <a href="org-netbeans-modules-diff/org/netbeans/api/diff/DiffView.html" shape="rect">DiffView</a> view){
    SwingUtilities.invokeLater(new Runnable() {
        public void run() {
            //create our panel with our view
            //right now I am just going to use the diff component 
            // instead of a panel
            //create a topcomponent with our panel
            DiffTopComponent tc = new DiffTopComponent(view);
            tc.setName("MY_DIFF");
            tc.setDisplayName("Some display name");
            tc.open();
            tc.requestActive();
        }
    });
}
</pre>
</usecase>

<usecase id="diff-component" name="Embeded into TopComponent">
<p>
Here is a top component to display it:
</p>

<pre xml:space="preserve">
public class DiffTopComponent extends <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html" shape="rect">TopComponent</a> {
    /** Creates a new instance of DiffTopComponent */
    public DiffTopComponent(Component diffPanel) {
        setLayout(new BorderLayout());
        add(diffPanel, BorderLayout.CENTER);
        getAccessibleContext().setAccessibleName(
            NbBundle.getMessage(DiffTopComponent.class, 
            "ACSN_Diff_Top_Component")); // NOI18N
        
        getAccessibleContext().setAccessibleDescription(
            NbBundle.getMessage(DiffTopComponent.class, 
            "ACSD_Diff_Top_Component")); // NOI18N
    }
   
    public DiffTopComponent(DiffView view) {
        this(view.getComponent());
    }
    public int getPersistenceType(){
        return TopComponent.PERSISTENCE_NEVER;
    }
    protected String preferredID(){
        return "DiffTopComponent";    //NOI18N
    }
    public HelpCtx getHelpCtx() {
        return new HelpCtx(getClass());
    }
}
</pre>
</usecase>

 </arch-usecases><api name="DiffAPI" type="export" category="official" group="java"/><api name="DiffImplementationAPI" type="export" category="friend" group="java"/></module><module name="Editor Module" target="org-netbeans-modules-editor/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The editor module provides a full-featured source text editor
that is integrated with the Form Editor, Explorer, compiler, and debugger. 
List of the main features:


    Syntax highlighting of java, HTML, XML and other languages.
  Code Completion enables to type a few characters 
        and then display a list of suggestions appropriate
        in the given context that can be then used 
        to automatically complete the expression.
  
  Word Matching enables enables to type the beginning characters
        of a word used elsewhere in the code and then have the editor
        generate the rest of the word.
  
  Abbreviations allow to expand typed text from a few
        predefined characters into a full word or phrase.
  
  Goto Class enables to open a Java file in the Source Editor 
        by typing only the class name.
        The IDE helps to identify the correct package name for the class.
  
  The Fast Import feature enables to quickly add import statements
        for Java classes in the source file.
  
  Goto Declaration feature allows to quickly jump to a declaration
        of a variable under the cursor.
  
  Goto Source allows to open source file containing
        definition of a type that the variable under the cursor is of.
  
  Code folding allows to collapse sections of the code that are
        unimportant to the user at the given time.
        For example in java source the collapsable sections include
        imports section, inner classes, methods and javadocs.
  

</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
No answer
</arch-usecases><api name="EditorModuleAPI" type="export" category="devel" group="java">
        Editor defines APIs and SPIs both by 
        <ul>
            <li> Providing java classes in public packages for further reuse.
                <br/>
                Most of the classes were created spontaneously (several years ago)
                without fulfilling of the rules imposed on APIs and SPIs
                at the present time.
                <br/>
                There is an ongoing work to revisit the existing classes
                and create stable APIs and SPIs (and possibly extract functionality
                into a submodule where appropriate). However this is a long-term
                task spanning several promotions.
            </li>
            <li> Being sensitive to content of certain directories in xml layer.
            </li>
        </ul>
    </api><api name="DefaultEditorKit.EndOfLineStringProperty" type="export" category="stable" group="property">
        Document property containing line separator that was used when the document content was
        loaded from a <code>java.io.Reader</code> by an <code>EditorKit.read()</code>.
    </api><api name="line-limit" type="export" category="private" group="property">
        Document property that determines the number of characters in the longest line
        determined during the document loading from a reader by the editor kit. 
    </api></module><module name="Editor Braces Matching" target="org-netbeans-modules-editor-bracesmatching/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
  The Braces Matching SPI allows modules providing editor support for documents
  to create their own BracesMatchers that are tailored for the type of documents they
  support. The module itself provides an infrastructure for
  highlighting matching areas identified by a matcher and navigating between them. 
  
 </description><deploy-dependencies>
  <p>
  Just normal module dependency.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
  Although the SPI can generally by used for highlighting areas in a document
  that have something in common, the usecases below are demonstrated on a simple
  braces matching example. This example is used for its simplicity and clarity,
  but it could be substituted by more complex examples.
  </p>

  <p>
  The usecases listed here were heavily inspired by comments in issues
  <a href="http://www.netbeans.org/issues/show_bug.cgi?id=95126" shape="rect">95126</a> and
  <a href="http://www.netbeans.org/issues/show_bug.cgi?id=66037" shape="rect">66037</a>.
  </p>
  
  <usecase id="usecase-1" name="Usecase 1. - Highlighting results">
  <p>
  Probably the main reason why this SPI exists is to allow Netbeans editor to
  highlight matching braces in a document. The highlighting itself is done by the
  infrastructure and is not of a concern for <code>BracesMatcher</code> implementors.
  It should be possible to highlight independently
  (ie. in a different color) both the original brace and the matching brace. It should also
  be possible to highlight the original brace in a special color when its matching
  brace can't be found. The colors obviously have to be customizable by users.
  </p>
  </usecase>
  
  <usecase id="usecase-2" name="Usecase 2. - Navigating between results">
  <p>
  If the original brace is detected and its matching brace is found Netbeans editor
  needs to allow an easy navigation between those two positions (ie. jumping
  from the original brace to the matching one and back).
  </p>
  
  <p>
  In general if there is more than one matching area users should be allowed to cycle
  through all of them. Since there is only one editor action (shortcut) for navigating
  between matching areas the cycling is only done in one direction (backward). In
  order for cycling to work properly the <code>BracesMatcher</code> implementation has to report
  matching areas in a consistent way. That is the matching areas should always be
  sorted by their position in a document, starting with the one at the lowest offset.
  </p>
  </usecase>

  <usecase id="usecase-3" name="Usecase 3. - Different search scenarios">
  <p>
  The users are likely to have different preferences for the way how braces matching
  works therefore its behavior should be customizable. We have listed below several
  possible scenarios that can be used simply by setting different values for the
  search parameters described before. They all differ in the way how the original
  area is detected.
  </p>

  <p>
  The shortcuts for the parameters have the following meaning - <code>MBL</code>
  ... max backward lookahead, <code>MFL</code> ... max forward lookahead,
  <code>SD</code> ... search direction, <code>CB</code> ... caret bias. The values
  are <code>B</code> ... backward or backward preferred and 
  <code>F</code> ... forward or forward preferred. The question mark <code>?</code>
  means that the value of this parameter has no effect for the search.
  </p>
  
  <ul style="list-style-type : upper-alpha">
  <li>
      <a name="search-scenario-A" shape="rect"><code>MBL = 0, MFL = 0, SD = ?, CB = F</code></a> : Check only the right hand side
      character of the caret. This is the default for Netbeans overwrite mode (ie. the
      block shaped caret).
  </li>
  <li>
      <a name="search-scenario-B" shape="rect"><code>MBL = 1, MFL = 1, SD = ?, CB = B</code></a> : Check characters right next to
      the caret on both its sides. This is the default for Netbeans normal mode (ie.
      the I-beam shaped caret).
  </li>
  <li>
      <code>MBL = 0, MFL = 256, SD = F, CB = B</code> : Check the character on the
      left hand side of the caret, otherwise search forward. This is the default
      for jVi insert mode.
  </li>
  <li>
      <code>MBL = 0, MFL = 256, SD = F, CB = F</code> : Search forward from the caret.
      This is the default for jVi command mode.
  </li>
  <li>
      <code>MBL = 256, MFL = 256, SD = F, CB = B</code> : Check the left hand side
      character, otherwise search forward first and then backward. Suitable for
      I-beam carets that detect the original area anywhere on the line with the
      caret giving preferrence to the area positioned forward from the caret. The
      preferrence for the backward positioned area can simply be achieved by changing
      the search direction (ie. <code>SD = B</code>).
  </li>
  <li>
      <code>MBL = 256, MFL = 256, SD = F, CB = F</code> : The same as
      option E, but for the block carets.
  </li>
  </ul>
  </usecase>
  
  <usecase id="usecase-4" name="Usecase 4. - Auto-switching the search scenario">
  <p>
  The editor in Netbeans can operate in two modes - normal and overwrite. They both
  use different shape of a caret and thus need a different caret bias. The braces
  matching infrastructure should detect what mode the editor is in and change the
  parameters used for searching for the original area accordingly. The caret bias
  is the most important parameter, but other parameters may need to be changed too.
  </p>
  
  <p>
  This feature should of course be only active for text components where the parameters
  have not been overwritten by some other module.
  </p>
  
  <p>
  By default the two search scenarios used for the normal and overwrite modes in
  Netbeans editor are the <a href="#search-scenario-B" shape="rect">scenario B</a> for the normal
  mode and <a href="#search-scenario-A" shape="rect">scenario A</a> for the overwrite mode. In
  general scenarios from both editor modes should be customizable by users.
  </p>
  </usecase>
 </arch-usecases><api name="BracesMatchingSPI" type="export" category="devel" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-bracesmatching/overview-summary.html" group="java"/><api name="nbeditor-bracesMatching-caretBias" type="export" category="devel" group="property">
  Controls where the important character lies in relation to a caret. The important
  character is a character right next to a caret and depending on the value of
  this property it can be the character on either the left hand side or the right hand side
  of the caret. Please see the infrastructure
  <a href="#controlling-parameters" shape="rect">overview</a>
  for more details.
  </api><api name="nbeditor-bracesMatching-searchDirection" type="export" category="devel" group="property">
  Controls a direction
  in which the search for the original area is performed. Please see the infrastructure
  <a href="#controlling-parameters" shape="rect">overview</a>
  for more details.
  </api><api name="nbeditor-bracesMatching-maxBackwardLookahead" type="export" category="devel" group="property">
  Controls the maximum distance
  measured in characters from the position of a caret, where matchers are allowed
  to search for the original area. Please see the infrastructure
  <a href="#controlling-parameters" shape="rect">overview</a>
  for more details.
  </api><api name="nbeditor-bracesMatching-maxForwardLookahead" type="export" category="devel" group="property">
  Controls the maximum distance
  measured in characters from the position of a caret, where matchers are allowed
  to search for the original area. Please see the
  <a href="#controlling-parameters" shape="rect">overveiw</a>
  for more details.
  </api></module><module name="Editor Code Templates" target="org-netbeans-modules-editor-codetemplates/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Code Templates allow to paste various code snippets by using parametrized text.
The parameters of the same name will share the same default value and if that value
gets changed by user's typing the new value gets replicated into all the parameter's
occurrences.

Code Templates replace the original abbreviations functionality.


Code template's example


for (Iterator ${iterator} = ${collection instanceof="java.util.Collection"}.iterator(); ${iterator}.hasNext();) {
    ${cursor}${iterator}.next();"
}

Each parameter can have additional hints of what values
can be assigned to it.
The hint has a form

${param hint=value}

or just

${param hint}

which translates to

${param hint="true"}



If necessary the value of the hint can be enclosed
in quotes to allow to write whitespace or { or }
into the value. The quote can be written by using \".


Reserved parameter names

${cursor} defines position where the caret will be located
after the editing of the code template default values will finish.


Reserved hint names

${param editable=false} can be used to make the parameter to be skipped
from user's editing. This may be useful e.g. with using java-specific type
hint (described below).



Java:

${ind index} defines that the default value of the parameter
  should be an unused variable in the given context named i.
  If i is already used then j is attempted
  or then k etc. until z.
  Then i0, i1 etc. are attempted.

${param type="java.util.Collection"} defines
  java type that the parameter must be instance of.
  Besides class names there can be array e.g. String[]
  or generics java.util.List&lt;String&gt;

${param array} defines parameter of array type (including
arrays of primitive data types).

${param type="java.util.Iterator"} defines
  that the parameter has the given java type. The template processing infrastructure
  will use short name Iterator and import java.util.Iterator.


</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<usecase id="code-template-parameters" name="Code Template Parameters">
One of the main benefits of the code templates is their parametrization
which allows to substitute the default values for the parameters
before the final insertion and it also allows the user to modify
these default values explicitly after the code template gets inserted
into the document.
<br/>
The parameters are marked in the code template's text by <code>${...}</code>.
<br/>
Parameters of the same name benefit from automatic replication. Once the template
gets pasted into the document all the parameter's occurrences
get replaced by parameter's default value.
<br/>
The first parameter's occurrence gets selected.
<br/>
The user can now replace the default value. If the user does so the new value
gets replicated to all the other occurrences of this parameter automatically.
</usecase>

<usecase id="mime-type-specific-operation" name="Mime-type specific operation">
Each code template needs to find the default values for its parameters
before it gets inserted into the text.
<br/>
Sometimes it's enough to just specify the default value in the template's text
but usually the default value gets determined from the context of insertion.
<br/>
There is an intent to create a mime-type specific code template processor
that would be registered per mime-type. There could be even more than one
such processors processing the template in a specific order.
</usecase>

<usecase id="parameter-hints" name="Parameter hints">
Besides parameter's name the template processors may need additional
hints of how to find a default value for the parameter.
<br/>
For example java code template's parameter may be an <code>index</code>
parameter which means that the infrastructure should fill in
a fresh index variable e.g. <code>i</code>.
<br/>
Or the parameter can only be of a certain java type such
as in the case of iterating through a collection
the type must be subtype of <code>java.util.Collection</code>.
<br/>
These requirements could be specified as additional hints
to the parameters e.g. <code>${i index}</code>
or <code>${c instanceof=java.util.Collection}</code>.
<br/>
The hints allow string literals to support arbitrary
explicit default values specifications
e.g. <code>${x default="Hello world"}</code>.
<br/>
The '{' and '}' have no special meaning inside the string literal.
<br/>
The '"' char is allowed to be used by escaping
<code>${x default="\"quoted string\""}</code>.
</usecase>

<usecase id="temporary-code-templates" name="Temporary Code Templates">
The Code Completion functionality allows to build temporary
Code Templates functionality if it could build a temporary template
for completing of the method parameters. The parameters could
be completed one by one by tabbing and the Code Templates framework
would fill in proper default values just like it does for regular templates.
<pre xml:space="preserve">
    JTextComponent pane = ...
    String tempCodeTemplateText = ...
    CodeTemplate ct = CodeTemplateManager.get(pane.getDocument()).createTemporary(tempCodeTemplateText);
    ct.insert(pane);
</pre>
</usecase>

<usecase id="insert-text" name="Insert Text Building and Updating">
The parametrized text of the code template first gets parsed
and the parameters get their default values which by default are
the names of the parameters.
The code template processor are then called to update this default
value.
<br/>
The new java infrastructure being developed would benefit
from the possibility to obtain the full string containing
the skeleton of the code template (without parameters)
with the present default values. It can take that string
and locally parse it to find out types of local variables
used in the particular template and fill in dependent
variable types.
</usecase>

<usecase id="parameter-editability" name="Parameter Editability">
Certain part of the code template may change text but it should
not be edited by the user. For example when iterating over collection
given as a parameter the collection may be generics-ed
by additional type. The iterator's variable type then also
needs to generics-ed with the same type.
<br/>
The iterator's type parameter should not be editable because
this operation may be done automatically
by the java code template processor.
<br/>
There should be a hint <code>editable</code> having
<code>true</code>/<code>false</code>.
</usecase>


</arch-usecases><api name="CodeTemplatesAPI" type="export" category="stable" group="java"/></module><module name="Editor Code Completion" target="org-netbeans-modules-editor-completion/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  Code Completion provides users with a list of suggested completions for partially typed texts in the editor and various dialog input fields.
  
   The Code Completion module was created to replace
   the original legacy editor code completion which
   lacked several key requirements:
  
   
     
     Support for multiple independent code completion content providers.
     
     
     Implied requirement for ordering and prioritization of the completion items.
     
     
     Direct support for asynchronous completion result computation.
     
     
     Missing separation to the API and SPI and implementation parts.
     
   
 </description><deploy-dependencies>
     Nothing.
 </deploy-dependencies><arch-usecases>
 
 <h3>API</h3>

 <usecase id="show-or-hide-completion" name="Show or hide completion window">

 <p>
 The API is small and it only allows to explicitly show or hide the completion window.
 <br/>
 It's being used by code templates that need to explicitly show the code completion
 window when tabbing to a particular parameter.
 <br/>
 There may be certain actions that want to ensure that the code completion is hidden
 at the time when they are invoked. For example the actions pasting the content
 of the completion item into the document.
 </p>

 </usecase>

 <h3>SPI</h3>

 <usecase id="completion-provider" name="Provide completion content by independent providers">
 
 <p>
  Completion infrastructure needs to obtain the results that are then displayed
  in the completion window.
  <br/>
  There are three types of displayed results related to the current caret offset:
 </p>
 <ul>
      <li>
      Code completion items
      </li>
      <li>
      Documentation (e.g. the javadoc documentation)
      </li>
      <li>
      Tooltip (e.g. for method parameters)
      </li>
 </ul>
 <p>
  For the purpose of obtaining these completion results
  <a href="org-netbeans-modules-editor-completion/org/netbeans/spi/editor/completion/CompletionProvider.html" shape="rect">
  CompletionProvider</a>
  exists.

  <br/>
  There may be an arbitrary number of independent completion providers for 
  a single completion popup window.
  <br/>
  The completion providers are registered through the xml layer into
  <i>Editors/&lt;mime-type&gt;/CompletionProviders</i>. Once the document
  with the particular mime-type gets loaded the corresponding completion providers
  will get instantiated and used.
 </p>

 <p>
 Threading:
 <br/>
 The code completion's infrastructure invokes the requests
 for the completion results in the AWT thread.
 <br/>
 Therefore all the methods of the completion providers are invoked
 in AWT thread but they may reschedule their processing into other threads.
 </p>
 
 </usecase>

 <usecase id="asynchronous-completion-task" name="Provide completion results computed asynchronously">
 <p>
  The completion provider creates a task that computes the resulting
  data that will then be displayed by the code completion infrastructure.
  <br/>
  The task creation and computation are called synchronously
  from the AWT event dispatch thread.
  <br/>
  However there can be potentially long-running tasks (e.g. working with MDR)
  that are not desirable to be run in AWT thread.
  <br/>
  Therefore the completion infrastructure provides a listener
  to which the completion task notifies the results.
  <br/>
  The support class
  <a href="org-netbeans-modules-editor-completion/org/netbeans/spi/editor/completion/support/AsyncCompletionTask.html" shape="rect">
  AsyncCompletionTask</a> allows to post the task computation
  into <code>RequestProcessor</code>.
 </p>
 
 </usecase>

 <usecase id="completion-item" name="Provide list of completion items fulfilling various requirements">
 <p>
  The completion task computes a collection of completion items
  which are then collected by the completion infrastructure and displayed.
  <br/>
  <b>Displaying</b>. Each completion item must be able to display itself in a <code>JList</code>.
  <br/>
  <b>Sorting</b>. The completion items may come from different completion providers
  and they must be sorted before displaying. The sort order
  should not only be alphabetical but it should also allow a prioritization
  of the items according to their importance in the given context.
  <br/>
  <b>Actions</b>. The interaction of the user with the completion item
  is done by interacting with item's input map and action map.
  <br/>
  <b>Documentation</b>. The item may want to display additional
  detailed information in a documentation popup window.
  </p>
 
 </usecase>

 </arch-usecases><api name="CodeCompletionAPI" type="export" category="official" url="org-netbeans-modules-editor-completion/index.html" group="java"/><api name="org.netbeans.ui.editor.completion" type="export" category="devel" group="logger">
    Since version 1.8 the completion cooperates with <!-- XXX link to http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-uihandler/overview-summary.html not OK from a stable API -->UI Gestures Collector
    by sending following messages to the <code>org.netbeans.ui.editor.completion</code> <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">logger</a>:
    <ul>
        <li><b>COMPL_INVOCATION</b> - message about a code completion being invoked. Arguments:
            <ul>
                <li>{0}: true - if explicit, false if implicit invocation happened</li>
                <!--
                <li>{1}: the index of selected item</li>
                <li>{2}: the classname of the selected item</li>
                -->
            </ul>
        </li>
        <li><b>COMPL_KEY_SELECT</b> - send when user selects an item from completion using keyboard character. Arguments:
            <ul>
                <li>{0}: character that invoked the action</li>
                <li>{1}: the index of selected item</li>
                <li>{2}: the classname of the selected item</li>
            </ul>
        </li>
        <li><b>COMPL_KEY_SELECT_DEFAULT</b> - send when user selects an item from completion using enter. Arguments:
            <ul>
                <li>{0}: '\n'</li>
                <li>{1}: the index of selected item</li>
                <li>{2}: the classname of the selected item</li>
            </ul>
        </li>
        <li><b>COMPL_MOUSE_SELECT</b> - send when user selects an item from completion using mouse. Arguments:
            <ul>
                <li>{0}: null</li>
                <li>{1}: the index of selected item</li>
                <li>{2}: the classname of the selected item</li>
            </ul>
        </li>
        <li><b>COMPL_CANCEL</b> - send when user selects cancels completion without any selection. No arguments.
<!--
            <ul>
                <li>{0}: null</li>
                <li>{1}: the index of selected item</li>
                <li>{2}: the classname of the selected item</li>
            </ul>
-->
        </li>
        
    </ul>
  </api><api name="org.netbeans.modules.editor.completion.slowness.report" type="export" category="private" url="http://wiki.netbeans.org/FitnessViaPostMortem" group="systemproperty">
      You can suppress automatic reporting of slow code completion computation
      by increasing value of <code>-J-Dorg.netbeans.modules.editor.completion.slowness.report</code>
      property to more than 2000 ms (the default value).
  </api></module><module name="Editor Error Stripe" target="org-netbeans-modules-editor-errorstripe-api/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  The Error Stripe shows an overview of important information of an edited source code.
     It shows this information for the whole source code (regardless of its size).
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
 
 <usecase id="annotations-provider" name="Augment Annotations to be shown in the Error Stripe">
     Use the <api category="stable" group="java" name="TextAPI" type="export" url="http://netbeans.apache.org/javadoc/dev/org-openide-text/overview-summary.html">OpenIDE Text API</api>.
 </usecase>

 <usecase id="up-to-date-provider" name="Provide Up-to-date Status for the Error Stripe">
 
 <p>A module in the IDE has information whether data shown in the Error Stripe
    is up-to-date or not. The Error Stripe may change the appearance according to this knowledge.
 </p>
 
 <p>Implement the <a href="org-netbeans-modules-editor-errorstripe-api/org/netbeans/spi/editor/errorstripe/UpToDateStatusProvider.html" shape="rect">UpToDateStatusProvider</a>
 that provides up-to-date status. Be sure that it fires PropertyChangeEvent when this status is changed.</p>

 <p>Implement the <a href="org-netbeans-modules-editor-errorstripe-api/org/netbeans/spi/editor/errorstripe/UpToDateStatusProviderFactory.html" shape="rect">UpToDateStatusProviderFactory</a>
 that creates an instance of your UpToDateStatusProvider for a given JTextComponent and install it as described
 <a href="org-netbeans-modules-editor-errorstripe-api/org/netbeans/spi/editor/errorstripe/UpToDateStatusProviderFactory.html" shape="rect">here</a>.</p>
 
 </usecase>

<!-- <usecase id="registration" name="MIME Type Based Registration">
 
 <p>An UpToDateStatusMarkProvider may provide information that can be applied to any editor type, or it may
 provide infromation that applies only to a very specific type of editor.
 </p>
 
 </usecase>-->
 
 </arch-usecases><api name="TextAPI" type="export" category="stable" url="http://netbeans.apache.org/javadoc/dev/org-openide-text/overview-summary.html" group="java">OpenIDE Text API</api><api name="ErrorStripeSPI" type="export" category="stable" url="org-netbeans-modules-editor-errorstripe-api/index.html" group="java">public SPI provided by the Error Stripe.</api><api name="ErrorStripePrivateSPI" type="export" category="private" group="java">Private mark provider SPI.</api><api name="TextAPI" type="export" category="stable" url="http://netbeans.apache.org/javadoc/dev/org-openide-text/overview-summary.html" group="java">OpenIDE Text API</api><api name="ErrorStripeSPI" type="export" category="stable" url="org-netbeans-modules-editor-errorstripe-api/index.html" group="java">Error Stripe SPI</api><api name="org.netbeans.modules.editor.errorstripe.AnnotationView" type="export" category="private" group="systemproperty">
    This property sets the logging level. See org.openide.ErrorManager.getInstance for more details.
   </api><api name="ErrorStripePrivateSPI" type="export" category="private" group="java">private mark provider SPI.</api><api name="ErrorStripePrivateSPI" type="export" category="private" group="java">private mark provider SPI</api><api name="ErrorStripePrivateSPI" type="export" category="private" group="java">private mark provider SPI.</api><api name="ErrorStripePrivateSPI" type="export" category="private" group="java">private mark provider SPI</api></module><module name="Editor Code Folding" target="org-netbeans-modules-editor-fold/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The Code Folding is part of the editor module functionality and it's responsible for hiding of the portions
of the code that are less important for the user at the given time.

</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<h2>
API Use Cases
</h2>

<h3>
Exploring of the Folds
</h3>

<p>
The code folding structure (fold hierarchy) relates
to <code>javax.swing.JTextComponent</code> instance in one-to-one relationship.
<br/>
To find the code folding hierarchy instance for the given non-null text component
the following code snippet can be used:
</p>

<pre xml:space="preserve">
    JTextComponent editorComponent = ...
    FoldHierarchy hierarchy = FoldHierarchy.get(editorComponent);
</pre>


<h3>
Explore the Folds Hierarchy
</h3>

<p>
The tree-based hierarchy has one non-removable and non-collapsable root fold
that covers the whole document. It can be obtained by
</p>

<pre xml:space="preserve">
    FoldHierarchy foldHierarchy = ...
    Fold rootFold = hierarchy.getRootFold();
</pre>

<p>
The children folds of the root fold (or children folds)
can be obtained by
</p>

<pre xml:space="preserve">
    // the hierarchy must be locked prior exploration or manipulation
    hierarchy.lock();
    try {
        Fold rootFold = ...
        int foldCount = rootFold.getFoldCount();
        for (int i = 0; i &lt; foldCount; i++) {
            Fold childFold = rootFold.getFold(i);
        }
    } finally {
        hierarchy.unlock();
    }
</pre>

<p>
Index of the child in its parent can be found by
</p>

<pre xml:space="preserve">
    hierarchy.lock();
    try {
        Fold rootFold = ...
        int foldIndex = rootFold.getFoldIndex(childFold);
    } finally {
        hierarchy.unlock();
    }
</pre>


<h3>
Collapse Nearest Fold
</h3>

<p>
In the given fold hierarchy find the nearest fold right at or after the given offset
and collapse it.
</p>

<pre xml:space="preserve">
    hierarchy.lock();
    try {
        Fold fold = FoldUtilities.findNearestFold(hierarchy, offset);
        hierarchy.collapse(fold);
    } finally {
        hierarchy.unlock();
    }
</pre>


<h3>
Expand All Folds
</h3>

<p>
In the given fold hierarchy expand all folds that are currently collapsed.
</p>

<pre xml:space="preserve">
    FoldUtilities.expand(hierarchy, null);
</pre>


<h3>
Collapse All Folds of Certain Type
</h3>

<p>
In the given fold hierarchy collapse all e.g. javadoc folds that are currently collapsed.
<br/>
The example can be generalized to any fold type.
</p>

<pre xml:space="preserve">
    FoldUtilities.collapse(hierarchy, JAVADOC_FOLD_TYPE);
</pre>


<h3>
Start Listening on Fold Hierarchy Changes
</h3>

<p>
In the given fold hierarchy start to listen on all changes
done in the hierarchy.
<br/>
This is actually used e.g. in the Editor's View Hierarchy that needs
to refresh views based on the fold changes.
</p>

<pre xml:space="preserve">
    hierarchy.addFoldHierarchyListener(new FoldHierarchyListener() {
        public void foldHierarchyChanged(FoldHierarchyEvent evt) {
            // Hierarchy does not need to be locked here
            //
            // evt.getAffectedStartOffset() and getAffectedEndOffset()
            // give text area affected by the fold changes in the event
        }
    });

</pre>


<h3>
Inspect Collapsed Folds in Affected Area
</h3>

<p>
Listen on the hierarchy changes
and refresh the views in the text area affected by the fold change.
<br/>
Inspect the collapsed folds in the affected area
because special views need to be created for the collapsed folds.
<br/>
The actual code in the View Hierarchy is somewhat different
but the one given here is more descriptive.
</p>

<pre xml:space="preserve">
    hierarchy.addFoldHierarchyListener(new FoldHierarchyListener() {
        public void foldHierarchyChanged(FoldHierarchyEvent evt) {
            for (Iterator collapsedFoldIterator
                = FoldUtilities.collapsedFoldIterator(hierarchy,
                    evt.getAffectedStartOffset(),
                    evt.getAffectedEndOffset()
                );
                it.hasNext();
            ) {
                Fold collapsedFold = (Fold)it.next();
                // Create special view for the collapsedFold
            }
        }
    });
</pre>



<h2>
SPI Use Cases
</h2>

<h3>
Create a New Fold Manager
</h3>

<p>
Manipulation of the folds is designed to be done by fold managers.
<br/>
Those classes implement <code>FoldManager</code> interface in the SPI.
<br/>
At initialization time they are given instance of <code>FoldOperation</code>
through which they can create, add or remove the fold instances.
</p>

<p>
To create and use a new <code>FoldManager</code> instance
it's necessary to
</p>

<ul>
    <li> Define the class of the FoldManager.
<pre xml:space="preserve">
    public class MyFoldManager implements FoldManager { // or extends AbstractFoldManager

        ...

    }
</pre>
    </li>

    <li> Create FoldManagerFactory for the FoldManager.
<pre xml:space="preserve">

    public class MyFoldManager ...

        ...

        public static final class Factory implements FoldManagerFactory {

            public FoldManager createFoldManager() {
                return new MyFoldManager();
            }

        }

    }
</pre>
    </li>

    <li> Register FoldManagerFactory into xml layer into the directory
        "Editors/&lt;mime-type&gt;/FoldManager/"
    </li>

    <li> Enable Code Folding in editor's Settings initializer
         (please see e.g. <code>NbJavaSettingsInitializer</code>)
<pre xml:space="preserve">

    public class MySettingsInitializer ...

        public void updateSettingsMap(Class kitClass, Map settingsMap) {
            ...
            settingsMap.put(SettingsNames.CODE_FOLDING_ENABLE, Boolean.TRUE);
        }

    }
</pre>
    </li>

</ul>


<h3>
Create a New Fold by Fold Manager
</h3>

<p>
Create a new fold and add it to the hierarchy. The operation
is performed by the fold manager either at initialization phase
(in the <code>initFolds()</code> which gets called automatically
by the infrastructure) or at any other time when the fold manager's
operation gets invoked (usually by a listener that the fold manager
attaches to be notified about changes that can cause the folds structure
to be changed - e.g. a parsing listener for java folds).
</p>

<p>
Operations that manipulate the hierarchy are done
in terms of a valid transaction over the fold hierarchy.
<br/>
Transactions allow to fire the collected changes as a single
<code>FoldHierarchyEvent</code> at the time when they are committed.
</p>

<pre xml:space="preserve">
    // In the FoldManager's context
    FoldOperation operation = getOperation();
    FoldHierarchyTransaction transaction = operation.openTransaction();
    try {
        Fold fold = operation.createFold(...);
        operation.addFoldToHierarchy(fold, transaction);
    } finally {
        transaction.commit();
    }
</pre>


<h3>
Remove Fold from Hierarchy by Fold Manager
</h3>

<p>
Remove the existing fold from the hierarchy
</p>

<pre xml:space="preserve">
    // In the FoldManager's context
    FoldOperation operation = getOperation();
    FoldHierarchyTransaction transaction = operation.openTransaction();
    try {
        Fold fold = ...
        operation.removeFoldFromHierarchy(fold, transaction);
    } finally {
        transaction.commit();
    }
</pre>

<h3>Updating Fold hierarchy</h3>
In the preceding cases, maintaining Folds was the FoldManager's responsibility. The FoldManager typically
held a copy of the Folds added to the hierarchy, and during the refresh, it compared them to the new data
and decided what folds to remove.
For simple cases, which only create/remove folds based on text positions, part of the work can be offloaded to the
FoldOperation:

<pre xml:space="preserve">
    // create new fold positional information for all folds.
    Collection&lt;FoldInfo&gt; newInfos = ...;
    
    // create FoldInfo for each of the fold
    newInfos.add(
        FoldInfo.range(start, end, type).
            withTemplate(customTemplate).
            withDescription(veryCustomDescription).
            collapse(true)
    );
    
    // the hierarchy must be locked prior to update
    
    doc.readLock();
    hierarchy.lock();
    try {
        operation.update(newInfos, null, null);
    } finally {
    }
</pre>

The <code>update()</code> operation performs a diff, creates new folds, discards old ones, and updates the folds, which
prevailed.

<h3>Accessing folds</h3>
Instead of keeping a copy of created folds, the FoldManager may call <code>operation.foldIterator</code>. The iterator
will enumerate all folds, including (recursively) blocked ones.

</arch-usecases><api name="CodeFoldingAPI" type="export" category="official" group="java"/></module><module name="Editor Guarded Sections" target="org-netbeans-modules-editor-guards/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Guarded Sections protects user from modifying document content. The main goal is
   to simplify work with such a content to module writers and preserve created
   sections.
  
 </description><deploy-dependencies>
  <p>
   A module using the Guarded Sections API should also require a proper
   implementation. Eg in case of java content add to your module manifest file:
  </p>
       <pre xml:space="preserve">
        OpenIDE-Module-Requires: org.netbeans.api.editor.guards.Java
       </pre>
  <p>
   A module implementing the Guarded Sections SPI should provide a token in
   the manifest file. Eg in case of java content add:
  </p>
       <pre xml:space="preserve">
        OpenIDE-Module-Provides: org.netbeans.api.editor.guards.Java
       </pre>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="AddingNewSection" name="Add new section">
       In order to add a new section after the existing section, which seems to be most frequent, use:
       <pre xml:space="preserve">
        String sectionName = ...;
        StyledDocument doc = ...;
        GuardedSectionManager guards = GuardedSectionManager.getInstance(doc);
        GuardedSection g = guards.findSimpleSection(sectionName);
        guards.createSimpleSection("new_name", doc.createPosition(g.getEndPosition().getOffset() + 1));
       </pre>
   </usecase>
   <usecase id="DeleteSection" name="Delete existing section">
       <pre xml:space="preserve">
        StyledDocument doc = ...;
        GuardedSectionManager guards = GuardedSectionManager.getInstance(doc);
        GuardedSection g = guards.findSimpleSection("sectionName");
        g.deleteSection();
       </pre>
   </usecase>
   <usecase id="PlugSectionsProvider" name="Plug guarded sections stuff into the editor">
       In case you want your <code>CloneableEditorSupport</code> to provide
       guarded sections you should implement the <code>GuardedEditorSupport</code>
       interface.
       <pre xml:space="preserve">
        private final class MyGuardedEditor implements GuardedEditorSupport {
           ...
        }
       </pre>
       Further implement reading and writing of existing sections.
       <pre xml:space="preserve">
        protected void loadFromStreamToKit(StyledDocument doc, InputStream stream, EditorKit kit) throws IOException, BadLocationException {
            if (guardedEditor == null) {
                guardedEditor = new MyGuardedEditor();
                // remember the provider
                String mimeType = ((CloneableEditorSupport.Env) this.env).getMimeType();
                guardedProvider = GuardedSectionsFactory.find(mimeType).create(guardedEditor);
            }

            // load content to kit
            if (guardedProvider != null) {
                guardedEditor.setDocument(doc);
                Charset cs = FileEncodingQuery.getEncoding(this.getDataObject().getPrimaryFile());
                Reader reader = guardedProvider.createGuardedReader(stream, cs);
                try {
                    kit.read(reader, doc, 0);
                } finally {
                    reader.close();
                }
            } else {
                kit.read(stream, doc, 0);
            }
        }

        protected void saveFromKitToStream(StyledDocument doc, EditorKit kit, OutputStream stream) throws IOException, BadLocationException {
            if (guardedProvider != null) {
                Charset cs = FileEncodingQuery.getEncoding(this.getDataObject().getPrimaryFile());
                Writer writer = guardedProvider.createGuardedWriter(stream, cs);
                try {
                    kit.write(writer, doc, 0, doc.getLength());
                } finally {
                    writer.close();
                }
            } else {
                kit.write(stream, doc, 0, doc.getLength());
            }
        }
       </pre>
       Your module should also require a proper implementation. In case of java
       content add to your module manifest file:
       <pre xml:space="preserve">
        OpenIDE-Module-Requires: org.netbeans.api.editor.guards.Java
       </pre>
   </usecase>
  </p>
 </arch-usecases><api name="GuardedSectionsAPI" type="export" category="official" group="java">
   The Guarded Sections module is supposed to operate over the Swing's <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/text/StyledDocument.html" shape="rect"><code>StyledDocument</code></a>.
   It allows clients to manipulate named guarded sections that prevents user to
   modify the content. So if you like to create, modify or delete guarded sections the <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-guards/org/netbeans/api/editor/guards/GuardedSectionManager.html" shape="rect">
   <code>GuardedSectionManager</code></a> is the best place where to start.
   </api><api name="GuardedSectionsSPI" type="export" category="official" group="java">
   The module also allows to implement custom guarded section persistance in various content types like java, xml, ...
   The easiest way is to subclass <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-guards/org/netbeans/spi/editor/guards/support/AbstractGuardedSectionsProvider.html" shape="rect">
   <code>AbstractGuardedSectionsProvider</code></a>.<br/>In order to bind guarded sections to your editor see <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-guards/org/netbeans/spi/editor/guards/GuardedSectionsFactory.html" shape="rect">
   <code>GuardedSectionsFactory</code></a>.
   </api><api name="org.netbeans.api.editor.guards.GuardedSectionManager" type="export" category="private" group="property">
    The <code>GuardedSectionManager</code> instance is physically stored as a property of
    the document with key <code>org.netbeans.api.editor.guards.GuardedSectionManager.class</code>. Modules should not depend on this.
   </api><api name="GuardedSectionsFactory" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-guards/org/netbeans/spi/editor/guards/GuardedSectionsFactory.html" group="lookup">
       Factories of custom providers that implements reading and writing guarded sections
       should be registered under <code>Editors/&lt;mime path&gt;</code>
       in the module layer file. The first one is chosen for the given mime path.
   </api></module><module name="Editor Indentation" target="org-netbeans-modules-editor-indent/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Editor indentation performs reindentation and code beautification of Swing document.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
<h1>
API Usecases
</h1>

<h3>
Fix indentation of a single or multiple lines of a document.
</h3>
<p>
Altghough there are formatting actions already there may be clients
wishing to explicitly fix indentation of e.g. a newly inserted code into a Swing document.
</p>
<p>
The same code is used after inserting a newline into a document.
</p>
The 
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-indent/org/netbeans/modules/editor/indent/api/Indent.html" shape="rect">Indent</a>
is an entry point for performing reindentation. The following code should be used by clients:
<pre xml:space="preserve">
Indent indent = Indent.get(doc);
indent.lock();
try {
    doc.atomicLock();
    try {
        indent.reindent(startOffset, endOffset);
    } finally {
        doc.atomicUnlock();
    }
} finally {
    indent.unlock();
}
</pre>

<h3>
Code beautification of a selected area of a document.
</h3>
<p>
Code beautification should not only fix line indentation but it may also perform
extra changes to code according to formatting rules. For example add newlines
 or additional whitespace or add/remove extra braces etc.
</p>
The 
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-indent/org/netbeans/modules/editor/indent/api/Reformat.html" shape="rect">Reformat</a>
class should be used:
<pre xml:space="preserve">
Reformat reformat = Reformat.get(doc);
reformat.lock();
try {
    doc.atomicLock();
    try {
        reformat.reformat(startOffset, endOffset);
    } finally {
        doc.atomicUnlock();
    }
} finally {
    reformat.unlock();
}
</pre>
 </arch-usecases><api name="EditorIndentationAPI" type="export" category="devel" group="java"/></module><module name="Editor Indentation Support" target="org-netbeans-modules-editor-indent-support/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    This module has not provided an architectural description, sorry.
</description><deploy-dependencies>No answer</deploy-dependencies><arch-usecases>No answer</arch-usecases></module><module name="Editor Library" target="org-netbeans-modules-editor-lib/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The editor library module provides subset of editor functionality independent
on the NetBeans IDE (except few specific standalone classes).

List of the main features:

  Syntax highlighting of java, HTML, XML and other languages.
  Code Completion enables to type a few characters 
        and then display a list of suggestions appropriate
        in the given context that can be then used 
        to automatically complete the expression.
  
  Word Matching enables enables to type the beginning characters
        of a word used elsewhere in the code and then have the editor
        generate the rest of the word.
  
  Abbreviations allow to expand typed text from a few
        predefined characters into a full word or phrase.
  
  Goto Class enables to open a Java file in the Source Editor 
        by typing only the class name.
        The IDE helps to identify the correct package name for the class.
  
  The Fast Import feature enables to quickly add import statements
        for Java classes in the source file.
  
  Goto Declaration feature allows to quickly jump to a declaration
        of a variable under the cursor.
  
  Goto Source allows to open source file containing
        definition of a type that the variable under the cursor is of.
  
  Code folding allows to collapse sections of the code that are
        unimportant to the user at the given time.
        For example in java source the collapsable sections include
        imports section, inner classes, methods and javadocs.
  

</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
No answer
</arch-usecases><api name="EditorHyperlinkSPI" type="export" category="devel" group="java">
    Hyperlink SPI in <code>org.netbeans.lib.editor.hyperlink.spi</code>
    allows the editors for a particular mime-type to respond to the situation
    when a user hovers over the text with a Ctrl key pressed.
</api><api name="EditorLibraryModuleAPI" type="export" category="devel" group="java">
        Editor defines APIs and SPIs both by 
        <ul>
            <li> Providing java classes in public packages for further reuse.
                <br/>
                Most of the classes were created spontaneously (several years ago)
                without fulfilling of the rules imposed on APIs and SPIs
                at the present time.
                <br/>
                There is an ongoing work to revisit the existing classes
                and create stable APIs and SPIs (and possibly extract functionality
                into a submodule where appropriate). However this is a long-term
                task spanning several promotions.
            </li>
            <li> Being sensitive to content of certain directories in xml layer.
            </li>
        </ul>
    </api><api name="DefaultEditorKit.EndOfLineStringProperty" type="export" category="stable" group="property">
        Document property containing line separator that was used when the document content was
        loaded from a <code>java.io.Reader</code> by an <code>EditorKit.read()</code>.
    </api><api name="line-limit" type="export" category="private" group="property">
        Document property that determines the number of characters in the longest line
        determined during the document loading from a reader by the editor kit. 
    </api></module><module name="Editor Library 2" target="org-netbeans-modules-editor-lib2/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>

    The Editor Library 2 module is a set of official APIs and SPIs, designed to 
    replaces the original Editor Library with legacy APIs
    that are not properly structured and do not conform to the rules
    implied on the current NB APIs.



    The APIs currently offered in Editor Library 2 module include:




    <api-ref name="editor-code-generator"/>
    

    <api-ref name="editor-highlighting"/>
    

    <api-ref name="editor-typing-hooks"/>


    <api-ref name="editor-caret"/>


</description><deploy-dependencies>
  Just normal module dependency.
</deploy-dependencies><arch-usecases>
    At the moment the Editor Library 2 module contains distinct APIs/SPIs. They live
    in their own package and the usecases can be found in the packages overview.
    <ul>
    <li>Code Generator SPI -
        <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/codegen/package-summary.html#usecases" shape="rect">org.netbeans.spi.editor.codegen</a>
    </li>
    <li>Highlighting SPI -
        <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/highlighting/package-summary.html#usecases" shape="rect">org.netbeans.spi.editor.highlighting</a>
    </li>
    <li>Typing Hooks SPI -
        <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/typinghooks/package-summary.html#usecases" shape="rect">org.netbeans.spi.editor.typinghooks</a>
    </li>
    <li>Caret API -
        <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/api/editor/caret/package-summary.html#usecases" shape="rect">org.netbeans.api.editor.caret</a>
    </li>
    <li>Caret SPI -
        <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/caret/package-summary.html#usecases" shape="rect">org.netbeans.spi.editor.caret</a>
    </li>
    </ul>
</arch-usecases><api name="editor-code-generator" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/codegen/package-summary.html" group="java">Code Generator SPI</api><api name="editor-highlighting" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/highlighting/package-summary.html" group="java">Highlighting SPI</api><api name="editor-typing-hooks" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/typinghooks/package-summary.html" group="java">Typing Hooks SPI</api><api name="editor-caret" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/api/editor/caret/package-summary.html" group="java">Editor Caret API</api><api name="HighlightsLayerIncludes" type="export" category="official" group="property">
      Defines a regular expression that can be used for filtering out highlighting
      layers used for rendering a text component. If specified, any layer with
      id matching the regular expression <b>will</b> be used for rendering the
      component. By default, when the property is not specified or is <code>null</code>,
      all layers are used. See 
      <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/highlighting/package-summary.html#usecase5" shape="rect">Use case 5.</a>
      for more details.
  </api><api name="HighlightsLayerExcludes" type="export" category="official" group="property">
      Defines a regular expression that can be used for filtering out highlighting
      layers used for rendering a text component. If specified, any layer with
      id matching the regular expression <b>will not</b> be used for rendering the
      component. By default, when the property is not specified or is <code>null</code>,
      all layers are used. See 
      <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-editor-lib2/org/netbeans/spi/editor/highlighting/package-summary.html#usecase5" shape="rect">Use case 5.</a>
      for more details.
  </api></module><module name="MIME Lookup API" target="org-netbeans-modules-editor-mimelookup/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Each editor provides an EditorKit which controls the policy of specific MIME content type.
The policy of content type should be easily registered and found via some lookup mechanism,
that will provide convenient way of using it either for kit provider or base
editor infrastructure.  In addition to this, the policy can be inherited, (e.g. in case of embeded
kits like JSP) and the content types need to be merged in this case. MIME Lookup API should 
provide all mentioned requierements via easy lookup query, so content type policy 
user need not to solve this searching and merging on its own side.
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<usecase id="per-mime-type-operation" name="Per mime-type operation">
Operation of the editor module must be parametrized by the type of the file
being edited. In the past the operation was parametrized by the class
of the editor kit but that did not show up as being useful enough.
<br/>
It is more practical to use a string-based parametrization concretely
the mime-type. Anyone can then easily register an additional functionality
for the editor because it's just enough to know the right mime-type and the type
of the functionality class to be implemented and the xml layer folder
where the class should be registered.
</usecase>

<usecase id="provide-lookup-result" name="Provide list of instances as lookup result">
On the modules' implementation side the registered functionality 
must be retrieved somehow. It's necessary to instantiate the registered objects
and react to module enabling/disabling which can affect validity of the registered objects.
<br/>
As the most convenient solution appears to use
<code>org.openide.util.Lookup</code> allowing to provide
the registered instances as a <code>Lookup.Result</code>
allowing to listen for changes (e.g. caused by the module enabling/disabling).
<br/>
This resulted into creation of <code>class MimeLookup extends Lookup</code> containing
<code>static MimeLookup getMimeLookup(String mimeType)</code>.
</usecase>

<usecase id="nested-mime-types" name="Nested mime-types">
On the lexical level the document can contain nested languages.
<br/>
For example JSP document can contain pieces of java code which can further contain
javadoc comment tokens with nested javadoc language.
<br/>
The nested languages should allow for special settings
such as fonts and colors of nested syntax coloring but even
things like actions that would be active in the nested document section.
<br/>
This resulted into creation of
<code>static Lookup getLookup(MimePath mimePath)</code> method in <code>MimeLookup</code>. 
</usecase>

<usecase id="known-clients-summary" name="Known clients summary">
<b>Fold Manager Factories</b>
<br/>
The editor/fold module expects to find the registered
fold manager factories (<code>org.netbeans.spi.editor.fold.FoldManagerFactory</code> classes).
<br/>
<br/>
<b>Completion Providers</b>
<br/>
The editor/completion module expects to find the registered
completion providers (<code>org.netbeans.spi.editor.completion.CompletionProvider</code> classes).
<br/>
<br/>
<b>Editor Context Menu Actions</b>
<br/>
The editor module expects to find the registered
popup menu actions (<code>javax.swing.Action</code> classes or names of actions
(i.e. value of Action.NAME attribute) present in editor kit e.g. "goto-source").
<br/>
<br/>
<b>Side Bars</b>
<br/>
The editor/lib module expects to find factories for components to be placed on the 
sides of the editor component (<code>org.netbeans.editor.SideBarFactory</code> classes).
<br/>
<br/>
<b>Hyperlink Providers</b>
<br/>
The editor/lib module expects to find hyperlink providers that allow connecting
an open document with some other documents (<code>org.netbeans.lib.editor.hyperlink.spi.HyperlinkProvider</code> classes).
<br/>
<br/>
<b>Code Template Processors</b>
<br/>
The editor/codetemplates module expects to find factories for code template processors
(<code>org.netbeans.lib.editor.codetemplates.spi.CodeTemplateProcessorFactory</code> classes).
<br/>
<br/>
<b>Hints Providers</b>
<br/>
The editor/hints module expects to find editor hints providers
(<code>org.netbeans.modules.editor.hints.spi.HintsProvider</code> classes).
</usecase>

<br/>
<br/>
<br/>
<b>
API Use Cases
</b>
<hr/>

<usecase id="find-class-instances-for-mime-type" name="Find class instances for the given mime-type">

An API method
<p/>
<code>
MimeLookup lookup = MimeLookup.getMimeLookup("text/x-java");
</code>
<p/>
can be used for getting the mime specific lookup. Having this we can lookup class
 or template:
<p/>
<code>
    Object obj = lookup.lookup(LookedUpClass.class);
</code>
<p/>
or
<p/>
<code>
    Lookup.Result result = lookup.lookup(new Lookup.Template(LookedUpClass.class));
</code>
</usecase>

<usecase id="find-embedded-lookup" name="Getting embeded mime-type specific Lookup">
As an example a jsp scriptlet is used. Scriptlet in fact consists of parent "text/x-jsp" mime-type and
embeded "text/x-java" mime-type. To obtain a scriptlet lookup firstly we need to get a MimePath and then
get appropriate lookup:

<p/>
<pre xml:space="preserve">
    MimePath scriptletPath = MimePath.parse("text/x-jsp/text/x-java");
    Lookup lookup = MimeLookup.getLookup(scriptletPath);
</pre>
</usecase>


<br/>
<b>
SPI Use Cases
</b>
<hr/>

<usecase id="mime-lookup-initializer" name="Providing implemented MimeLookupInitializer">
It is the general way of adding mime specific object into the <code>MimeLookup</code>. Implementation of <code>MimeLookupInitializer</code> should be created and
            registered to default lookup via <code>META-INF/services</code> registration.
For details, please look at the simplified 
<code>TestMimeLookupInitializer</code> 
            in <code>mimelookup/test/unit</code> or <code>LayerMimeLookupInitializer</code>.
<b> Usage of MimeLookupInitializer is deprecated, please use MimeDataProvider instead in similar way </b>
</usecase>

</arch-usecases><api name="MimeLookupAPI" type="export" category="official" group="java"/><api name="MimeLookupSPI" type="export" category="official" group="java"/></module><module name="Editor Settings" target="org-netbeans-modules-editor-settings/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>

    The legacy settings system in the editor module is complicated, error prone
    and hard to use. It'd been created spontaneously over the years to support
    immediate needs at that time without paying enough attention to extensibility
    and interoperability. Historically any module providing editor settings needed
    to depend on the whole editor module.


    The main purpose of this project is to define API for editor settings, that
    is lightweight and easily extensible. The API relies on MimeLookup
    to provide a way of registering and looking up settings.
    The aim is NOT to provide an implementation of a storage for editor settings, 
    but to define an interface between this storage and clients 
    like &lt;mime-type&gt; editors, externaleditor, etc.

</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<usecase id="accessing-settings" name="Accessing settings">
<p>
All editor settings are mime type specific and therefore should be retrieved
using <code>MimeLookup</code>. The following example shows how to retrieve
the <code>FontColorSettings</code> for java files and how to get <code>AttributeSet</code>
with coloring attributes for a particular coloring (i.e. in this case the
colors used for highlighting selected text)
</p>
    
<pre xml:space="preserve">
    MimePath mimePath = MimePath.parse("text/x-java");
    FontColorSettings fcs  = (FontColorSettings) MimeLookup.getLookup(mimePath).lookup(FontColorSettings.class);
    AttributeSet coloring = fcs.getFontColors(FontColorNames.SELECTION_COLORING);
</pre>
</usecase>

<usecase id="listening-on-changes" name="Listening on changes">
<p>
If clients need to react on changes in editor settings they can attach <code>LookupListener</code>
to the <code>LookupResult</code> they got for their particular settings class
from <code>MimeLookup</code>. The following example shows how to do it.
</p>

<pre xml:space="preserve">
    MimePath mimePath = MimePath.parse("text/x-java");
    Lookup lookup = MimeLookup.getLookup(mimePath);
    LookupResult result = lookup.lookup(new Lookup.Template(FontColorSettings.class));
    
    result.addLookupListener(new LookupListener() {
        public void resultChanged(LookupEvent ev) {
            //... the client's response to the settings change
        }
    });
</pre>

<p>
The <code>FontColorSettings</code> class implementor is responsible and will create
a new instance of <code>FontColorSettings</code> whenever some coloring will change.
This new instance will be placed in <code>MimeLookup</code> replacing the old one.
</p>
</usecase>

</arch-usecases><api name="EditorSettingsAPI" type="export" category="official" group="java">API</api></module><module name="Editor Settings Storage" target="org-netbeans-modules-editor-settings-storage/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    The module is an implementation of the
    <api-ref name="org.netbeans.modules.editor.settings"/>
    providing a settings storage on the default filesystem.
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<usecase id="new-options-dialog" name="New Options Dialog">
<p>
The friend API provided by this module is used only by the new options dialog. It
is not expected to have any other clients or users. The API gives the options
dialog a read/write access to the editor settings storage allowing it to implement
UI for maintaining the settings.
</p>
</usecase>

<usecase id="defining-a-coloring" name="Defining a coloring">
<p>
Various modules need to provide predefined font a colors for text tokens from
languages they support. An example of such a module is <code>java/editor</code>
which defines colorings for tokens in java files. Defining colorings is as simple
as writing an XML file with the appropriate information. The example below shows
how to do that.
</p>

<pre xml:space="preserve">
&lt;?xml version="1.0"  encoding="UTF-8"?&gt;
&lt;!DOCTYPE fontscolors PUBLIC "-//NetBeans//DTD Editor Fonts and Colors settings 1.1//EN" "http://www.netbeans.org/dtds/EditorFontsColors-1_1.dtd"&gt;

&lt;fontscolors&gt;
    &lt;fontcolor name="mylang-keyword" foreColor="0000CC" default="keyword"&gt;
        &lt;font style="bold" /&gt;
    &lt;/fontcolor&gt;
&lt;/fontscolors&gt;
</pre>

<p>
Please see the
<a href="http://www.netbeans.org/dtds/EditorFontsColors-1_1.dtd" shape="rect">http://www.netbeans.org/dtds/EditorFontsColors-1_1.dtd</a>
for more details.
</p>
</usecase>

<usecase id="defining-a-key-binding" name="Defining a key binding">
<p>
As well as providing predefined colorings modules need to provide predefined
key bindings. This can be accomplished by writing another simple XML file.
</p>

<pre xml:space="preserve">
&lt;?xml version="1.0"  encoding="UTF-8"?&gt;
&lt;!DOCTYPE bindings PUBLIC "-//NetBeans//DTD Editor KeyBindings settings 1.1//EN" "http://www.netbeans.org/dtds/EditorKeyBindings-1_1.dtd"&gt;

&lt;bindings&gt;
    &lt;bind actionName="goto-source" key="O-O"/&gt;
&lt;/bindings&gt;
</pre>

<p>
Please see the
<a href="http://www.netbeans.org/dtds/EditorKeyBindings-1_1.dtd" shape="rect">http://www.netbeans.org/dtds/EditorKeyBindings-1_1.dtd</a>
for more details.
</p>
</usecase>

</arch-usecases><api name="EditorSettingsStorageAPI" type="export" category="friend" group="java"/><api name="EditorFontsColors-1_1.dtd" type="export" category="official" url="http://www.netbeans.org/dtds/EditorFontsColors-1_1.dtd" group="dtd"><code>-//NetBeans//DTD Editor Fonts and Colors settings 1.1//EN</code></api><api name="EditorKeyBindings-1_1.dtd" type="export" category="official" url="http://www.netbeans.org/dtds/EditorKeyBindings-1_1.dtd" group="dtd"><code>-//NetBeans//DTD Editor KeyBindings settings 1.1//EN</code></api><api name="SpecialProfilesAndMimeTypesAPI" type="export" category="friend" group="java"/></module><module name="Editor Utilities" target="org-netbeans-modules-editor-util/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Editor Utilities module contains useful utility classes and methods used
by other editor related modules.
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>

<h3>
GapList
</h3>

<p>
The GapList class is a <code>java.util.List</code> implementation
similar to <code>java.util.ArrayList</code> but containing a gap in its underlying 
array. After a first modification at a particular index
the subsequent modifications around that index are cheap.
<br/>
The class is suitable for storage of any elements related to editing
such as positions, elements, views etc.
</p>

<h3>
PriorityMutex
</h3>

<p>
The PriorityMutex is a simple mutex implementation
allowing to find out that a priority thread (by default Event Dispatch Thread)
is waiting to enter the mutex.
<br/>
It's used e.g. in editor's view hierarchy or in editor fold hierarchy.
</p>

<h3>
GapBranchElement
</h3>

<p>
GapList-based element implementation suitable for line elements
and any other branch element types.
</p>


</arch-usecases><api name="EditorUtilitiesAPI" type="export" category="devel" group="java"/></module><module name="External Execution API" target="org-netbeans-modules-extexecution/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides common APIs to execute external process in the IDE to handle its
   streams and present the output to the user. Input/line processing can be used
   as separate part.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="execute-process" name="Execution of an external process">
   <p>
    Client needs to execute an external process and handle process streams and
    display the output in the output tab.
   </p>
   <p>
    In order to achieve this client creates the
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ExecutionDescriptor.html" shape="rect">ExecutionDescriptor</a>.
    Via this object client configures all the UI behaviour of the subsequent
    execution. As a next step client creates the
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ExecutionService.html" shape="rect">ExecutionService</a>
    itself and calls run to execute the job. Run can be called multiple times.
    The output and input streams are presented in output tab. Additional
    processing and printing conversion can be configured in descriptor through
    interfaces described in following usecases.
   </p>
   <p>
    The creation of the external process is supported by
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ExternalProcessBuilder.html" shape="rect">ExternalProcessBuilder</a>
    to make things easier.
   </p>
  </usecase>
  <usecase id="handle-input" name="Processing the input">
   <p>
    <span style="text-decoration:line-through;">Client needs to process character
    data coming from stream, file or other source.</span> This usecase should 
    be solved by External Execution Base API.
   </p>
   <p>
    To abstract the source of the data client must implement
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/InputReader.html" shape="rect">InputReader</a>.
    To abstract the data processing client must implement
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/InputProcessor.html" shape="rect">InputProcessor</a> or
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/LineProcessor.html" shape="rect">LineProcessor</a>.
    For all three interfaces there are prepared common implementations (and bridge
    from character based to line based processing) at these three factory classes:
   </p>
   <ul>
    <li><a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/InputReaders.html" shape="rect">InputReaders</a></li>
    <li><a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/InputProcessors.html" shape="rect">InputProcessors</a></li>
    <li><a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/LineProcessors.html" shape="rect">LineProcessors</a></li>
   </ul>
   <p>
    To configure additional functionality specific to <code>org.openide.windows.OutputWriter</code>
    see the next usecase.
   </p>
   <p>
    Once the data source and processing objects are prepared client creates
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/InputReaderTask.html" shape="rect">InputReaderTask</a>.
    Factory methods of the <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/InputReaderTask.html" shape="rect">InputReaderTask</a>
    can create either common task exiting on interruption or cancellation
    or draining task which is trying to drain out all available data before exiting.
   </p>
  </usecase>
  <usecase id="print-input" name="Printing the input">
   <p>
    Client intends to process input lines and print them to <code>org.openide.windows.OutputWriter</code>.
    In addition printed lines should be transformed (converted) somehow
    and enriched by line listeners.
   </p>
   <p>
    The both default printing processors provide factory method accepting
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/LineConvertor.html" shape="rect">LineConvertor</a>.
    Namely
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/InputProcessors.html#printing-org.openide.windows.OutputWriter-org.netbeans.api.extexecution.print.LineConvertor-boolean-" shape="rect">
     InputProcessors.printing(org.openide.windows.OutputWriter out, LineConvertor convertor, boolean resetEnabled)</a>
    and
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/LineProcessors.html#printing-org.openide.windows.OutputWriter-org.netbeans.api.extexecution.print.LineConvertor-boolean-" shape="rect">
     LineProcessors.printing(org.openide.windows.OutputWriter out, LineConvertor convertor, boolean resetEnabled)</a>.

    Convertor is then used to convert received lines to printed ones.
    Common convertors (file, http) are provided in factory class
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/LineConvertors.html" shape="rect">LineConvertors</a>.
   </p>
  </usecase>
  <usecase id="process-builder" name="Custom process builder">
    <p>
      <span style="text-decoration:line-through;">Third party wants to implement custom process builder to provide
      additional functionality, such as remote execution.</span>
      This usecase should be solved by External Execution Base API.
    </p>
    <p>
      In order to do so it will implement
      <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/ProcessBuilderImplementation.html" shape="rect">
       ProcessBuilderImplementation</a> and pass
      <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ProcessBuilder.html" shape="rect">
       ProcessBuilder</a> to its clients. The API instances are created with
      help of
      <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/ProcessBuilderFactory.html" shape="rect">ProcessBuilderFactory</a>.
    </p>
  </usecase>
  <usecase id="destroy-process" name="Destroying a process">
    <p>
      <span style="text-decoration:line-through;">Client wants to destroy the process, trying to kill whole process tree.</span>
      This usecase should be solved by External Execution Base API.
      Method
      <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ExternalProcessSupport.html#destroy-java.lang.Process-java.util.Map-" shape="rect">
       ExternalProcessSupport.destroy(java.lang.Process process, Map&lt;String,String&gt; env)</a>
      is designed for that. It will use a
      <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/destroy/ProcessDestroyPerformer.html" shape="rect">ProcessDestroyPerformer</a>
      registered in default lookup to do so.
    </p>
  </usecase>
  <usecase id="startup-extender" name="Extending startup environment">
   <p>
    The third party plugin may want to be able provide additional arguments
    for the process startup in a standardized way. In order to do so it will
    register a implementation of
    <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/startup/StartupExtenderImplementation.html" shape="rect">StartupExtenderImplementation</a>
    to the layer folder StartupExtender. The annotation
    <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/startup/StartupExtenderImplementation.Registration.html" shape="rect">StartupExtenderImplementation.Registration</a>
    can be used for that.
   </p>
   <p>
    The clients (for exmaple project or server) may query the extenders via the
    API class
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/startup/StartupExtender.html" shape="rect">StartupExtender</a>
    and use the additional arguments for the process.
   </p>
  </usecase>
  <usecase id="pluggable-open" name="Making certain open actions pluggable">
   <p>
    Some default
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/LineConvertor.html" shape="rect">LineConvertor</a>s
    returned by
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/LineConvertors.html" shape="rect">LineConvertor</a>
    needs to open file or URL. A bit special case is also options dialog opening
    required by
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ExecutionService.html" shape="rect">ExecutionService</a>
    to open options dialog specified by
    <a href="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/ExecutionDescriptor.html" shape="rect">ExecutionDescriptor</a>.
    To cover this three usecases in a pluggable way while keeping dependencies
    minimal there are three corresponding SPI classes one may implement.
    So there is
    <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/open/FileOpenHandler.html" shape="rect">FileOpenHandler</a>
    to handle file opening,
    <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/open/HttpOpenHandler.html" shape="rect">HttpOpenHandler</a>
    to deal with HTTP URLs and
    <a href="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/open/OptionOpenHandler.html" shape="rect">OptionOpenHandler</a>
    to open proper options dialog.
   </p>
  </usecase>
 </arch-usecases><api name="ExternalExecutionAPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/package-summary.html" group="java"/><api name="ExternalExecutionInputAPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/input/package-summary.html" group="java"/><api name="ExternalExecutionInputPrintingAPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/print/package-summary.html" group="java"/><api name="ExternalExecutionSPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/package-summary.html" group="java"/><api name="ExternalExecutionDestroySPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/destroy/package-summary.html" group="java"/><api name="ExternalExecutionOpenSPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/open/package-summary.html" group="java"/><api name="ExternalExecutionStartupAPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/api/extexecution/startup/package-summary.html" group="java"/><api name="ExternalExecutionStartupSPI" type="export" category="stable" url="org-netbeans-modules-extexecution/org/netbeans/spi/extexecution/startup/package-summary.html" group="java"/></module><module name="Java EE Metadata" target="org-netbeans-modules-j2ee-metadata/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The project provides a generic framework for accessing Java EE metadata models.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="metadata-access" name="Accessing metadata models">
   <p>
    A module wishing to access Java EE metadata obtains a metadata model, which is encapsulated
    by the <a href="org-netbeans-modules-j2ee-metadata/org/netbeans/modules/j2ee/metadata/model/api/MetadataModel.html" shape="rect">MetadataModel</a>
    class. The client then implements a model action, represented by the 
    <a href="org-netbeans-modules-j2ee-metadata/org/netbeans/modules/j2ee/metadata/model/api/MetadataModelAction.html" shape="rect">MetadataModelAction</a> class,
    and executes this action in the model context by calling the model's 
    <a href="org-netbeans-modules-j2ee-metadata/org/netbeans/modules/j2ee/metadata/model/api/MetadataModel.html#runReadAction-org.netbeans.modules.j2ee.metadata.model.api.MetadataModelAction-" shape="rect">runReadAction()</a>
    method:
   </p>
   <pre xml:space="preserve">
    MetadataModel&lt;SomeMetadata&gt; model = // ...
    String result = model.runReadAction(new MetadataModelAction&lt;SomeMetadata, String&gt;() {
        public String run(SomeMetadata metadata) {
            // ... do something with metadata, e.g.
            // compute a String value
            return value;
        }
    }
   </pre>
   <p>
    The way to obtain the model itself, as well as the kinds of metadata encapsulated by <code>MetadataModel</code> is 
    metadata and metadata provider-specific and is not addressed by this API.
   </p>
  </usecase>
  <usecase id="providing-metadata" name="Providing metadata models">
   <p>
    A metadata provider first defines a root class describing the metadata, e.g., <code>SomeMetadata</code>. Then the provider
    implements the <a href="org-netbeans-modules-j2ee-metadata/org/netbeans/modules/j2ee/metadata/model/spi/MetadataModelImplementation.html" shape="rect">MetadataModelImplementation</a> interface and
    creates a <code>MetadataModel</code> using <a href="org-netbeans-modules-j2ee-metadata/org/netbeans/modules/j2ee/metadata/model/spi/MetadataModelFactory.html" shape="rect">MetadataModelFactory</a>.
    Then the provider defines a way to return the model to its clients:
   </p>
   <pre xml:space="preserve">
    private SomeMetadataModelImplementation modelImpl = new SomeMetadataModelImplementation();
    private MetadataModel&lt;SomeMetadata&gt; model = MetadataModelFactory.createMetadataModel(modelImpl);

    /**
     * Call this to retrieve the model of some metadata.
     */
    public MetadataModel&lt;SomeMetadata&gt; getSomeMetadataModel() {
        return model;
    }

    // ... 

    private class SomeMetadataModelImplementation implements MetadataModelImplementation&lt;SomeMetadata&gt; {

        // ...

    }
   </pre>
  </usecase>
  <usecase id="providing-multiple-metadata" name="Providing multiple metadata models">
   <p>
    A metadata provider might need to provide several kinds of metadata models at once. Furthermore, since there
    can be many models available or for backward compatibility reasons it might be impractical to provide 
    a method for each of the models. In this case the provider may define a method like:
   </p>
   <pre xml:space="preserve">
    public MetadataModel&lt;T&gt; getMetadataModel(Class&lt;T&gt; clazz) {
        // ...
    }
   </pre>
   <p>
    The types of <code>Class</code> which may be passed to the method is a part of the contract between
    the provider and its clients.
   </p>
  </usecase>
 </arch-usecases><api name="GenericJavaEEMetadataModelAPI" type="export" category="devel" url="org-netbeans-modules-j2ee-metadata/index.html" group="java"/></module><module name="Java Common Project API" target="org-netbeans-modules-java-api-common/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    This module has not provided an architectural description, sorry.
</description><deploy-dependencies>No answer</deploy-dependencies><arch-usecases>No answer</arch-usecases></module><module name="Java Hints Test API" target="org-netbeans-modules-java-hints-test/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="java.hints.test" type="export" category="devel" group="java">
       API to create tests for the custom Java hints.
   </api></module><module name="Java SE Projects" target="org-netbeans-modules-java-j2seproject/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides a project type for plain Java projects. J2SE projects can be created
   from scratch, or you can import existing Java source trees. Creates an Ant
   script letting you build the project (and subprojects), run it, debug it, run
   JUnit-format tests, and build Javadoc. GUI customizer permits easy
   customization of the most commonly needed project parameters. Provides code
   completion and other services for editing Java sources. Classpaths can include
   other projects, raw JARs, or configured libraries. Specific J2SE platforms may
   be configured. 
   
  
 </description><deploy-dependencies>
  <p>
   N/A
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   Covered by UI specification and design document.
  </p>
 </arch-usecases><api name="j2se-project.xsd" type="export" category="official" url="http://www.netbeans.org/ns/j2se-project/1.xsd" group="dtd">
     <p>
      Definition of j2seproject-specific portions of <code>project.xml</code> (1st revision).
     </p>
    </api><api name="j2se-project-2.xsd" type="export" category="official" url="http://www.netbeans.org/ns/j2se-project/2.xsd" group="dtd">
     <p>
      Definition of j2seproject-specific portions of <code>project.xml</code> (2nd revision).
     </p>
    </api><api name="project.properties" type="export" category="devel" group="java.io.File">
     <p>
      Definition of recognized keys in <code>project.properties</code> and/or
      <code>private.properties</code>. XXX not yet formally specified.
     </p>
    </api><api name="build-impl.xml" type="export" category="devel" group="java.io.File">
     <p>
      Definition of targets in <code>build-impl.xml</code> which may be called or
      overridden in <code>build.xml</code>. XXX not yet formally specified.
     </p>
    </api><api name="J2SEPropertyEvaluator" type="export" category="friend" group="java">
     <p>
      Module provides public package <code>org.netbeans.modules.java.j2seproject.api</code> with 
      interface for resolving values of project properties defined in project.properties and private.properties files.
     </p>
    </api><api name="j2seproject.transparentUpdate" type="export" category="private" group="systemproperty">
    If the property is set to <code>true</code> the project updates metadata of <code>project.xml</code> from
    the namespace <code>http://www.netbeans.org/ns/j2se-project/1</code> to
    <code>http://www.netbeans.org/ns/j2se-project/2</code> without explicit user confirmation.
   </api><api name="J2SEProjectCustomizer" type="export" category="official" group="layer">
     <p>
       "Projects/org-netbeans-modules-java-j2seproject/Customizer" folder's content is used to construct the project's customizer.
       It's content is expected to be <code>ProjectCustomizer.CompositeCategoryProvider</code> instances.
       The lookup passed to the panels contains an instance of <code>Project</code> and <code>org.netbeans.modules.java.j2seproject.ui.customizer.J2SEProjectProperties</code>
       Please note that the latter is not part of any public APIs and you need implementation dependency to make use of it.
     </p>
    </api><api name="J2SELogicalViewProvider" type="export" category="official" group="layer">
     <p>
       "Projects/org-netbeans-modules-java-j2seproject/Nodes" folder's content is used to construct the project's child nodes.
       It's content is expected to be <code>NodeFactory</code> instances.
     </p>
    </api><api name="J2SELookup" type="export" category="official" group="layer">
     <p>
       "Projects/org-netbeans-modules-java-j2seproject/Lookup" folder's content is used to construct the project's additional lookup.
       It's content is expected to be <code>LookupProvider</code> instances. J2SE project provides <code>LookupMerger</code>s 
       for <code>Sources</code>, <code>PrivilegedTemplates</code> and <code>RecommendedTemplates</code>. Implementations added by 3rd parties 
       will be merged into a single instance in the project's lookup.
     </p>
    </api></module><module name="Java Platform" target="org-netbeans-modules-java-platform/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Many Java-based project types need to be able to configure the version and
   location of Java to be used when building and running the project. This
   API/SPI permits these platforms to be registered and queried, and any
   customizations made in an appropriate GUI and persisted to disk.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The API can be used by any code wishing to know the list of installed
   platforms and information about each one; typically this would be used by
   project type providers to implement a customizer dialog. The SPI is intended
   to be implemented by a few modules supply support for locating and
   introspecting installed platforms, for example a JDK setup wizard.
  </p>
 </arch-usecases><api name="JavaPlatformAPI" type="export" category="official" group="java">
   The Java Platform API permits access to installed Java platforms (for example,
   the J2SE JDK, or various mobile-device emulators for J2ME). Particular platform
   types are registered by modules and can store customized information about the
   platform to disk. <br/>
   <b>Note</b> that this module concentrates the part of th API which is independent of
   the client desktop (and Swing UI library) environment. Its desktop-dependent counterpart
   is in the <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-java-platform-ui/index.html" shape="rect">
   org.netbeans.modules.java.platform.ui</a> module.
  </api></module><module name="Java Platform UI" target="org-netbeans-modules-java-platform-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Many Java-based project types need to be able to configure the version and
   location of Java to be used when building and running the project. This
   API/SPI permits these platforms to be registered and queried, and any
   customizations made in an appropriate GUI and persisted to disk.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The API can be used by any code wishing to know the list of installed
   platforms and information about each one; typically this would be used by
   project type providers to implement a customizer dialog. The SPI is intended
   to be implemented by a few modules supply support for locating and
   introspecting installed platforms, for example a JDK setup wizard.
  </p>
 </arch-usecases><api name="JavaPlatformUI" type="export" category="official" group="java">
   The Java Platform API permits access to installed Java platforms (for example,
   the J2SE JDK, or various mobile-device emulators for J2ME). Particular platform
   types are registered by modules and can store customized information about the
   platform to disk. <br/>
   <b>Note</b> that this module concentrates the UI part of API. Its desktop-independent counterpart
   is in the <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-java-platform/index.html" shape="rect">
   org.netbeans.modules.java.platform</a> module.
  </api></module><module name="Java Project Support" target="org-netbeans-modules-java-project/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides support infrastructure for projects working with the Java language.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   Project type providers wishing to show Java packages in their logical views
   can use this SPI. Templates which are Java-centric can use it. Projects which
   wish to implement queries from the Java Support APIs can place implementations
   in their lookup and these will be delegated to automatically.
  </p>
 </arch-usecases><api name="JavaProjectAPI" type="export" category="official" group="java">
   <p>
   The Java Project API is actually entirely SPI and supplies useful
   implementations of Java-related functionality specific to the project system.
    </p>
  </api><api name="ProjectClassPathExtender" type="export" category="devel" group="java">
   <p>
    Implemented by <code>java/j2seproject</code> and asked for by
    <code>form</code>. Permits the Form Editor to add JavaBeans archives to the
    classpath of a J2SE project automatically.
   </p>
  </api><api name="ProjectClassPathSupport" type="export" category="devel" group="java">
   <p>
      Support class containg helper method for creating <code>ClassPathImplementation</code> based on Ant
      properties.
   </p>
  </api><api name="org.netbeans.spi.java.project.support.ui.packageView.TRUNCATE_PACKAGE_NAMES" type="export" category="private" group="systemproperty">
     <p>
      If set to <code>true</code>, displays a truncated version of Java package
      names, usually in the <b>Projects</b> tab.
     </p>
    </api><api name="logger.max.line.length" type="export" category="private" group="systemproperty">
     <p>
      If a longer message is logged the ant logger will handle the message as plain text and will not try to hyperlink, color, fold, etc. 
      If not set by the user a default value of <b>3000</b> will be used.
     </p>
    </api></module><module name="Java Project Support UI" target="org-netbeans-modules-java-project-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides support infrastructure for projects working with the Java language.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   Project type providers wishing to show Java packages in their logical views
   can use this SPI. Templates which are Java-centric can use it. Projects which
   wish to implement queries from the Java Support APIs can place implementations
   in their lookup and these will be delegated to automatically.
  </p>
 </arch-usecases><api name="JavaProjectUI" type="export" category="official" group="java">
   <p>
   The Java Project API is actually entirely SPI and supplies useful
   implementations of Java-related functionality specific to the project system. This module
   focuses on Swing UI components.
    </p>
  </api><api name="org.netbeans.spi.java.project.support.ui.packageView.TRUNCATE_PACKAGE_NAMES" type="export" category="private" group="systemproperty">
     <p>
      If set to <code>true</code>, displays a truncated version of Java package
      names, usually in the <b>Projects</b> tab.
     </p>
    </api><api name="logger.max.line.length" type="export" category="private" group="systemproperty">
     <p>
      If a longer message is logged the ant logger will handle the message as plain text and will not try to hyperlink, color, fold, etc. 
      If not set by the user a default value of <b>3000</b> will be used.
     </p>
    </api><api name="JavaPackageChooser" type="export" category="friend" group="java">
      Templatesui module is using reflection to access 
      <code>JavaTemplates</code> class from this module
      in order to
      create Java-like package chooser.
  </api></module><module name="Java Source" target="org-netbeans-modules-java-source/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="ensure.built.source.roots" type="export" category="devel" group="systemproperty">
       When the <code>ensure.built.source.roots</code> property is set during ant script execution,
       the <code>javac</code> task will not actually build the classfiles from scratch, but rather copy classfiles
       produced by the Java infrastructure into the output folder. The content of the property will
       be interpreted as list of source roots, for which the artifacts should be copied.
   </api><api name="org.openide.loaders.CreateFromTemplateAttributesProvider" type="export" category="official" group="lookup">
       Attributes provider is registered in <code>META-INF/services</code>. It provides
       <code>package</code>, <code>javaSourceLevel</code> and <code>java15style</code> attributes for java templates using scripting support.
     </api><api name="package" type="export" category="official" group="property">
       <code>package</code> attribute contains java package as <code>String</code> for newly created
       templates using scripting.
     </api><api name="javaSourceLevel" type="export" category="official" group="property">
       <code>javaSourceLevel</code> attribute contains java source level as <code>String</code> (e.g. "1.5") for newly created
       templates using scripting.
     </api><api name="java15style" type="export" category="official" group="property">
       <code>java15style</code> attribute is defined for newly created
       templates using scripting only if java source level is 1.5 or later.
       Useful to conditionally generate code with java 1.5 features (generics, annotations, etc.).
     </api></module><module name="Java Source Base" target="org-netbeans-modules-java-source-base/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="JavaSourceAPI" type="export" category="official" group="java">
       When the <code>ensure.built.source.roots</code> property is set during ant script execution,
       the <code>javac</code> task will not actually build the classfiles from scratch, but rather copy classfiles
       produced by the Java infrastructure into the output folder. The content of the property will
       be interpreted as list of source roots, for which the artifacts should be copied.
   </api><api name="JavaSourceAPI" type="export" category="official" url="org-netbeans-modules-java-source-base/index.html" group="java"/><api name="org.openide.loaders.CreateFromTemplateAttributesProvider" type="export" category="official" group="lookup">
       Attributes provider is registered in <code>META-INF/services</code>. It provides
       <code>package</code>, <code>javaSourceLevel</code> and <code>java15style</code> attributes for java templates using scripting support.
     </api><api name="package" type="export" category="official" group="property">
       <code>package</code> attribute contains java package as <code>String</code> for newly created
       templates using scripting.
     </api><api name="javaSourceLevel" type="export" category="official" group="property">
       <code>javaSourceLevel</code> attribute contains java source level as <code>String</code> (e.g. "1.5") for newly created
       templates using scripting.
     </api><api name="java15style" type="export" category="official" group="property">
       <code>java15style</code> attribute is defined for newly created
       templates using scripting only if java source level is 1.5 or later.
       Useful to conditionally generate code with java 1.5 features (generics, annotations, etc.).
     </api></module><module name="Java Source UI" target="org-netbeans-modules-java-sourceui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   <api-ref name="java.sourceui"/>
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="java.sourceui" type="export" category="official" group="java">
   APIs for controling visual aspects of processing of Java files.
   </api></module><module name="JavaHelp Integration" target="org-netbeans-modules-javahelp/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        The JavaHelp integration API wraps the standard JavaHelp extension
        library. It also provides a small additional API for NetBeans modules to
        supply help sets to the system, add GUI menu items, and request that
        particular help topics be displayed.
        <api-ref name="JavaHelpIntegrationAPI"/>
    </description><api name="JavaHelpIntegrationAPI" type="export" category="official" url="org-netbeans-modules-javahelp/index.html" group="java"/><api name="OpenIDE-mergeIntoMaster" type="export" category="official" group="property">
                    The context and key <code>OpenIDE/mergeIntoMaster</code> can be set as an attribute on a help set
                    provided programmatically rather than with an XML file to
                    customize one attribute. Such programmatic provision is rare
                    but supported.
                </api><api name="javahelp.ignore.modality" type="export" category="friend" group="property">
                     The help window through JDK 1.5.0 handles modal dialogs by reparenting the help 
                     component into a child dialog of any new modal dialog whenever it is shown, and 
                     reparenting it back into a frame whenever it is hidden.  Under certain circumstances
                     (showing two dialogs sequentially before the frame can be re-shown), it can produce
                     a race condition in the underlying java.awt.Toolkit implementation.  As a workaround,
                     callers of DialogDisplayer.getDefault().notify(DialogDescriptor) may set the system
                     property "javahelp.ignore.modality" to the String "true".  This system property will
                     be reset by notify(), and applied as a client property of the root pane of the dialog
                     to be shown.  JavaHelp will, in turn, ignore the appearance of any dialog whose root
                     pane posesses the client property "javahelp.ignore.modality" with the String value
                     "true".
                </api><api name="ObjectTag" type="export" category="friend" url="org-netbeans-modules-javahelp/overview-summary.html" group="dtd">
                </api></module><module name="Jelly Tools IDE" target="org-netbeans-modules-jellytools-ide/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    This module has not provided an architectural description, sorry.
</description><deploy-dependencies>No answer</deploy-dependencies><arch-usecases>No answer</arch-usecases></module><module name="Jelly Tools Platform" target="org-netbeans-modules-jellytools-platform/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    This module has not provided an architectural description, sorry.
</description><deploy-dependencies>No answer</deploy-dependencies><arch-usecases>No answer</arch-usecases></module><module name="JUnit Tests" target="org-netbeans-modules-junit/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The module makes creating, running and navigation between tests easier.
   (Actual test running is typically performed directly by a
   project type provider using Ant.)
  
 </description><deploy-dependencies>
  <p>
Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
     <p>
        The SPI allows to plug a project-type-specific implementation of JUnit
        support into NetBeans. The current NetBeans implementation only supports
        JUnit on J2SE project types. The SPI describes services provided by the
        custom JUnit support plugin.
     </p>
     <p>
        The functionality to be plugged in comprises:
     </p>
     <ul>
        <li>generation of test skeletons</li>
        <li>navigation between source classes and corresponding test
            classes</li>
     </ul>
     <p>
        For navigation, the plugin defines mapping between source classes and
        the corresponding test classes (both directions). Thus it provides
        an additional information to the information provides by
        <code>UnitTestForSourceQuery</code>
     </p>
     <p>
         For generation of test skeletons, the plugin actually defines the whole
         test skeleton generator - it generates one or more test files for
         a given source file.
     </p>
</arch-usecases><api name="org.netbeans.modules.junit.plugin" type="export" category="devel" group="java">
            This SPI describes services provided by the
            custom JUnit support plugin which are not desribed by the existing
            public SPI (<code>UnitTestForSourceQuery</code>). This SPI
            represents an additional source of information for the JUnit module
            and allows a custom test-skeleton generator to be plugged.
        </api><api name="JUnit-plugin-lookup" type="export" category="devel" url="org/netbeans/modules/junit/plugin/JUnitPlugin.html" group="lookup">
            The object implementing the <code>JUnitPlugin</code> interface
            is taken by the JUnit module from the current project's lookup,
            the same way as the <code>UnitTestForSourceQuery</code>.
        </api></module><module name="Keyring API" target="org-netbeans-modules-keyring/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="Keyring-API" type="export" category="official" group="java">
         Other modules can access the keyring, or add implementations.
     </api></module><module name="Lexer" target="org-netbeans-modules-lexer/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Lexer module provides token lists for various
text inputs. Token lists can either be flat or they can form
tree token hierarchies if any language embedding is present.
Tokens
</description><deploy-dependencies>
<pre xml:space="preserve">
OpenIDE-Module-Module-Dependencies: org.netbeans.modules.lexer/2 &gt; @SPECIFICATION-VERSION@
</pre>
</deploy-dependencies><arch-usecases>

<!-- API Usecases - API Usecases - API Usecases - API Usecases - API Usecases -->

<h1>
API Usecases
</h1>

<h3>
Obtaining of token hierarchy for various inputs.
</h3>
The
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenHierarchy.html" shape="rect">TokenHierarchy</a>
is an entry point into Lexer API
and it represents the given input in terms of tokens.
<pre xml:space="preserve">
    String text = "public void m() { }";
    TokenHierarchy hi = TokenHierarchy.create(text, JavaLanguage.description());
</pre>

<br/>
Token hierarchy for swing documents must be operated under read/write document's lock.
<pre xml:space="preserve">
    document.readLock();
    try {
        TokenHierarchy hi = TokenHierarchy.get(document);
        ... // explore tokens etc.
    } finally {
        document.readUnlock();
    }
</pre>


<h3>
Obtaining and iterating token sequence over particular swing document from the given offset.
</h3>
The tokens cover the whole document and it's possible to iterate either forward or backward.
<br/>
Each token can contain language embedding that can also be explored by the token sequence.
The language embedding covers the whole text of the token (there can be few characters
skipped at the begining an end of the branch token).

<pre xml:space="preserve">
    document.readLock();
    try {
        TokenHierarchy hi = TokenHierarchy.get(document);
        TokenSequence ts = hi.tokenSequence();
        // If necessary move ts to the requested offset
        ts.move(offset);
        while (ts.moveNext()) {
            Token t = ts.token();
            if (t.id() == ...) { ... }
            if (TokenUtilities.equals(t.text(), "mytext")) { ... }
            if (ts.offset() == ...) { ... }

            // Possibly retrieve embedded token sequence
            TokenSequence embedded = ts.embedded();
            if (embedded != null) { // Token has a valid language embedding
                ...
            }
        }
    } finally {
        document.readUnlock();
    }
</pre>

<br/>
Typical clients:
<ul>
    <li>Editor's painting code doing syntax coloring
        <code>org.netbeans.modules.lexer.editorbridge.LexerLayer</code> in <i>lexer/editorbridge</i> module.
    </li>  
    <li>Brace matching code searching for matching brace in forward/backward direction.</li>
    <li>Code completion's quick check whether caret is located inside comment token.</li>
    <li>Parser constructing a parse tree iterating through the tokens in forward direction.</li>
</ul>

<h3>
Using language path of the token sequence
</h3>
For the given token sequence the client may check whether it's a top level
token sequence in the token hierarchy or whether it's embedded at which level
it's embedded and what are the parent languages.
<br/>
Each token can contain language embedding that can also be explored by the token sequence.
The language embedding covers the whole text of the token (there can be few characters
skipped at the begining an end of the branch token).

<pre xml:space="preserve">
    TokenSequence ts = ...
    LanguagePath lp = ts.languagePath();
    if (lp.size() &gt; 1) { ... } // This is embedded token sequence
    if (lp.topLanguage() == JavaLanguage.description()) { ... } // top-level language of the token hierarchy
    String mimePath = lp.mimePath();
    Object setting-value = some-settings.getSetting(mimePath, setting-name);
</pre>


<h3>
Extra information about the input
</h3>
The
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/InputAttributes.html" shape="rect">InputAttributes</a>
class may carry extra information about the text input on which the token hierarchy
is being created. For example there can be information about the version of the language
that the input represents and the lexer may be written to recognize multiple versions
of the language. It should suffice to do the versioning through a simple integer:
<pre xml:space="preserve">
public class MyLexer implements Lexer&lt;MyTokenId&gt; {
    
    private final int version;
    
    ...
    
    public MyLexer(LexerInput input, TokenFactory&lt;MyTokenId&gt; tokenFactory, Object state,
    LanguagePath languagePath, InputAttributes inputAttributes) {
        ...
        
        Integer ver = (inputAttributes != null)
                ? (Integer)inputAttributes.getValue(languagePath, "version")
                : null;
        this.version = (ver != null) ? ver.intValue() : 1; // Use version 1 if not specified explicitly
    }
    
    public Token&lt;MyTokenId&gt; nextToken() {
        ...
        if (recognized-assert-keyword) {
            return (version &gt;= 4) { // "assert" recognized as keyword since version 4
                ? keyword(MyTokenId.ASSERT)
                : identifier();
        }
        ...
    }
    ...
}
</pre>

The client will then use the following code:
<pre xml:space="preserve">
    InputAttributes attrs = new InputAttributes();
    // The "true" means global value i.e. for any occurrence of the MyLanguage including embeddings
    attrs.setValue(MyLanguage.description(), "version", Integer.valueOf(3), true);
    TokenHierarchy hi = TokenHierarchy.create(text, false, SimpleLanguage.description(), null, attrs);
    ...
</pre>


<h3>
Filtering out unnecessary tokens
</h3>
Filtering is only possible for immutable inputs (e.g. String or Reader).
<pre xml:space="preserve">
    Set&lt;MyTokenId&gt; skipIds = EnumSet.of(MyTokenId.COMMENT, MyTokenId.WHITESPACE);
    TokenHierarchy tokenHierarchy = TokenHierarchy.create(inputText, false,
        MyLanguage.description(), skipIds, null);
    ...
</pre>

<br/>
Typical clients:
<ul>
    <li>Parser constructing a parse tree. It is not interested
        in the comment and whitespace tokens so these tokens do not need
        to be constructed at all.
    </li>
</ul>


<!-- SPI Usecases - SPI Usecases - SPI Usecases - SPI Usecases - SPI Usecases -->

<h1>
SPI Usecases
</h1>

<h3>
Providing language description and lexer.
</h3>

Token ids should be defined as enums. For example
<code>org.netbeans.lib.lexer.test.simple.SimpleTokenId</code> can be copied
or the following example from
<code>org.netbeans.modules.lexer.editorbridge.calc.lang.CalcTokenId</code>.
<br/>
The static <code>language()</code> method returns the language describing the token ids.
<pre xml:space="preserve">
public enum CalcTokenId implements TokenId {

    WHITESPACE(null, "whitespace"),
    SL_COMMENT(null, "comment"),
    ML_COMMENT(null, "comment"),
    E("e", "keyword"),
    PI("pi", "keyword"),
    IDENTIFIER(null, null),
    INT_LITERAL(null, "number"),
    FLOAT_LITERAL(null, "number"),
    PLUS("+", "operator"),
    MINUS("-", "operator"),
    STAR("*", "operator"),
    SLASH("/", "operator"),
    LPAREN("(", "separator"),
    RPAREN(")", "separator"),
    ERROR(null, "error"),
    ML_COMMENT_INCOMPLETE(null, "comment");


    private final String fixedText;

    private final String primaryCategory;

    private CalcTokenId(String fixedText, String primaryCategory) {
        this.fixedText = fixedText;
        this.primaryCategory = primaryCategory;
    }
    
    public String fixedText() {
        return fixedText;
    }

    public String primaryCategory() {
        return primaryCategory;
    }

    private static final Language&lt;CalcTokenId&gt; language = new LanguageHierarchy&lt;CalcTokenId&gt;() {
        <code>@Override</code>
        protected Collection&lt;CalcTokenId&gt; createTokenIds() {
            return EnumSet.allOf(CalcTokenId.class);
        }
        
        <code>@Override</code>
        protected Map&lt;String,Collection&lt;CalcTokenId&gt;&gt; createTokenCategories() {
            Map&lt;String,Collection&lt;CalcTokenId&gt;&gt; cats = new HashMap&lt;String,Collection&lt;CalcTokenId&gt;&gt;();

            // Incomplete literals 
            cats.put("incomplete", EnumSet.of(CalcTokenId.ML_COMMENT_INCOMPLETE));
            // Additional literals being a lexical error
            cats.put("error", EnumSet.of(CalcTokenId.ML_COMMENT_INCOMPLETE));
            
            return cats;
        }

        <code>@Override</code>
        protected Lexer&lt;CalcTokenId&gt; createLexer(LexerRestartInfo&lt;CalcTokenId&gt; info) {
            return new CalcLexer(info);
        }

        <code>@Override</code>
        protected String mimeType() {
            return "text/x-calc";
        }
        
    }.language();

    public static final Language&lt;CalcTokenId&gt; language() {
        return language;
    }

}
</pre>

Note that it is not needed to publish the underlying <code>LanguageHierarchy</code> extension.

<br/>
Lexer example:
<pre xml:space="preserve">
public final class CalcLexer implements Lexer&lt;CalcTokenId&gt; {

    private static final int EOF = LexerInput.EOF;

    private static final Map&lt;String,CalcTokenId&gt; keywords = new HashMap&lt;String,CalcTokenId&gt;();
    static {
        keywords.put(CalcTokenId.E.fixedText(), CalcTokenId.E);
        keywords.put(CalcTokenId.PI.fixedText(), CalcTokenId.PI);
    }
    
    private LexerInput input;
    
    private TokenFactory&lt;CalcTokenId&gt; tokenFactory;

    CalcLexer(LexerRestartInfo&lt;CalcTokenId&gt; info) {
        this.input = info.input();
        this.tokenFactory = info.tokenFactory();
        assert (info.state() == null); // passed argument always null
    }
    
    public Token&lt;CalcTokenId&gt; nextToken() {
        while (true) {
            int ch = input.read();
            switch (ch) {
                case '+':
                    return token(CalcTokenId.PLUS);

                case '-':
                    return token(CalcTokenId.MINUS);

                case '*':
                    return token(CalcTokenId.STAR);

                case '/':
                    switch (input.read()) {
                        case '/': // in single-line comment
                            while (true)
                                switch (input.read()) {
                                    case '\r': input.consumeNewline();
                                    case '\n':
                                    case EOF:
                                        return token(CalcTokenId.SL_COMMENT);
                                }
                        case '*': // in multi-line comment
                            while (true) {
                                ch = input.read();
                                while (ch == '*') {
                                    ch = input.read();
                                    if (ch == '/')
                                        return token(CalcTokenId.ML_COMMENT);
                                    else if (ch == EOF)
                                        return token(CalcTokenId.ML_COMMENT_INCOMPLETE);
                                }
                                if (ch == EOF)
                                    return token(CalcTokenId.ML_COMMENT_INCOMPLETE);
                            }
                    }
                    input.backup(1);
                    return token(CalcTokenId.SLASH);

                case '(':
                    return token(CalcTokenId.LPAREN);

                case ')':
                    return token(CalcTokenId.RPAREN);

                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                case '.':
                    return finishIntOrFloatLiteral(ch);

                case EOF:
                    return null;

                default:
                    if (Character.isWhitespace((char)ch)) {
                        ch = input.read();
                        while (ch != EOF &amp;&amp; Character.isWhitespace((char)ch)) {
                            ch = input.read();
                        }
                        input.backup(1);
                        return token(CalcTokenId.WHITESPACE);
                    }

                    if (Character.isLetter((char)ch)) { // identifier or keyword
                        while (true) {
                            if (ch == EOF || !Character.isLetter((char)ch)) {
                                input.backup(1); // backup the extra char (or EOF)
                                // Check for keywords
                                CalcTokenId id = keywords.get(input.readText());
                                if (id == null) {
                                    id = CalcTokenId.IDENTIFIER;
                                }
                                return token(id);
                            }
                            ch = input.read(); // read next char
                        }
                    }

                    return token(CalcTokenId.ERROR);
            }
        }
    }

    public Object state() {
        return null;
    }

    private Token&lt;CalcTokenId&gt; finishIntOrFloatLiteral(int ch) {
        boolean floatLiteral = false;
        boolean inExponent = false;
        while (true) {
            switch (ch) {
                case '.':
                    if (floatLiteral) {
                        return token(CalcTokenId.FLOAT_LITERAL);
                    } else {
                        floatLiteral = true;
                    }
                    break;
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case 'e': case 'E': // exponent part
                    if (inExponent) {
                        return token(CalcTokenId.FLOAT_LITERAL);
                    } else {
                        floatLiteral = true;
                        inExponent = true;
                    }
                    break;
                default:
                    input.backup(1);
                    return token(floatLiteral ? CalcTokenId.FLOAT_LITERAL
                            : CalcTokenId.INT_LITERAL);
            }
            ch = input.read();
        }
    }
    
    private Token&lt;CalcTokenId&gt; token(CalcTokenId id) {
        return (id.fixedText() != null)
            ? tokenFactory.getFlyweightToken(id, id.fixedText())
            : tokenFactory.createToken(id);
    }

}
</pre>
<p>
    The classes containing token ids and the language description should be
    part of an API. The lexer should only be part of the implementation.
</p>



<h3>
Providing language embedding.
</h3>

The embedding may be provided statically
in the <code>LanguageHierarchy.embedding()</code>
see e.g. <code>org.netbeans.lib.lexer.test.simple.SimpleLanguage</code>.

<p>
    Or it may be provided dynamically through the xml layer
    by using a file in "Editors/language-mime-type/languagesEmbeddingMap" folder
    named by the token-id's name containing target mime-type and initial and ending skip lengths:
</p>
<pre xml:space="preserve">
    &lt;folder name="Editors"&gt;
        &lt;folder name="text"&gt;
            &lt;folder name="x-outer-language"&gt;
                &lt;folder name="languagesEmbeddingMap"&gt;
                    &lt;file name="WORD"&gt;&lt;![CDATA[text/x-inner-language,1,2]]&gt;
                    &lt;/file&gt;
                &lt;/folder&gt;
            &lt;/folder&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;
</pre>

</arch-usecases><api name="LexerAPI" type="export" category="official" group="java"/><api name="org.netbeans.lib.lexer.TokenHierarchyOperation" type="export" category="friend" group="logger">
        <code>FINE</code> level lists lexer changes made in tokens both at the root level
        and embedded levels of the token hierarchy after each document modification.
        <br/>
        <code>FINER</code> level in addition will also check the whole token hierarchy
         for internal consistency after each modification.
    </api><api name="org.netbeans.lib.lexer.TokenList" type="export" category="friend" group="logger">
        <code>FINE</code> level forces lexer to perform more thorough and strict checks
        in certain situations so this is useful mainly for tests.
        Lookahead and state information is generated even for batch-lexed inputs which allows
        easier checking of incremental algorithm correctness (fixing of token list after modification).
        There are also some additional checks performed
        that should verify correctness of the framework and the SPI implementation
        classes being used (for example when flyweight tokens are created the text
        passed to the token factory is compared to the text in the lexer input).
    </api></module><module name="Master Filesystem" target="org-netbeans-modules-masterfs/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
MasterFileSystems is just implementation of FileSystem provided in standalone 
module including implementation of URLMapper that resolves file protocol and 
is responsible for conversion from URL into FileObject and vice versa.
Implementation just delegates to the other FileSystem implementations 
(LocalFileSystem, VCSFileSystem, ...) and playes the role of arbiter that controls  
instantiation  and  life cycle of  provided FileObjects. 
<api-ref name="MasterFileSystemAPI"/>
</description><deploy-dependencies>
        Nothing currently. Most "clients" are really callers of
        <code>FileUtil.toFileObject</code> and so on, and thus
        implicitly depend on the existence of this module. In the
        future a provide-require token might make sense.
</deploy-dependencies><arch-usecases>
MasterFileSystem is just implementation of FileSystem. There are no special use
cases. FileObjects erlier returned from <code>URLMapper</code> or
<code>FileUtil.fromFile</code>  provided by <code>LocalFileSystem</code> or 
<code>CvsFileSystem</code> will be now provided by <code>MasterFileSystem</code>. 
There will be guaranteed that there won't be more instances of FileObject 
addressing one <code>java.ioFile</code>.
</arch-usecases><api name="MasterFileSystemAPI" type="export" category="friend" url="org-netbeans-modules-masterfs/org/netbeans/modules/masterfs/providers/package-summary.html" group="java"/><api name="refreshSlow" type="export" category="private" group="property">
        One can ask FileObject.getAttribute("refreshSlow") and obtain an instance
        of <code>Runnable</code> with intricate behavior. This is a private contract
        used from core.ui module to show refresh progress and tested
        in <code>masterfs/test/unit/src/org/netbeans/modules/masterfs/SlowRefreshTest.java</code>.
    </api><api name="org.netbeans.modules.masterfs.watcher.disable" type="export" category="private" group="systemproperty">
        It is possible to disable native listening on filesystem changes.
        Useful mostly in testing environment, but it may be interesting for some
        users too. Don't rely (much) on this property from production code however.
    </api><api name="org.netbeans.modules.masterfs.watcher.FAM" type="export" category="private" group="systemproperty">
        It is possible to enable use of FAM notifier on Solaris disabled by default.
        Useful mostly in testing environment, but it may be interesting for some
        users too. Don't rely (much) on this property from production code however.
    </api><api name="org.netbeans.modules.masterfs.case" type="export" category="private" group="systemproperty">
    To address problems when mixing various types of network file systems 
    (as described in bug <code>198946</code>)
    there is a special property <code>org.netbeans.modules.masterfs.case</code>
    that can be set to <code>sensitive</code> or <code>insensitive</code> value
    in order to override the system default. This is intended only for end user
    consumption, not for consumption by other parts of the system. The name and
    meaning of this property may change in any release.
    </api><api name="org.netbeans.io.suspend" type="export" category="devel" group="systemproperty">
        <p>
    Native listeners check the <code>org.netbeans.io.suspend</code> property. 
    If it is set to integer greater than zero, they stop delivering file change events.
    The list of modified directories is recorded (its size is made available
    by setting its string value into <code>org.netbeans.io.pending</code> property), 
    but its processing is suspended. Events are delivered when 
    <code>org.netbeans.io.suspend</code> property changes its value to <code>0</code>
    or becomes empty.
    </p>
    <p>
    I/O intensive operations in other NetBeans modules are advised
    to honour the <code>org.netbeans.io.suspend</code> property as well and
    suspend their I/O activities too.
    </p>
    <p>
    In order to properly communicate changes to the property between multiple
    <em>receivers</em> and multiple <em>controllers</em> it is suggested to
    only manipulate the value under <code>synchronized("org.netbeans.io.suspend".intern())</code>
    lock. Those changing the value are supposed to increment it by one when they
    request the suspend and decrement it by one when they want to resume their
    own suspend.
    </p>
    <p>
    Whenever a change to the state of the property is made,
    <em>controllers</em> are supposed to 
    <code>"org.netbeans.io.suspend".intern().notifyAll()</code>.
    </p>
    </api></module><module name="Master Filesystem - UI extensions" target="org-netbeans-modules-masterfs-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    This module has not provided an architectural description, sorry.
</description><deploy-dependencies>No answer</deploy-dependencies><arch-usecases>No answer</arch-usecases></module><module name="NB JUnit" target="org-netbeans-modules-nbjunit/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Module contains NetBeans extension to JUnit. 
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   Tests typically extends NbTestCase.
  </p>
 </arch-usecases><api name="nbjunit.diff.impl.CmdLine" type="export" category="devel" group="systemproperty">
            used only when nbjunit.diff.impl is set
            to org.netbeans.junit.diff.NativeDiff class. This property
            contain command line, which is called from NativeDiff class
            to perform comparision. This property use
            also '%TESTFILE%' and '%PASSFILE%' variables understood
            by NbJUnit, which are replaced with real
            file names when running tests.
        </api><api name="nbjunit.workdir" type="export" category="devel" group="systemproperty">
            path to a directory, which is used as a root for tests' working
            directories (for details see JavaDoc for NbTestCase.getWorkDir()).
          </api><api name="NbTestCase.order" type="export" category="friend" group="systemproperty">
            This property tries to influence the order of <code>NbTestCase</code>
            methods so it is more predicatable (see <a href="http://wiki.apidesign.org/wiki/OrderOfElements" shape="rect">
            Order of elements</a> for description of the problem). The acceptable
            values of the property are:
            <ul>
                <li>"<b>natural</b>" - use the methods as provided by JDK (e.g. quite random on JDK7)</li>
                <li>"<b>a-z</b>" - sort the tests in ascending alphabetical order</li>
                <li>"<b>z-a</b>" - sort the tests in descending alphabetical order</li>
                <li>"<b>shuffle</b>" - randomize the order of the tests. 
                    If a test fails in this mode a <em>seed</em> is attached to
                    the failure message, use it in the seed mode
                </li>
                <li>seed mode "<b>12234390434</b>" - one can specify any long value
                    as a <em>seed</em> to shuffle the methods. Use this to reproduce
                    random failures
                </li>
            </ul>
            The default order is <b>natural</b> right now, but this may
            change in future to mitigate the <a href="http://wiki.apidesign.org/wiki/OrderOfElements" shape="rect">
            randomness caused by JDK7</a>.
          </api><api name="branding.token" type="export" category="devel" group="systemproperty">
              <a href="org-netbeans-modules-nbjunit/org/netbeans/junit/NbModuleSuite.html" shape="rect">NbModuleSuite</a>
              can now be influenced by system property <code>branding.token</code>.
              If it is provided (by Ant harness for example), it is used
              to call <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/NbBundle.html#setBranding-java.lang.String-" shape="rect">
              NbBundle.setBranding</a>.
          </api></module><module name="Options Dialog and SPI" target="org-netbeans-modules-options-api/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   This module contains implementation of Options Panel and simple SPI.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
    <usecase id="register-top-level-options-panel" name="Register top level Options Panel">
    <p>Client can install new panel to Options Dialog - see JavaDoc for OptionsCategory class.</p>
    </usecase>
    <usecase id="register-panel-to-advanced-options" name="Register panel to Advanced Options Panel">
    <p>Client can install new panel to Advanced Options Panel - see JavaDoc for AdvancedOption class.</p>
    </usecase>
 </arch-usecases><api name="OptionsDialogSPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-options-api/org/netbeans/spi/options/OptionsCategory.html" group="java"/><api name="OptionsDialogSPILayers" type="export" category="devel" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-options-api/org/netbeans/spi/options/OptionsCategory.html" group="layer">
        Use OptionsDialog folder for registration of custom top level options panels. Register 
        your implementation of OptionsCategory there (*.instance file). Standard
        file systems sorting mechanism is used.
   </api><api name="AdvancedPanelSPILayers" type="export" category="devel" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-options-api/org/netbeans/spi/options/AdvancedOption.html" group="layer">
        Use OptionsDialog/Advanced folder for registration of custom panels to Miscellaneous Panel. Register 
        your implementation of AdvancedCategory there (*.instance file). Standard
        file systems sorting mechanism is used.
   </api><api name="OptionsExportLayers" type="export" category="devel" group="layer">
        Use OptionsExport/&lt;MyCategory&gt; folder for registration of items for export/import
        of options. Registration in layers looks as follows
 <pre style="background-color: rgb(255, 255, 153);" xml:space="preserve">
 &lt;folder name="OptionsExport"&gt;
     &lt;!-- category --&gt;
     &lt;folder name="MyCategory"&gt;
         &lt;!-- category display name --&gt;
         &lt;attr name="displayName"
          bundlevalue="org.netbeans.modules.mymodule.options.Bundle#Category_Display_Name"/&gt;
         &lt;!-- item --&gt;
         &lt;file name="MyItem1"&gt;
             &lt;attr name="displayName" bundlevalue="org.netbeans.modules.mymodule.options.Bundle#Item1_Display_Name"/&gt;
             &lt;!-- include regex pattern rooted to userdir --&gt;
             &lt;attr name="include" stringvalue="config/Preferences/org/netbeans/modules/mymodule/.*|config/mymodule/.*"/&gt;
             &lt;!-- exclude regex pattern rooted to userdir --&gt;
             &lt;attr name="exclude" stringvalue="config/mymodule/obsolete/.*"/&gt;
         &lt;/file&gt;
         &lt;!-- item --&gt;
         &lt;file name="MyItem2"&gt;
             &lt;attr name="displayName" bundlevalue="org.netbeans.modules.mymodule.options.Bundle#Item2_Display_Name"/&gt;
             &lt;!-- include pattern with properties constrain --&gt;
             &lt;attr name="include" stringvalue="config/mymodule[.]properties#key[1-9].*|keyA.*#|config/mymodule[.]xml"/&gt;
             &lt;!-- exclude pattern with properties constrain  --&gt;
             &lt;attr name="exclude" stringvalue="config/obsolete[.]properties#key5"/&gt;
         &lt;/file&gt;
     &lt;/folder&gt;
 &lt;/folder&gt;
 </pre>
        Include/exclude patterns may contain either a regular expression defining
        files relatively to userdir (see MyItem1) or a compound pattern defining
        files and property keys (see MyItem2). A compound pattern consists of
        file regex pattern followed by hash delimiter (#) then property key
        regex pattern followed by another hash delimiter. Hash delimiter can be
        ommited at the end of compound pattern. For example, a compound pattern
        can have the following structure
        <code>filePattern1#keyPattern1#|filePattern2|filePattern3#keyPattern3</code>.
   </api><api name="OPT_RestartAfterImport" type="export" category="devel" group="branding">
       By default importing settings (as described by <a href="#layer-OptionsExportLayers" shape="rect">OptionsExport</a>
       API does not require restart. Some systems may however support complex
       modifications to the installation structure. Then they should brand the 
       <code>OPT_RestartAfterImport</code> to <code>true</code>. NetBeans IDE
       does require restart after settings import.
   </api></module><module name="Parsing API" target="org-netbeans-modules-parsing-api/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      See Parsing API homepage for project requirements, motivation.
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
    <ol>
        <li>Parsing API Client can always ask for parser result. 
        This direct call has top level priority (stops all other requests). 
        Its designed to support direct user to IDE interaction 
        (like request for code completion) that have to be as 
        fast as possible. Such type of task is called UserTask. 
        This approach is used not only for parsing of file currently 
        edited in Editor, but it supports Refactoring too.</li>

        <li>Parsing API Implementation listens on various changes in IDE 
        (typing in the current document, cursor movements, switching 
        of editor tabs, changes of classpath). These changes affects parse 
        tree of the current document, and various visualisation features 
        based on parser results (text coloring, hints, error stripe). 
        Parsing API Client can register some tasks that should run when 
        such change is done (Task). Implemementation of Parsing API than 
        calls all such registerred tasks. These calls has lower priority than
        UserTasks, and they should not block user interaction with IDE 
        (typing in editor).</li>

        <li>Parsing API defines how to recognize embedded languages. It should
        be possible to create snapshot of some file, call some recognizers that
        finds blocks of embedded languages and run different parsers for embedded blocks.
        It should be able to use the same parser for top level language and any
        embedded block of code written in the same language. Embedding recognizer 
        can add some virtual code (code that does not exists in top level source) 
        to the embedded block. There should be some support for translation 
        of offsets between top level source and virtual source generated 
        for embedded piece of code.</li>
    </ol>
 </arch-usecases><api name="ParsingAPI" type="export" category="stable" url="org-netbeans-modules-parsing-api/index.html" group="java"/><api name="org.netbeans.ui.indexing" type="export" category="devel" group="logger">
    Since version 1.47 the <code>RepositorUpdater</code> cooperates with <!-- XXX link to http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-uihandler/overview-summary.html not OK from a stable API -->UI Gestures Collector
    by sending following messages to the <code>org.netbeans.ui.indexing</code> <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">logger</a>:
    <ul>
        <li><b>INDEXING_STARTED</b> - message about a start of indexing (up to date check). Arguments:
            <ul>
                <li>{0}: Long - the time from the last indexing</li>
            </ul>
        </li>
        <li><b>INDEXING_FINISHED</b> - message about an end of indexing (up to date check). Arguments:
            <ul>
                <li>{0}: Long - the time of indexing</li>
                <li>For each indexer following 3 records are logged<ul>
                    <li>{1}: String - name of indexer</li>
                    <li>{2}: Integer - indexer invocation count</li>
                    <li>{3}: Integer - indexing time spent in given indexer</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
  </api></module><module name="Parsing API Indexing" target="org-netbeans-modules-parsing-indexing/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      See Parsing API homepage for project requirements, motivation.
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
    <ol>
        <li>
            Indexing API client may request that some or all indexes should be
            rebuilt for a certain or all project source roots, or certain files. The indexing
            infrastructure eventually rebuilds the indexes. The API client may
            choose to wait for the indexing to complete.
        </li>

        <li>
            Module implementor may plug into the indexing system by declaring a 
            CustomIndexer, BinaryIndexer, or EmbeddingIndexer. The implementation
            is called at appropriate time to generate or refresh index information
            for portion of project sources.
        </li>
    </ol>
 </arch-usecases><api name="IndexingAPI" type="export" category="stable" url="org-netbeans-modules-parsing-indexing/index.html" group="java"/><api name="org.netbeans.ui.indexing" type="export" category="devel" group="logger">
    Since version 1.47 the <code>RepositorUpdater</code> cooperates with <!-- XXX link to http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-uihandler/overview-summary.html not OK from a stable API -->UI Gestures Collector
    by sending following messages to the <code>org.netbeans.ui.indexing</code> <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">logger</a>:
    <ul>
        <li><b>INDEXING_STARTED</b> - message about a start of indexing (up to date check). Arguments:
            <ul>
                <li>{0}: Long - the time from the last indexing</li>
            </ul>
        </li>
        <li><b>INDEXING_FINISHED</b> - message about an end of indexing (up to date check). Arguments:
            <ul>
                <li>{0}: Long - the time of indexing</li>
                <li>For each indexer following 3 records are logged<ul>
                    <li>{1}: String - name of indexer</li>
                    <li>{2}: Integer - indexer invocation count</li>
                    <li>{3}: Integer - indexing time spent in given indexer</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
  </api></module><module name="Print" target="org-netbeans-modules-print/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      Provides print functionality in NetBeans.
  
  </description><deploy-dependencies>
  <p>
      Nothing.
  </p>
  </deploy-dependencies><arch-usecases>
      <p>The typical client of Print module can be any tool to print custom data.</p>

      <p>The simple way to enable printing for a custom data is:</p>

      <p>If the data is a Swing component which extends <code>javax.swing.JComponent</code>
      and shown in a <code>org.openide.windows.TopComponent</code>, the key "print.printable"
      (PrintManager.PRINT_PRINTABLE) with value <code>"Boolean.TRUE"</code>
      in the component must be set as a client property. See example:</p>

      <pre xml:space="preserve">
      public class MyComponent extends javax.swing.JComponent {
        public MyComponent() {
          ...
          putClientProperty("print.printable", Boolean.TRUE); // NOI18N
        }
        ...
      }</pre>
  </arch-usecases><api name="PrintAPI" type="export" category="stable" group="java"/></module><module name="Ant-Based Project Support" target="org-netbeans-modules-project-ant/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides the basic infrastructure by which Ant-based projects can be created,
   read and write configuration parameters and properties from/to disk, satisfy
   common queries and interfaces, etc. See Javadoc and build system design
   document.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   Mostly an SPI for use by project type providers to create the project type.
   Also includes a small API/SPI for other projects to find what Ant build steps
   are necessary to create a certain build product, for use in inter-project
   dependencies.
  </p>
  
  <b>Ant project support faq:</b>
    
  <usecase id="support-for-storing-project-properties" name="How to use support for storing project properties?">
  
    <em><b>Q:</b>
    I'm creating a customizer (properties dialog) for my project type. I wan't to use the support
    for simple data types. What do I need to do?</em>
    <p>
    You basicaly need to do two things. First create the representation of the project properties which
    can be used in the GUI. Second at some time convert the objects back to the ANT properties form and
    store them into the project.
    </p>
    <ul>
        <li><b>Creating the object representation.</b>
            <ol>
                <li>Create new instance of StoreGroup for each group of properties you want to store later
                    e.g. project and prvate. Sometimes it might be useful to create temporary source group
                    which will only be used for creating the models without being used for storing. E.g.
                    for properties which need special handling.</li>
                <li>Call the factory methods e.g. createBooleanButtonModel, createStringDocument, etc. which
                    will create the swing models for you.</li>
                <li>Use the models in your Swing controls by calling setModel() or setDocument()</li>
            </ol>                                 
        </li>
        <li><b>Storing the models back to the proprties of project.</b>
            <ol>
                <li>Get the EditableProperties you want to store the model in e.g. private or project 
                    properties</li>
                <li>Call the store method on given SourceGroup with the EditableProperties as parameter</li>
                <li>Manually store models which need some special handling.</li>
            </ol>
        </li>
    </ul>    
  </usecase>
  
 </arch-usecases><api name="AntProjectAPI" type="export" category="official" group="java">
   <p>
   Mostly an SPI for creating project types centered around the Ant build tool.
   Permits Ant-based project types to be registered and supplies various support
   implementations to help satisfy the contract of <code>Project</code> and
   various optional interfaces.
   </p>
  </api><api name="netbeans.do.not.check.xalan" type="export" category="private" group="systemproperty">
          The "netbeans.do.not.check.xalan" property switches off the startup check for
          buggy Xalan. See issue #70130 for more information.
      </api><api name="knownValidProjectXmlCRC32s" type="export" category="private" group="preferences">
       <p>
           A LRU list of CRC-32s of <code>project.xml</code> files known to validate successfully
           is kept to avoid the need to validate files just to load projects, especially during startup.
       </p>
   </api></module><module name="Ant-Based Project Support UI" target="org-netbeans-modules-project-ant-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides the basic infrastructure by which Ant-based projects can be created,
   read and write configuration parameters and properties from/to disk, satisfy
   common queries and interfaces, etc. See Javadoc and build system design
   document.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   Mostly an SPI for use by project type providers to create the project type.
   Also includes a small API/SPI for other projects to find what Ant build steps
   are necessary to create a certain build product, for use in inter-project
   dependencies.
  </p>
  
  <b>Ant project support faq:</b>
    
  <usecase id="support-for-storing-project-properties" name="How to use support for storing project properties?">
  
    <em><b>Q:</b>
    I'm creating a customizer (properties dialog) for my project type. I wan't to use the support
    for simple data types. What do I need to do?</em>
    <p>
    You basicaly need to do two things. First create the representation of the project properties which
    can be used in the GUI. Second at some time convert the objects back to the ANT properties form and
    store them into the project.
    </p>
    <ul>
        <li><b>Creating the object representation.</b>
            <ol>
                <li>Create new instance of StoreGroup for each group of properties you want to store later
                    e.g. project and prvate. Sometimes it might be useful to create temporary source group
                    which will only be used for creating the models without being used for storing. E.g.
                    for properties which need special handling.</li>
                <li>Call the factory methods e.g. createBooleanButtonModel, createStringDocument, etc. which
                    will create the swing models for you.</li>
                <li>Use the models in your Swing controls by calling setModel() or setDocument()</li>
            </ol>                                 
        </li>
        <li><b>Storing the models back to the proprties of project.</b>
            <ol>
                <li>Get the EditableProperties you want to store the model in e.g. private or project 
                    properties</li>
                <li>Call the store method on given SourceGroup with the EditableProperties as parameter</li>
                <li>Manually store models which need some special handling.</li>
            </ol>
        </li>
    </ul>    
  </usecase>
  
 </arch-usecases><api name="AntProjectUI" type="export" category="official" group="java">
   <p>
   Mostly an SPI for creating project types centered around the Ant build tool.
   Permits Ant-based project types to be registered and supplies various support
   implementations to help satisfy the contract of <code>Project</code> and
   various optional interfaces.
   </p>
  </api><api name="netbeans.do.not.check.xalan" type="export" category="private" group="systemproperty">
          The "netbeans.do.not.check.xalan" property switches off the startup check for
          buggy Xalan. See issue #70130 for more information.
      </api><api name="knownValidProjectXmlCRC32s" type="export" category="private" group="preferences">
       <p>
           A LRU list of CRC-32s of <code>project.xml</code> files known to validate successfully
           is kept to avoid the need to validate files just to load projects, especially during startup.
       </p>
   </api></module><module name="External Libraries" target="org-netbeans-modules-project-libraries/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Permits libraries to be defined, customized, and stored by the user for
   reuse in multiple projects. For example, a Java JAR library has a classpath
   (usually one JAR), and an optional source path and Javadoc path that may be
   used for development-time features.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   Different technology support modules will supply definitions of different
   kinds of libraries, e.g. Java JARs, that may be reused in user projects.
   Modules may register library predefinitions to wrap libraries they bundle.
   Project type providers can refer to available libraries in customizer dialogs.
  </p>
 </arch-usecases><api name="ProjectLibrariesAPI" type="export" category="official" group="java">
   The Project Libraries API permits definitions of <q>libraries</q> to be
   registered and persisted. Library type providers may be registered and can
   construct memory objects corresponding to persistent library definitions.
  </api><api name="Library-Declaration-DTD" type="export" category="official" url="http://www.netbeans.org/dtds/library-declaration-1_0.dtd" group="dtd">
   <p>
    An XML DTD is used to define the library definition format.
  </p>
  </api></module><module name="External Libraries UI" target="org-netbeans-modules-project-libraries-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   None.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="project_libs_ui" type="export" category="official" group="java">
   API allows to display standard Swing UI for project library manipulation.
   </api></module><module name="Project API" target="org-netbeans-modules-projectapi/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Provides a generic infrastructure for modelling projects.
   Documentation available in the Javadoc. The build system design overview
   describes the basic purpose of modelling projects.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The SPI should be used by modules defining particular project types, e.g. the
   J2SE project type. The API is to be used primarily by GUI infrastructure and
   some queries, though other module code may on occasion need to refer to the
   API.
  </p>
 </arch-usecases><api name="ProjectAPI" type="export" category="official" group="java">
   The Project API defines abstract projects. These are groupings of files built and
   manipulated as units. It is used for Ant-based projects but could support
   other scenarios such as makefiles. Modules can plug in project types which can
   recognize certain folders as being projects, and define their behaviors.
    Besides the visible Javadoc, this module permits a project to add implementations
    of <code>org.netbeans.spi.queries.FileBuiltQueryImplementation</code>,
    <code>org.netbeans.spi.queries.SharabilityQueryImplementation</code> and
    <code>org.netbeans.spi.queries.FileEncodingQueryImplementation</code>
    into the project lookup (rather than global lookup).
    The implementations will be consulted only in the case the relevant file
    belongs to that project (according to <code>org.netbeans.api.project.FileOwnerQuery</code>).
    This helps avoid the need to consult irrelevant query implementations.   
  </api></module><module name="Project UI" target="org-netbeans-modules-projectui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   General user interface implementation for the project system. UI
   Specification
  
 </description><deploy-dependencies>
  <p>
   N/A
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   Needed for working with projects in the IDE.
  </p>
  <api category="friend" group="java" name="RecentProjects" type="export" url="http://www.netbeans.org/issues/show_bug.cgi?id=57073">
    <p>
     API can be used to get list of information about recently opened projects 
     in IDE. API provides project display name, icon and URL of project folder 
     location. Listeners can be registered to learn about change of the list.
    </p>
  </api>
 </arch-usecases><api name="RecentProjects" type="export" category="friend" url="http://www.netbeans.org/issues/show_bug.cgi?id=57073" group="java">
    <p>
     API can be used to get list of information about recently opened projects 
     in IDE. API provides project display name, icon and URL of project folder 
     location. Listeners can be registered to learn about change of the list.
    </p>
  </api><api name="RecentProjects" type="export" category="friend" url="http://www.netbeans.org/issues/show_bug.cgi?id=57073" group="java">
    <p>
     There is package org.netbeans.modules.project.ui.api which is public and exposed
     as friend API.
    </p>
  </api><api name="PRESELECT_CATEGORY" type="export" category="private" group="property">
     <p>
      Path to a category of project type, e.g. Sample/Standard.
     </p>
    </api><api name="PRESELECT_TEMPLATE" type="export" category="private" group="property">
     <p>
       Name of a project type, e.g. emptyWeb.
     </p>
    </api><api name="project.tab.no.selection" type="export" category="private" group="systemproperty">
     <p>
         When this property is set, the opening of projects doesn't trigger 
         opening and focusing of the projects logical view  top component.
         Allows the BlueJ Edition to focus it's own component instead.
     </p>
    </api><api name="org.netbeans.modules.project.ui.OpenProjectList" type="export" category="private" group="systemproperty">
     <p>
      Error manager logging category for things affecting project list.
     </p>
    </api><api name="netbeans.projects.dir" type="export" category="private" group="systemproperty">
     <p>
      Property for overriding default location of projects directory
      which is folder NetBeansProjects under $HOME on Unixes and under default user folder on 
      Windows (e.g. C:\Documents and Settings\[username]\My Documents\NetBeansProjects). 
      Directory passed by the property must exist, otherwise default is used.
     </p>
    </api><api name="org.netbeans.ui.actions.UI_ACTION_BUTTON_PRESS" type="export" category="friend" group="logger">
      There is a special support for notifying when an action wrapped by
      <code>LookupSensitiveAction</code> is 
      invoked and how. The support is using <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
      Logger.getLogger("org.netbeans.ui.actions")
      </a> and sents a <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">LogRecord</a>
      with message <code>UI_ACTION_BUTTON_PRESS</code>, 
      <code>FINER</code> <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">level</a>
      and paramerters:
      <ul>
          <li>{<b>0</b>} instance of the button</li>
          <li>{<b>1</b>} class of the button</li>
          <li>{<b>2</b>} instance of the action</li>
          <li>{<b>3</b>} class of the action</li>
          <li>{<b>4</b>} display name of the action</li>
      </ul>
      whenever such action is invoked. This message can then be consumed
      by enhanced UI logger that track what the user is going.
      </api><api name="group" type="export" category="devel" group="cli">
     <p>
         Can use <code>--open-group <i>NAME</i></code> to open a project group at startup, or <code>--close-group</code>.
     </p>
    </api><api name="ProjectsTabActions" type="export" category="friend" group="layer">
    <p>
     Actions for the <b>Projects</b> tab root context menu are taken from
     the layer folder <code>ProjectsTabActions</code>. Foreign modules ought
     to place entries below <code>sep-below-main-actions.instance</code>.
    </p>
   </api><api name="org.netbeans.modules.projectui" type="export" category="private" group="preferences">
         <p>
             List of open projects. See <code>OpenProjectListSettings</code>.
         </p>
     </api><api name="org.netbeans.modules.projectui.groups" type="export" category="private" group="preferences">
         <p>
             Project groups. See <code>Group</code>.
         </p>
     </api></module><module name="Project UI API" target="org-netbeans-modules-projectuiapi/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The module supplies the APIs for the basic, generic UI infrastructure for
   projects: list of opened projects, main project, basic project-sensitive
   actions, template wizards, etc.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The main use case is for project type providers to supply logical views and
   customizers for the project. Also for template providers to create
   project-aware file templates. Can also get a list of open projects, create
   different kinds of project-related actions, and select projects on disk.
  </p>
 </arch-usecases><api name="ProjectUIAPI" type="export" category="official" group="java">
     <p> 
      The Project UI API provides some miscellaneous APIs and SPIs relating to the
      appearance and UI behavior of generic projects. Most importantly, it permits
      the customizer and logical view of a project to be defined.
     </p>
    </api><api name="ProjectUIAPI-provider" type="export" category="friend" group="java">
     <p>
      Callbacks intended to let the Project UI module plug in implementations of
      APIs defined here. Uses implementation dependencies.
     </p>
    </api><api name="willOpenProjects" type="export" category="friend" group="property">
   Since version 1.55 a special <a href="http://download.oracle.com/javase/8/docs/api/java/beans/PropertyChangeEvent.html" shape="rect">
   PropertyChangeEvent</a> is generated for benefit of <code>ide.ergonomics</code>
   module by <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-projectuiapi-base/org/netbeans/api/project/ui/OpenProjects.html#getDefault--" shape="rect">
   OpenProjects.getDefault()</a>. The property name of the event is <code>"willOpenProjects"</code>
   and its new value contains an array of projects that will be opened (a type
   <code>Project[]</code>). Ergonomics module uses this information to enable
   modules that seem to provide support for technologies used in the about 
   to be opened projects.
   </api><api name="org.openide.loaders.CreateFromTemplateAttributesProvider" type="export" category="official" group="lookup">
       The attributes provider is registered in <code>META-INF/services</code>. It collects
       attributes from
       <code>org.openide.loaders.CreateFromTemplateAttributesProvider</code>s
       registered in project lookups.
       It provides the
       <a href="#property-project.license" shape="rect">project.license</a> and
       <a href="#property-project.encoding" shape="rect">project.encoding</a> 
       attributes for file templates using scripting support.
     </api><api name="project.license" type="export" category="official" group="property">
       <code>project.license</code> attribute contains project license as <code>String</code> for newly created
       <a href="#lookup-org.openide.loaders.CreateFromTemplateAttributesProvider" shape="rect">templates</a>.
       It is used to import license templates.
       The <code>default</code> is used if the attribute was not found in any
       project lookup.
     </api><api name="project.encoding" type="export" category="official" group="property">
       <code>project.encoding</code> attribute contains the project encoding as <code>String</code> for newly created
       <a href="#lookup-org.openide.loaders.CreateFromTemplateAttributesProvider" shape="rect">templates</a>.
       The encoding of the parent folder of the new file is used if the attribute was not found in any
       project lookup.
     </api><api name="project.licensePath" type="export" category="stable" group="property"> contains <code>String</code> path to the license header include file, by default as path to <code>Templates/Licenses/license-${project.license}.txt</code> system filesystem location, but a local filesystem (file:) url is also supported. </api><api name="RegisteredActions" type="export" category="devel" group="layer">
  <p>
    Several project related actions are registered in the Actions folder in the layer.
    Product branding is intended to use those actions to build main menu, toolbars and shortcuts.
  </p>
   <ul>
       <li>Actions/Project/org-netbeans-modules-project-ui-BuildMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-CleanMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RebuildMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RunMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-DebugMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-TestProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-BuildProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-CleanProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RebuildProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RunProject.instance</li>
   </ul>
  </api><api name="ProjectTemplates" type="export" category="official" group="layer">
   <p>
    New (or import) project wizards can be registered in a special folder
    <code>Templates/Projects/</code>.
   </p>
  </api><api name="ProjectActions" type="export" category="official" group="layer">
   <p>
    Providers of generic project actions can register <code>Action</code> and <code>JSeparator</code>
    instances in a special folder <code>Projects/Actions/</code>. So if any module wishes
    to extend, hide or reorder some of them it can just register its actions there. Example:
   </p>
    <pre xml:space="preserve">
    &lt;folder name="Projects" &gt;
        &lt;folder name="Actions" &gt;
            &lt;file name="org-mymodule-MyAction.instance" &gt;
                &lt;attr name="instanceCreate" stringvalue="org.mymodule.MyAction" /&gt;
            &lt;/file&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;
    </pre>
  </api><api name="Templates" type="export" category="official" group="layer">
   <p>
    File templates can be registered with various attributes, some specific to
    the project system.
   </p>
  </api><api name="TemplatesLicenses" type="export" category="official" group="layer">
   <p>
    Under <code>Templates/Licenses</code> folder should be registered various license headers
    that can be imported by templates using scripting. The recommended format of filename is
    <code>license-[licensename].txt</code> e.g. <code>license-cddl.txt</code>.
   </p>
  </api></module><module name="Base Project UI API " target="org-netbeans-modules-projectuiapi-base/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The module supplies the APIs for the basic, generic UI infrastructure for
   projects: list of opened projects, main project, basic project-sensitive
   actions, template wizards, etc.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   The main use case is for project type providers to supply logical views and
   customizers for the project. Also for template providers to create
   project-aware file templates. Can also get a list of open projects, create
   different kinds of project-related actions, and select projects on disk.
  </p>
 </arch-usecases><api name="BaseProjectUIAPI" type="export" category="official" group="java">
     <p> 
      The Project UI API provides some miscellaneous APIs and SPIs relating to the
      appearance and UI behavior of generic projects. Most importantly, it permits
      the customizer and logical view of a project to be defined.
     </p>
    </api><api name="BaseProjectUIAPI-provider" type="export" category="friend" group="java">
     <p>
      Callbacks intended to let the Project UI module plug in implementations of
      APIs defined here. Uses implementation dependencies.
     </p>
    </api><api name="willOpenProjects" type="export" category="friend" group="property">
   Since version 1.55 a special <a href="http://download.oracle.com/javase/8/docs/api/java/beans/PropertyChangeEvent.html" shape="rect">
   PropertyChangeEvent</a> is generated for benefit of <code>ide.ergonomics</code>
   module by <a href="org-netbeans-modules-projectuiapi-base/org/netbeans/api/project/ui/OpenProjects.html#getDefault--" shape="rect">
   OpenProjects.getDefault()</a>. The property name of the event is <code>"willOpenProjects"</code>
   and its new value contains an array of projects that will be opened (a type
   <code>Project[]</code>). Ergonomics module uses this information to enable
   modules that seem to provide support for technologies used in the about 
   to be opened projects.
   </api><api name="org.openide.loaders.CreateFromTemplateAttributesProvider" type="export" category="official" group="lookup">
       The attributes provider is registered in <code>META-INF/services</code>. It collects
       attributes from
       <code>org.openide.loaders.CreateFromTemplateAttributesProvider</code>s
       registered in project lookups.
       It provides the
       <a href="#property-project.license" shape="rect">project.license</a> and
       <a href="#property-project.encoding" shape="rect">project.encoding</a> 
       attributes for file templates using scripting support.
     </api><api name="project.license" type="export" category="official" group="property">
       <code>project.license</code> attribute contains project license as <code>String</code> for newly created
       <a href="#lookup-org.openide.loaders.CreateFromTemplateAttributesProvider" shape="rect">templates</a>.
       It is used to import license templates.
       The <code>default</code> is used if the attribute was not found in any
       project lookup.
     </api><api name="project.encoding" type="export" category="official" group="property">
       <code>project.encoding</code> attribute contains the project encoding as <code>String</code> for newly created
       <a href="#lookup-org.openide.loaders.CreateFromTemplateAttributesProvider" shape="rect">templates</a>.
       The encoding of the parent folder of the new file is used if the attribute was not found in any
       project lookup.
     </api><api name="project.licensePath" type="export" category="stable" group="property"> contains <code>String</code> path to the license header include file, by default as path to <code>Templates/Licenses/license-${project.license}.txt</code> system filesystem location, but a local filesystem (file:) url is also supported. </api><api name="RegisteredActions" type="export" category="devel" group="layer">
  <p>
    Several project related actions are registered in the Actions folder in the layer.
    Product branding is intended to use those actions to build main menu, toolbars and shortcuts.
  </p>
   <ul>
       <li>Actions/Project/org-netbeans-modules-project-ui-BuildMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-CleanMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RebuildMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RunMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-DebugMainProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-TestProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-BuildProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-CleanProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RebuildProject.instance</li>
       <li>Actions/Project/org-netbeans-modules-project-ui-RunProject.instance</li>
   </ul>
  </api><api name="RegistrationOfConvertors" type="export" category="friend" group="layer">
      This module provides an 
      <a href="org-netbeans-modules-projectuiapi-base/org/netbeans/spi/project/ui/ProjectConvertor.Registration.html" shape="rect">annotation</a>
      to register 
      <a href="org-netbeans-modules-projectuiapi-base/org/netbeans/spi/project/ui/ProjectConvertor.html" shape="rect">project convertor</a>s
      which generates registration in layer. This registration is used and
      processed by <em>ide.ergonomics</em> module. The module especially relies
      on the location of the registration (e.g. <code>Services/ProjectConvertors/</code>)
      and <code>requiredFiles</code> and <code>delegate</code> attributes.
  </api><api name="ProjectTemplates" type="export" category="official" group="layer">
   <p>
    New (or import) project wizards can be registered in a special folder
    <code>Templates/Projects/</code>.
   </p>
  </api><api name="ProjectActions" type="export" category="official" group="layer">
   <p>
    Providers of generic project actions can register <code>Action</code> and <code>JSeparator</code>
    instances in a special folder <code>Projects/Actions/</code>. So if any module wishes
    to extend, hide or reorder some of them it can just register its actions there. Example:
   </p>
    <pre xml:space="preserve">
    &lt;folder name="Projects" &gt;
        &lt;folder name="Actions" &gt;
            &lt;file name="org-mymodule-MyAction.instance" &gt;
                &lt;attr name="instanceCreate" stringvalue="org.mymodule.MyAction" /&gt;
            &lt;/file&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;
    </pre>
  </api><api name="Templates" type="export" category="official" group="layer">
   <p>
    File templates can be registered with various attributes, some specific to
    the project system.
   </p>
  </api><api name="TemplatesLicenses" type="export" category="official" group="layer">
   <p>
    Under <code>Templates/Licenses</code> folder should be registered various license headers
    that can be imported by templates using scripting. The recommended format of filename is
    <code>license-[licensename].txt</code> e.g. <code>license-cddl.txt</code>.
   </p>
  </api></module><module name="General Queries API" target="org-netbeans-modules-queries/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   General kinds of queries between modules.
   Queries are one way of solving the
   intermodule communication problem when it is necessary for some modules to
   obtain basic information about the system (e.g. whether a particular file is
   intended for version control) without needing direct dependencies on the
   module providing the answer (e.g. the project type which controls the file).
   Details are covered in the Javadoc.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
  <p>
   Particular use cases are enumerated in the Javadoc for each query API. Usage
   consists of simple static method calls. Potentially a wide variety of modules
   could use these queries; implementations are typically registered by project
   type providers, though also by Java library and platform implementations.
  </p>
 </arch-usecases><api name="GeneralQueriesAPI" type="export" category="official" group="java">
   The General Queries API provides generic <q>queries</q>, or sources of
   concrete information, useful throughout the build system and perhaps
   elsewhere. Each query is split into an API component intended for clients to
   find the answer to a particular question without knowledge of the underlying
   structure or origin of the answer; and an SPI interface (using lookup)
   permitting answers to be provided from any source. These queries currently
   pertain to VCS and compilation status and user visibility of files.
  </api><api name="org.netbeans.api.queries" type="export" category="private" group="preferences">
      <table>
          <tbody>
              <tr>
                  <th colspan="1" rowspan="1">key</th>
                  <th colspan="1" rowspan="1">description</th>
                  <th colspan="1" rowspan="1">read</th>
                  <th colspan="1" rowspan="1">write</th>
              </tr>
              <tr>
                  <td colspan="1" rowspan="1">default-encoding</td>
                  <td colspan="1" rowspan="1">Default encoding which should be used for new project</td>
                  <td colspan="1" rowspan="1">x</td>
                  <td colspan="1" rowspan="1">x</td>
              </tr>
          </tbody>
      </table>
  </api></module><module name="Refactoring API" target="org-netbeans-modules-refactoring-api/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
Refactoring module allows developer to do high level code transformations aka refactorings.
  
 </description><deploy-dependencies>
Nothing.
 </deploy-dependencies><arch-usecases>
 Refactoring module provides API for refactorings. The idea is that at least the most elementary set of refactorings should be
 available via an API, so that the refactorings could be invoked programmatically. This is particulary useful when creating more
 complex refactorings. These can then be composed from the primitive refactorings accessible via an API using delegation. As an example we can use
 a simple rename refactoring. When renaming a class in a J2SE environment, simple rename refactoring (which renames all occurrences of
 the class) is sufficient. However in a J2EE environment, renaming a class may require renaming of other classes to preserve the functionality
 of the application (e.g. synchrinized renaming a home and remote interface for an EJB). This could be achieved by creating a more complex rename
 refactoring composed of two simple rename refactorings (one for each class to be renamed).
 <p/>
 When analyzing flow of various refactorings, we have found out that the steps in the flow are very common for all
 refactorings. The flow is as follows:
 <ul>
    <li>User selects an object (or set of objects) and chooses to invoke a particular refactoring on it.</li>
    <li>Refactoring pre-conditions are checked - whether a given refactoring can be invoked on a given object (or set of objects) or not. User needs to be
    presented with errors (if any). The errors can be fatal or non-fatal. If an error is fatal, it means the refactoring cannot be performed, if it is not
    fatal, user should be notified of the problem but still be able to proceed with the refactoring.</li>
    <li>User sets parameters of the refactoring - each refactoring has some input parameters (e.g. new name for an element in case of Rename refactoring).
    These parameters need to be set by the client.</li>
    <li>Entered values of refactoring parameters are checked - errors (if any) are presented to the user.</li>
    <li>Refactoring collects all changes that need to be performed and presents them to the user.</li>
    <li>User can choose to not perform a particular set of proposed changes.</li>
    <li>Refactoring is performed - all the changes confirmed by user are made to the source code.</li>
 </ul>
 To make the implementation of various refactorings consistent, the refactoring module provides an API and UI framework that allows these refactorings to be plugged in. This
 framework enforces the above flow. Using this framework (set of SPI and API) the refactoring implementor can focus purely on the things specific to that particular refactoring
 (specific pre-conditions checks, parameters checks, implementation of changes, etc.) and leave the
 functionality that is common for all refactorings (implementation of the flow) up to the framework.
 <p/>
 It is quite common that some modules need to be able to affect the behavior of a refactoring. There are 4 typical use-cases when this is desirable:
 <ol>
     <li>A module wants to implement refactoring features for their own elements. For instance Java Refactoring module wants to implement Refactoring for Java elements.</li>
     <li>A module wants to participate in existing refactoring. E.g. refactoring of java files requires refactoring of non-java files in J2EE area. When a code is refactored, these non-java files need to be refactored too.
We can mention JSP files or deployment descriptors as an example.</li>
     <li>A module introduces some hidden relationships between several elements. E.g. a single logical EJB consists of several physical classes. When one of these classes are refactored,
     the other classes need to be refactored as well.</li>
     <li>A module generates some derived code into the guarded blocks. In such case it is desirable that the provider of the guarded block refactors the guarded code, since
     the refactoring module itself has no knowledge of where the guarded code comes from.</li>
 </ol>
 The refactoring module provides hooks for other modules - an SPI that allows other modules to participate in refactorings. The modules can participate on all refactoring
 phases from "preCheck" (checking preconditions), through "checkParameters" (checking validity of refactoring parameters) to "prepare" (collecting changes).
 Use-cases number 1), 2) and 3) are covered by the same SPI (interfaces RefactoringPluginFactory and RefactoringPlugin). The forth use-case (guarded blocks) are covered by
 a separate set of interfaces, since for this use-case the module does not need to participate in all refactoring phases. The refactoring framework itself automatically detects
 that a given change points to a code in guarded blocks and requests all registered guarded block providers to handle that situation.
 <p/>
 The rest of this section provides simple orientational examples of API/SPI usage.
 <p/>
<b>Refactoring API</b> can be used for programmatical invocation of refactorings and for pluging ui for these refactorings in.
<p><i><b>Refactoring API Example:</b></i></p> 
<i>Intention:</i> Programatically rename java file<code>com/company/Test.java</code> to <code>com/company/RenamedTest.java</code> and update references.
<pre xml:space="preserve">

  	FileObject fo = ...com/company/Test.java...
        RefactoringSession renameSession = RefactoringSession.create("Rename Class");
        refactoring = new RenameRefactoring(fo);
        Problem pre = refactoring.preCheck();
        if (pre!=null &amp;&amp; pre.isFatal()) {
     	  //fatal problem in precheck
     	  return;
        }
        refactoring.setNewName("RenamedTest");
        Problem p = refactoring.prepare(renameSession);
        
        if (p!=null &amp;&amp; p.isFatal()) {
     	  //fatal problem in precheck
     	  return;
        }
        
        renameSession.doRefactoring(true /* saveAll */);
</pre>
        
<p>
<b>Refactoring SPI</b> permit other modules to plug into existing refactorings and allow them to participate.
Client of SPI must implement factory class <code>RefactoringPluginFactory</code> and register this class into Lookup.
</p>
<i><b>Refactoring SPI Example 1:</b></i>
<p>
    <i>Intention:</i> Create a plugin for RenameRefactoring, which will participate in existing refactoring (let say in java refactoring) 
    and renames references in XML files.
</p>
<pre xml:space="preserve">
//implementation of factory class
public class J2EERefactoringFactory implements RefactoringPluginFactory {
    
    public RefactoringPlugin createInstance(AbstractRefactoring refactoring) {
    
        if (refactoring instanceof RenameRefactoring) {
            //return our custom instance for RenameRefactoring
            if (wantToParticipate(refactoring.getRefactoredObject())
                return new J2EERenameRefactoringPlugin((RenameRefactoring) refactoring);
        }
        
        if (refactoring instanceof ... {
            ...
        }

        return null;
    }
    
}
</pre>

It is necessary to register <code>J2EERefactoringFactory</code> in the lookup:
<pre xml:space="preserve">
META-INF/services/org.netbeans.modules.refactoring.spi.RefactoringPluginFactory
</pre>
<p>
and implement RefactoringPlugin interface:
</p>

<pre xml:space="preserve">
//implementation of RefactoringPlugin
public class J2EERenameRefactoringPlugin implements RefactoringPlugin {
    
    private RenameRefactoring refactoring;
    
    public J2EERenameRefactoringPlugin(RenameRefactoring refactoring) { 
        this.refactoring = refactoring;
    }
 
    public Problem preCheck() {
        ...
    }
    
    public Problem checkParameters() {
        ...
    }
    
    public Problem fastCheckParameters() {
        ...
    }
    
    public void cancelRequest() {
        ...
    }
    
    public Problem prepare(RefactoringElementsBag refactoringElements) {
        RenameRefactoring renameRefactor = ((RenameRefactoring)refactoring);
        Object element = renameRefactor.getRefactoredObject();
        if (...) {
           ...
           //lets add our RefactoringElements for usages found in XML files 
           refactoringElements.add(refactoring, new XMLRenameRefactoringElement());
        }
        return null;
    }

    public class XMLRenameRefactoringElement implements RefactoringElementImplementation {

        public void performChange() {
            //do change
        }
    }
</pre>

<i><b>Refactoring SPI Example 2:</b></i>
<i>Intention:</i> Create a module, which will add Rename... to html files
First you must create your ActionsImplementationProvider:
<pre xml:space="preserve">
public class MyProvider extends ActionsImplementationProvider {
    
  public boolean canRename(Lookup lookup) {
    Node[] nodes = lookup.lookupAll(Node.class);
    if (..one node selected and the node belongs to html...)
      return true;
    else 
      return fals;
 }

  public void doRename(Lookup selectedNodes) {
    Node[] nodes = lookup.lookupAll(Node.class);
    final FileObject fo = getFileFromNode(nodes[0]);
    return new Runnable() {
      public void run() {
        UI.openRefactoringUI(new RenameRefactoringUI(fo);
      }
    }    
  }
}
</pre>
And of course your own RefactoringPlugin and RefactoringPluginFactory see 
<i><b>Refactoring SPI Example 1</b></i> and
<i><b>Refactoring SPI Example 2</b></i>
<br/>
<i><b>Refactoring SPI Example 3</b></i>
Module wants to implement it's own refactoring preview tree:

Register your own TreeElementFactoryImplementation into META-INF/services
if you want to build your own RefactoringPreview tree.
 
For instance Java Refactoring understand Java - specific objects e.g. 
Projects, Groups, Methods etc.

<pre xml:space="preserve">
public TreeElement getTreeElement(Object o) {
.
.
if (o instanceof SourceGroup) {
  return new SourceGroupTreeElement((SourceGroup)o);
} else if (o instanceof SomethingFromJava) {
   return new SomethingFromJavaTreeElement((SomethingFromJava) o);
}
</pre>
TreeElement is then displayed in refactoring preview panel.

<br/>
<br/>
<br/>Other usecases are docummented in javadoc.
<ul>
    <li>Module wants to add common Refactoring Action into popup. <br/>
        See <a href="org-netbeans-modules-refactoring-api/org/netbeans/modules/refactoring/api/ui/RefactoringActionsFactory.html" shape="rect">RefactoringActionsFactory</a>
    </li>
    <li>
       http://wiki.netbeans.org/wiki/view/RefactoringFAQ
    </li>
</ul>

 </arch-usecases><api name="RefactoringAPI" type="export" category="devel" group="java"/><api name="RefactoringSPI" type="export" category="devel" group="java"/><api name="org.netbeans.modules.refactoring.spi.RefactoringPluginFactory" type="export" category="devel" group="lookup"/><api name="org.netbeans.modules.refactoring.spi.GuardedBlockHandlerFactory" type="export" category="devel" group="lookup"/><api name="org.netbeans.modules.refactoring.spi.ReadOnlyFilesHandler" type="export" category="devel" group="lookup"/><api name="org.netbeans.modules.refactoring.spi.ui.ActionsImplementationProvider" type="export" category="devel" group="lookup"/><api name="org.netbeans.modules.refactoring.spi.ui.TreeElementFactoryImplementation" type="export" category="devel" group="lookup"/></module><module name="Java Refactoring" target="org-netbeans-modules-refactoring-java/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="JavaRefactoringAPI" type="export" category="devel" group="java"/></module><module name="Sampler API" target="org-netbeans-modules-sampler/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   It allows NetBeans Platform developer to self-sample their application,
   which should provide them with a valuable information about CPU 
   performance problems.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="user-sampling" name="User controlled sampling">
       There needs to be a simple API for someone who wants to create simple user 
       action which starts and stops self-sampling and presents user with sampled
       results.
       <p/>
       The correct way to achieve this is to call 
        <code><a href="org-netbeans-modules-sampler/org/netbeans/modules/sampler/Sampler.html" shape="rect">Sampler</a>.createManualSampler</code>,
        followed by
        <code><a href="org-netbeans-modules-sampler/org/netbeans/modules/sampler/Sampler.html" shape="rect">Sampler</a>.start()</code> and
        <code><a href="org-netbeans-modules-sampler/org/netbeans/modules/sampler/Sampler.html" shape="rect">Sampler</a>.stop()</code>.
        
   </usecase>
   <usecase id="code-sampling" name="Sampling of the slow operation">
       Second major use-case of the Sampling API is sampling of the slow operation.
       
       <p/>
       The correct way to achieve this is to call 
        <code><a href="org-netbeans-modules-sampler/org/netbeans/modules/sampler/Sampler.html" shape="rect">Sampler</a>.createSampler()</code>,
        followed by
        <code><a href="org-netbeans-modules-sampler/org/netbeans/modules/sampler/Sampler.html" shape="rect">Sampler</a>.start()</code> and
        <code><a href="org-netbeans-modules-sampler/org/netbeans/modules/sampler/Sampler.html" shape="rect">Sampler</a>.stopAndWriteTo(DataOutputStream dos)</code>.
   </usecase>
  </p>
 </arch-usecases><api name="SamplerAPI" type="export" category="devel" url="org-netbeans-modules-sampler/org/netbeans/modules/sampler/package-summary.html" group="java"/></module><module name="Command Line Parsing API" target="org-netbeans-modules-sendopts/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   GetOpts like infrastructure to parse command line arguments with the cooperative
   participation of various modules.
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="cli-just-parse" name="Just Parse the Command Line">
       There needs to be a simple API for someone who has an array of strings 
       and wants to parse them. One does not need to search for providers,
       just ask the infrastructure to do the parse and get the result. 
       <p/>
       The correct way to achieve this is to call 
        <code><a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html" shape="rect">CommandLine</a>.getDefault().process(args)</code>.
   </usecase>
   <usecase id="cli-own-parse" name="Parse the Command Line with Own Options">
       Since version 2.20 one can define own classes with fields and annotate
       them with <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">@Arg</a>
       annotation. Those classes can then be passed into a 
       <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html#create-java.lang.Class...-" shape="rect">
       factory method
       </a>
       that creates new <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html#create-java.lang.Class...-" shape="rect">command line</a>.
       One can then process the arguments as many times as needed via the
        <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html#process-java.lang.String...-" shape="rect">process</a>
        method. Example:
        <pre xml:space="preserve">
public final class MyOption implements <a href="http://download.oracle.com/javase/8/docs/api/java/lang/Runnable.html" shape="rect">Runnable</a> {
  <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">@Arg</a>(longName="hello")
  public String name;

  public void run() {
    System.out.println("Hello " + name + "!");
  }
  
  public static void main(String... args) {
    <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html" shape="rect">CommandLine</a> line = <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html#create-java.lang.Class...-" shape="rect">CommandLine.create</a>(MyOption.class);
    line.<a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html#process-java.lang.String...-" shape="rect">process</a>(args);
  }
}
</pre>
   <p>
       If the above main class is called with parameters <code>--hello World</code> it
       will print out <code>Hello World!</code>.
   </p>
   </usecase>
   <usecase id="cli-types-of-options" name="Short and Long options with or without an argument">
       The standard <code>getopts</code> supports short form of options - e.g. a dash
       followed with one letter - or long form using two dashes followed with a word. 
       Moreover the long form is optimized for abbrevations. If there are no 
       conflicts between multiple options, then one can only use double dash followed
       with a prefix of a long option.
       <p/>
       When using the <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">declarative annotation style</a>
       one can always specify 
       <code><a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">@Arg</a>(longName="text", shortName='t')</code>.
       The <code>longName</code> attribute is required, but if there is supposed to be
       no long version of the argument, it can be set to empty string.
       <p/>
       One can create an <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Option.html" shape="rect">Option</a>
       by calling any of its factory methods 
       (like 
        <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Option.html#withoutArgument-char-java.lang.String-" shape="rect">withoutArgument</a>)
        and provider <code>char</code> for the one letter option and/or string for
        the long getopts option.
   </usecase>
   <usecase id="cli-types-args" name="Options with or without an argument">
       There are three types of options. Those without an argument, those with
       a required one and those with optional one. Each one can be created
       by appropriate factory method in the 
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Option.html" shape="rect">Option</a> class.
       <p/>
       When using the <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">declarative annotation style</a>
       one needs to annotate a field of type <code>boolean</code> to create
       an option without an argument.
   </usecase>
   <usecase id="cli-double-dash" name="Support for --">
       The getopts compliant command line parsers support <q>--</q>. If 
       these characters do appear on the command line, the rest of it is
       treated as extra arguments and not processed. The sendopts infrastructure
       supports this as well.
   </usecase>
   <usecase id="cli-multiple-handlers" name="Multiple Independent CLI Handlers">
       The handlers for the options need not know about each other and still 
       have to be able to process the command line successfully. Any module
       which wishes to provide its own options can register its 
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" shape="rect">OptionProcessor</a>
       with <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-lookup/org/openide/util/lookup/ServiceProvider.html" shape="rect">@ServiceProvider</a>
       annotation. Alternatively the module can use the
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">@Arg</a> annotation
       of its fields and it will be registered as well.
   </usecase>
   <usecase id="cli-extensible-options-set" name="Extensible Options Set">
       <p>
        <b>Q:</b> How shall one write an 
        <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" shape="rect">OptionProcessor</a>
        that recognizes set of basic options, however contains one open <q>slot</q>?
        The processor wants other modules to provide recognizers for that slot 
        and wants to communicate with them. For example, by default the processor
        recognizes option <code>--channel &lt;name_of_the_channel&gt;</code>
        which describes a source of data, and stores such data into a <q>sink</q>.
        There can be multiple sinks - discard the output, save it to file, show
        it on stdout, stream it to network. The processor itself can handle the
        copying of data, but does not itself know all the possible <q>sink</q>
        types.
       </p>
       
       <p>
           To implement 
           <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" shape="rect">OptionProcessor</a>
           like this one shall define an additional interface to communicate with
           the <q>sink</q> providers:
       </p>
       
       <pre xml:space="preserve">
   package my.module;
   public interface SinkProvider {
     /** gets the option (even composite) that this sink needs on command line */
     public Option getOption();

     /** processes the options and creates a "sink" */
     public OutputStream createSink(Env env, Map&lt;Option,String[]&gt; values) throws CommandException;
   }
       </pre>
       <p>
           Other modules would then registered implementations of this 
           interface in the 
           <code>META-INF/services/my.module.SinkProvider</code> files.
           The 
           <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" shape="rect">OptionProcessor</a>
           itself would just look all the implementations up, queried for 
           the <q>sinks</q>, and then did the copying:
       </p>
       
       <pre xml:space="preserve">
   class CopyingProvider extends OptionProvider {
     public Option getOption() {
        List&lt;Option&gt; l = ...;
        for (SinkProvider sp : Lookup.getDefault().lookupAll(SinkProvider.class)) {
          l.add(sp.getOption());
        }

        // we need only one provider to be present
        Option oneOfSinks = OptionGroups.oneOf(l.toArray(new Option[0]));

        // our channel option
        Option channel = ...;

        // the channel option needs to be present as well as a sink
        return OptionGroups.allOf(channel, oneOfSinks);
     }

     public void process(Env env, Map&lt;Option,String[]&gt; values) throws CommandException {
        OutputStream os = null;
        for (SinkProvider sp : Lookup.getDefault().lookupAll(SinkProvider.class)) {
          if (values.containsKey(sp.getOption())) {
            os = sp.createSink(env, values);
            break;
          }
        }
        if (os == null) {
          throw CommandException.exitCode(2);
        }

        // process the channel option and
        // handle the copying to the sink <code>os</code>
     }
   }
       </pre>
       <p>
           Another possible approach how to allow sharing of one option between
           multiple modules is to expose the option definition and its handling
           code as an interface to other modules, and then let the modules
           to write their own 
           <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" shape="rect">OptionProcessor</a>s.
           Necessary condition is that each of the processor is uniquely 
           identified by some additional option, so when the shared option appears
           the infrastructure knows which processor to delegate to. 
           This is demonstrated in the 
           <a href="http://www.netbeans.org/source/browse/contrib/sendopts/test/unit/src/org/netbeans/api/sendopts/Attic/SharedOptionTest.java?rev=1.1.2" shape="rect">
           SharedOptionTest</a> which
           basically does the following:
       </p>       
       <pre xml:space="preserve">
   /** the shared option, part of an interface of some module */
   public static final Option SHARED = ...;
   /** finds value(s) associated with the SHARED option and 
   * creates a JPanel based on them */
   public static JPanel getSharedPanel(Map&lt;Option,String[]&gt; args) { ... }
       </pre>
       <p>
           Then each module who wishes to reuse the SHARED option and the
           factory method that knows how to process their values for their
           own processing can just:
       </p>
       <pre xml:space="preserve">
  public static final class ShowDialog extends OptionProcessor {
    private static final Option DIALOG = Option.withoutArgument('d', "dialog");

    protected Set&lt;Option&gt; getOptions() {
        // the following says that this processor should be invoked
        // everytime --dialog appears on command line, if the SHARED
        // option is there, then this processor wants to consume it 
        // as well...
        return Collections.singleton(Option.allOf(DIALOG, Option.anyOf(SHARED)));
    }

    protected void process(Env env, Map&lt;Option, String[]&gt; optionValues) throws CommandException {
        JPanel p = getSharedPanel(optionvalues);
        if (p == null) {
           // show empty dialog
        } else {
           // show some dialog containing the panel p
        }
    }
  }
       </pre>
       <p>
           The other modules are then free to write other processors refering to
           <code>SHARED</code>, for example one can write <code>ShowFrame</code>
           that does the same, just shows the panel in a frame, etc. The infrastructure
           guarantees that the exactly one provider which matches the command 
           line options is called.
       </p>
   </usecase>
   <usecase id="cli-help" name="Printing Full Help Text">
       Althrough the handlers are provided by independent parties, it must be possible
       to generate resonable and consistent help description from all of them,
       so for the end user it appears as well formated and easily understandable.
       That is why
       every option can be associated with a short description providing info
       about what it is useful for using
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Option.html#shortDescription-org.netbeans.spi.sendopts.Option-java.lang.String-java.lang.String-" shape="rect">
           Option.shortDescription
       </a> method. When using the 
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">@Arg</a> style, there
       is an additional <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Description.html" shape="rect">@Description</a>
       annotation which can be used to declaratively associate a localized display name
       and short description with the option.
       To get such descriptions for all available options one 
       can use 
       <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html#usage-java.io.PrintWriter-" shape="rect">
        CommandLine.getDefault().usage(java.io.PrintWriter)</a>.
   </usecase>
   <usecase id="cli-errorrecovery" name="Finding and Reporting when Options Are Not Correct">
       In case the command line cannot be processed a clean error for programmatic
       consumation and also one that can be shown to the end user of the command
       line must be given. This is handled by throwing 
       <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandException.html" shape="rect">CommandException</a>
       with appropriate message description and exit code.
   </usecase>
   <usecase id="cli-extraarguments" name="Processing Extra Command Line Arguments">
       There can be non-option arguments in the command line and they can freely
       mix with the option ones. For example the getopts would treat the following
       command line arguments as the same:<pre xml:space="preserve">
       --open X.java Y.java Z.txt
       X.java Y.java --open Z.txt
       </pre> if the option <q>open</q> handles <q>extra arguments</q>.
       The sendopts infrastructure must distinquish between them
       and pass the non-option ones to the only one handler (active because it 
       processed an option) that knowns how to
       parse them. It is an error if more than one or no handler expresses 
       an interest in extra arguments and those are given. One can register
       such option by using the <code>
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Option.html#additionalArguments-char-java.lang.String-" shape="rect">
           Option.additionalArgument
       </a>
       </code> factory method.
       <p/>
       When using the 
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">declarative annotation style</a>
       one may annotate a field of type <code>String[]</code> which then means
       this field should be filled with all additional arguments.
   </usecase>
   <usecase id="cli-io" name="Handling Input and Output">
       Handler's shall not use the input and output streams directly for their execution, they should 
       rely on the framework provided ones. This allows NetBeans based application to
       transfer the I/O from second started instance to the master one which 
       is already running. From the client side there is the
       <code><a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandLine.html" shape="rect">CommandLine</a>.getDefault().parse</code>
       methods taking additional arguments like input and output streams.
       This gets transfered to providers as an 
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Env.html" shape="rect">Env</a>
       argument of their methods.
   </usecase>
   <usecase id="cli-exitcode" name="Returning Exit Code">
       When Handler's get execute (in the order defined by the order of options
       on the command line), each of them can either execute successfully, or
       fail. If a handler succeeds, next one is executed, if it fails, the 
       execution is terminated and its return code is returned to the caller.
       The error can be notified by creating and throwing 
       <a href="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/CommandException.html" shape="rect">CommandException.exitCode(int errorCode)</a>.
   </usecase>
   <usecase id="cli-onlyextraarguments" name="Processing Only Extra Command Line Arguments">
       Sometimes it is desirable to process non-option arguments like file names
       without providing any option. Handlers can declare interest in such arguments.
       It is an error if such non-options are provided and no or more than one
       handler is around to handle them. One can create such option by 
       using <code>
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Option.html#defaultArguments--" shape="rect">Option.defaultArguments</a>
       </code> factory method. With the
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">declarative annotation style</a>
       one can annotate a field of type <code>String[]</code> and specify that
       it is supposed to be <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html#implicit--" shape="rect">implicit</a>.
   </usecase>
   <usecase id="cli-lazy-handler-initiliazation" name="Only those processor need to process the options are created">
       For purposes of usage in NetBeans, it is needed to not-initialize those
       handlers that are not really needed to process certain command line. 
       The infrastructure decides which of them are going to be needed and 
       instantiates only those. This is supported only when using the
       <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">declarative annotation style</a> -
       information about these options is recorded in declarative way and the
       system can decide without loading the provider classes whether they are
       present on the command line or not.
   </usecase>
   <usecase id="cli-complex-options" name="Complex Option Relations">
       Certain CLI processors may need more than one option before they 
       can process the input. For example it is necesary to tune the radio
       and then also tell what to do with the output. It is unconvenient 
       to process that as one option with argument(s), that is why one can 
       use the 
<a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionGroups.html#allOf-org.netbeans.spi.sendopts.Option...-" shape="rect">
OptionGroups.allOf</a>,
<a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionGroups.html#someOf-org.netbeans.spi.sendopts.Option...-" shape="rect">
OptionGroups.someOf</a>, for example like: <pre xml:space="preserve">
class PP extends OptionProcessor {
    private static Option tune = Option.requiredArgument(Option.NO_SHORT_NAME, "tune");
    private static Option stream = Option.requiredArgument(Option.NO_SHORT_NAME, "stream");
    
    public Set&lt;Option&gt; getOptions() {
      return Collections.singleton(
        <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionGroups.html#allOf-org.netbeans.spi.sendopts.Option...-" shape="rect">OptionGroups.allOf</a>(tune, stream)
      );
    }
    
    public void process(Env env, Map&gt;Option,String[]&gt; values) throws CommandException {
        String freq = values.get(tune)[0];
        String output = values.get(stream)[0];

        // XXX handle what is needed here
    }
}
</pre>
When the two options are registered and command line like 
<q>--tune 91.9 --stream radio1.mp3</q> is being processed, the 
<code>PP</code>'s <code>process</code> method is going to get 
called with values <q>91.9</q> and <q>radio1.mp3</q>.
<p/>
This kind of grouping is not currently supported with the 
<a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/Arg.html" shape="rect">declarative annotation style</a>
registration.
   </usecase>
   
   
   <usecase id="cli-alternative-options" name="Alternative Options">
       Sometimes there may different ways to specify the same option and
       just one of them or none of them can be provided at given time. 
       For example is there is a way to tune the radio with direct frequency
       or with name of the station. Just one can be provided and one is needed.
       This can be specified by using 
<a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionGroups.html#oneOf-org.netbeans.spi.sendopts.Option...-" shape="rect">
OptionGroups.oneOf</a> factory methods:
<pre xml:space="preserve">
Option freq = Option.requiredArgument(Option.NO_SHORT_NAME, "tune");
Option station = Option.requiredArgument(Option.NO_SHORT_NAME, "station");
Option tune = OptionGroups.oneOf(freq, station);    
</pre>
The option <code>tune</code> then signals that just one of the station or
freq options can appear and that they both are replaceable.
   </usecase>
  </p>
 </arch-usecases><api name="SendOptsAPI" type="export" category="official" url="org-netbeans-modules-sendopts/org/netbeans/api/sendopts/package-summary.html" group="java"/><api name="SendOptsSPI" type="export" category="official" url="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/package-summary.html" group="java"/><api name="OptionProcessor" type="export" category="stable" url="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" group="lookup">
    The sendopts module uses <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-lookup/org/openide/util/Lookup.html" shape="rect">Lookup</a>
    to get list of all registered <a href="org-netbeans-modules-sendopts/org/netbeans/spi/sendopts/OptionProcessor.html" shape="rect">OptionProcessor</a>s.
</api></module><module name="Common Server" target="org-netbeans-modules-server/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Allows UI presentation of server instance without dependency on a server
   specific API (like j2eeserver).
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <usecase id="register-provider" name="Registering the server/cloud instance provider">
   <p>
    An external module can register itself as the server instance provider.
    In order to do that it must register the implementation of
    <a href="org-netbeans-modules-server/org/netbeans/spi/server/ServerInstanceProvider.html" shape="rect">ServerInstanceProvider</a>
    in <code>Servers</code> or <code>Cloud</code> folder in the layer.xml.
   </p>
   <p>
    When this is done the module will handle displaying of instances at appropriate
    IDE dialogs and views. Note that more specific SPIs can still be required
    for the technology specific dialogs and actions. This module covers the areas
    where the "common server" term makes sence.
   </p>
   <p>
    Every
    <a href="org-netbeans-modules-server/org/netbeans/spi/server/ServerInstanceImplementation.html" shape="rect">ServerInstance</a>
    returned by the provider is handled by this module. Some features of the
    <a href="org-netbeans-modules-server/org/netbeans/spi/server/ServerInstanceImplementation.html" shape="rect">ServerInstance</a>
    are not mandatory (as described in javadoc). If new instances can be added
    or removed during the lifecycle of external module it has to notify all
    listeners of the
    <a href="org-netbeans-modules-server/org/netbeans/spi/server/ServerInstanceProvider.html" shape="rect">ServerInstanceProvider</a>.
   </p>
  </usecase>
  <usecase id="register-wizard" name="Registering the server/cloud wizard">
   <p>
    An external module can register the wizard(s) in order to allow the user
    to add new instances. In order to do that it must register the implementation of
    <a href="org-netbeans-modules-server/org/netbeans/spi/server/ServerWizardProvider.html" shape="rect">ServerWizardProvider</a>
    in <code>Servers</code> or <code>Cloud</code> folder in the layer.xml.
   </p>
   <p>
    When this is done the module will offer this wizard in UI (at contexts where
    it makes sense).
   </p>
  </usecase>
  <usecase id="persist-instance" name="Persisting instance properties">
   <p>
    The Commons Server SPI implemetor has to usually implement persistence
    of its instances somehow. There are many ways how this can be done.
    To make it easier
    <a href="org-netbeans-modules-server/org/netbeans/api/server/properties/InstancePropertiesManager.html" shape="rect">InstancePropertiesManager</a>
    can be used. It provides a way how to store and retrieve properties of
    the server instance.
   </p>
  </usecase>   
 </arch-usecases><api name="CommonServerSPI" type="export" category="devel" url="org-netbeans-modules-server/org/netbeans/spi/server/package-summary.html" group="java"/><api name="CommonServerAPI" type="export" category="devel" url="org-netbeans-modules-server/org/netbeans/api/server/package-summary.html" group="java"/><api name="CommonServerLayerSPI" type="export" category="devel" url="org-netbeans-modules-server/overview-summary.html" group="layer"/><api name="CommonServerPropertiesAPI" type="export" category="devel" url="org-netbeans-modules-server/org/netbeans/api/server/properties/package-summary.html" group="java"/><api name="ServersNodeActions" type="export" category="devel" group="layer">
            By registering actions to <code>Servers/Actions</code> you
            can extend the list of popup actions on Servers node in
            Services tab.
      </api><api name="CloudNodeActions" type="export" category="devel" group="layer">
            By registering actions to <code>Cloud/Actions</code> you
            can extend the list of popup actions on Cloud node in
            Services tab.
      </api><api name="serverNodeHidden" type="export" category="friend" group="property">
            If the action registered in <code>Servers/Actions</code> or <code>Cloud/Actions</code> folder
            has <code>getValue("serverNodeHidden") == Boolean.TRUE</code>, then
            it will not be shown in the popup menu.
      </api><api name="wizardMessage" type="export" category="friend" group="property">
            <p>
            By adding <code>wizardMessage</code> attribute you tell the
            <q>Add Server...</q> or <q>Add Cloud...</q> action to display this message as an
            option, if no servers are yet registered. If user agrees, your
            action will be called then to enable some server providers.
            </p>
            <p>
            The action then receives command <q>noui</q>,
            to know that it shall only enable given functionality, but there
            is no need to show user anything.
            </p>
      </api><api name="ServersNodeActionsAttributes" type="export" category="friend" group="layer">
            <p>
            By adding additional attributes to files in <code>Servers/Actions</code> or <code>Cloud/Actions</code>
            folder you can influence behaviour of the <q>Servers</q> and <q>Cloud</q> node.
            </p>
            <p>
            By adding <code>property-something</code> attribute you identify
            an action that will be called as soon as the node is expanded and
            <code>System.getProperty("something")</code> is non-null.
            </p>
            <p>
            By adding <code>config-something</code> attribute you identify
            an action that will be called as soon as the node is expanded and
            <code>FileUtil.getConfigFile("something")</code> is non-null.
            </p>
            <p>
            In all of these cases, the action receives command <q>noui</q>,
            to know that it shall only enable given functionality, but there
            is no need to show user anything.
            </p>
            <p>
            These attribute based APIs shall be seen as temporary and subject
            to replacement. Please notify us as soon as you start to use them.
            </p>
      </api></module><module name="Settings API" target="org-netbeans-modules-settings/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Settings are persistent objects with a set of properties, that should be available via lookup.  
Properties are expected to be changed. Implementation of setting doesn't care about persistence issues, which
is responsibility of settings infrastructure.  XML persistence support is provided in a standalone autoload module core-settings.jar.
Also service types must be mentioned here.
Service type can be desribed as typed a named settings.


<api-ref name="SettingsAPI"/>

<api-ref name="ServicesAPI"/>

<api-ref name="XmlSettingsPersistence"/>


</description><api name="SettingsAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-util-ui/org/openide/util/doc-files/api.html#settings" group="java"/><api name="ServicesAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-util-ui/org/openide/util/doc-files/api.html#service-lookup" group="java"/><api name="XmlSettingsPersistence" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-settings/org/netbeans/spi/settings/package-summary.html" group="java"/><api name="sessionsettings-1_0.dtd" type="export" category="stable" url="http://www.netbeans.org/dtds/sessionsettings-1_0.dtd" group="dtd"><samp>-//NetBeans//DTD Session settings 1.0//EN</samp></api><api name="properties-1_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/properties-1_0.dtd" group="dtd"><samp>-//NetBeans org.netbeans.modules.settings.examples//DTD XML ProxySettings 1.0//EN</samp></api><api name="RuntimeInstancesRegistry" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-settings/org/netbeans/spi/settings/package-summary.html#use-memory" group="layer">
<b>xml/memory</b>: Associates runtime instance with environment provider. </api><api name="ServicesDisplayRegistry" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-util-ui/org/openide/util/doc-files/api.html#lookup-ui" group="layer">
<b>UI/Services</b>: The root folder for displaying options in the deprecated Advanced dialog.</api></module><module name="UI Gestures Collector Infrastructure" target="org-netbeans-modules-uihandler/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
        
            XXX no answer for arch-what
        
    </description><deploy-dependencies>
        <p>
            Modules may use functionality of this module either by depending on its presence
            and registering <a href="org-netbeans-modules-uihandler/org/netbeans/modules/uihandler/api/Deactivated.html" shape="rect">callback interfaces</a> 
            provided by its API. Or the modules do not need to depend on this module at all,
            and just generate <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">log records</a>
            to the <code>UI_LOGGER_NAME_VALUE+".someloggername"</code> logger. These records are 
            then going to be consumed by this module, if enabled.
        </p>
    </deploy-dependencies><arch-usecases>
        <usecase id="gather-info" name="Gather information about UI gestures">
            <p>
                Primary purpose of this module is collect information about
                the user actions that take place in the running NetBeans based
                application.
            </p>
            
            <p>
                <api category="devel" group="logger" name="UI_LOGGER_NAME" type="export">
                    The info about various UI events in the system is collected thru
                    listening on 
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">log records</a> send to
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
                        Logger.getLogger(UI_LOGGER_NAME_VALUE)
                    </a>, where UI_LOGGER_NAME_VALUE is a value of UI_LOGGER_NAME
                    resource bundle key, defining the name of the UI usage logger.
                    Any code in the system can get instance of this logger
                    or any child logger and send useful informations to it. 
                    At the end of the session the last few hundereds events
                    is taken and displayed to the user for further processing.
                </api>
                <api category="devel" group="logger" name="METRICS_LOGGER_NAME" type="export">
                    The info about various UI events in the system is collected thru
                    listening on 
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">log records</a> send to
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
                        Logger.getLogger(METRICS_LOGGER_NAME_VALUE)
                    </a>, where METRICS_LOGGER_NAME_VALUE is a value of
                    METRICS_LOGGER_NAME resource bundle key, defining the name
                    of the metrics logger.
                    Any code in the system can get instance of this logger
                    or any child logger and send useful informations to it. 
                    At the end of the session the last few hundereds events
                    is taken and displayed to the user for further processing.
                </api>
            </p>
            
        </usecase>
        <usecase id="showing-results" name="Presenting usage statistics">
            <p>
                Important part of the behaviour of this module is the ability
                to cooperate with information analyzing tools and present their 
                results. This is done thru special HTTP contracts, where the 
                module reads and understands various server responses and is
                able to open browser after submitting data to analysis.
            </p>
            
            <p>
                <api category="private" group="property" name="WELCOME_URL" type="export">
                    There is a key in the <code>org.netbeans.modules.uihandler.Bundle</code>
                    that specifies the location of the page on a server one shall
                    query and display to the user when the module is about the
                    submit usage data for analysis.
                </api>
                <api category="private" group="property" name="METRICS_URL" type="export">
                    There is a key in the <code>org.netbeans.modules.uihandler.Bundle</code>
                    that specifies the location of the page on a server one shall
                    query and display to the user when the module is about the
                    submit metrics data for analysis.
                </api>
                <api category="private" group="property" name="ERROR_URL" type="export">
                    There is a key in the <code>org.netbeans.modules.uihandler.Bundle</code>
                    that specifies the location of the page on a server one shall
                    query and display to the user when the module is about the
                    submit an error report.
                </api>
                <api category="friend" group="java.io.File" name="WelcomePageContent" type="export">
                    The page pointed by <code>WELCOME_URL</code> can contain
                    any XHTML text, but it also should contain a &lt;form/&gt; tag 
                    that defines &lt;input type="hidden" name="submit" value="localizedName"/&gt;.
                    The <code>localizedName</code> is then going to be used for a button
                    for the dialog displaying the summary. When this button is invoked,
                    the "action" URL is then feed with data from the UI logs.
                    The server is then supposed to process the data, create 
                    some analytics pages and return them back to the client.
                    If the returned page contains tag like
                    &lt;meta http-equiv='Refresh' content='3; URL=somepage'&gt;
                    an (external) browser is opened with the specified URL and
                    the user can then interact directly with the server, thru
                    pages it serves.
                </api>
                <api category="private" group="systemproperty" name="org.netbeans.modules.uihandler.Submit" type="export">
                    
                    For testing purposes one can 
                    specify different URL for upload of files, by setting
                    <code>org.netbeans.modules.uihandler.Submit</code>
                    property when invoking NetBeans.
                </api>
            </p>
        </usecase>
        <usecase id="extending-info" name="Adding own UI gestures">
            <p>
                The base module is in fact just an infrastructure which collects
                data about UI gestures, but the actual gestures need to be delivered
                to it somehow. Here is the description of the ways how one can
                extend own modules to cooperate with this UI gestures infrastructure.
            </p>
            
            <p>
                To feed own data about special UI gestures one can just create own
                <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
                    Logger.getLogger(UI_LOGGER_NAME_VALUE+".ownname")
                </a> and send own log records to it.
                UI_LOGGER_NAME_VALUE is a value of UI_LOGGER_NAME
                resource bundle key, defining the name of the logger.
                The format of the log messages shall follow the one described by the
                <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/doc-files/logging.html" shape="rect">
                    structured logging 
                </a> document, e.g. the 
                <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">LogRecord</a>
                shall have associated 
                <a href="http://download.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html" shape="rect">ResourceBundle</a>
                and the record's <code>getMessage</code> shall point to a key
                in that bundle.
                
                <api category="devel" group="property" name="ICON_BASE" type="export">
                    there is an extension to the regular formatting done by
                    the <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Formatter.html" shape="rect">logging
                    formatter</a> that, in order to achieve nicer appearance to
                    the user, allows each record to be associated with an icon. 
                    Just define <code>MSG_KEY_ICON_BASE</code> in the bundle associated
                    with the
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">LogRecord</a>
                    (where the MSG_KEY is the string returned by <code>record.getMessage()</code>)
                    and the value is then going to be used for the 
                    <a href="http://netbeans.apache.org/javadoc/dev/org-openide-nodes/org/openide/nodes/AbstractNode.html#setIconBaseWithExtension-java.lang.String-" shape="rect">
                        Node
                    </a> representing the UI gesture.
                </api>
            </p>
            
            <p>
                Sometimes direct logging may not be possible. For example for
                performance data it might be meaningful to collect the information
                over a longer time period and only at the end output some statistics.
                This is supported as well. Just implement and register one
                of the 
                <api category="devel" group="java" name="CallbackInterfaces" type="export" url="org-netbeans-modules-uihandler/org/netbeans/modules/uihandler/api/Activated.html">interfaces from the API of this module</api> 
                and properly register
                them and the implementation will be called when the logger module
                is activated or when the user finishes the work with the application.
                In order to keep dependencies clean, it is strongly adviced 
                to make modules that implement this API 
                eager,
                so they get enabled as soon as the UI logger module is enabled.
            </p>
        </usecase>
        <p>
            These usecases are realized as described in
            <a href="org-netbeans-modules-uihandler/org/netbeans/modules/uihandler/api/doc-files/ui.html" shape="rect">
            here in provided UI specification</a>.
        </p>
    </arch-usecases><api name="UI_LOGGER_NAME" type="export" category="devel" group="logger">
                    The info about various UI events in the system is collected thru
                    listening on 
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">log records</a> send to
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
                        Logger.getLogger(UI_LOGGER_NAME_VALUE)
                    </a>, where UI_LOGGER_NAME_VALUE is a value of UI_LOGGER_NAME
                    resource bundle key, defining the name of the UI usage logger.
                    Any code in the system can get instance of this logger
                    or any child logger and send useful informations to it. 
                    At the end of the session the last few hundereds events
                    is taken and displayed to the user for further processing.
                </api><api name="METRICS_LOGGER_NAME" type="export" category="devel" group="logger">
                    The info about various UI events in the system is collected thru
                    listening on 
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">log records</a> send to
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
                        Logger.getLogger(METRICS_LOGGER_NAME_VALUE)
                    </a>, where METRICS_LOGGER_NAME_VALUE is a value of
                    METRICS_LOGGER_NAME resource bundle key, defining the name
                    of the metrics logger.
                    Any code in the system can get instance of this logger
                    or any child logger and send useful informations to it. 
                    At the end of the session the last few hundereds events
                    is taken and displayed to the user for further processing.
                </api><api name="WELCOME_URL" type="export" category="private" group="property">
                    There is a key in the <code>org.netbeans.modules.uihandler.Bundle</code>
                    that specifies the location of the page on a server one shall
                    query and display to the user when the module is about the
                    submit usage data for analysis.
                </api><api name="METRICS_URL" type="export" category="private" group="property">
                    There is a key in the <code>org.netbeans.modules.uihandler.Bundle</code>
                    that specifies the location of the page on a server one shall
                    query and display to the user when the module is about the
                    submit metrics data for analysis.
                </api><api name="ERROR_URL" type="export" category="private" group="property">
                    There is a key in the <code>org.netbeans.modules.uihandler.Bundle</code>
                    that specifies the location of the page on a server one shall
                    query and display to the user when the module is about the
                    submit an error report.
                </api><api name="WelcomePageContent" type="export" category="friend" group="java.io.File">
                    The page pointed by <code>WELCOME_URL</code> can contain
                    any XHTML text, but it also should contain a &lt;form/&gt; tag 
                    that defines &lt;input type="hidden" name="submit" value="localizedName"/&gt;.
                    The <code>localizedName</code> is then going to be used for a button
                    for the dialog displaying the summary. When this button is invoked,
                    the "action" URL is then feed with data from the UI logs.
                    The server is then supposed to process the data, create 
                    some analytics pages and return them back to the client.
                    If the returned page contains tag like
                    &lt;meta http-equiv='Refresh' content='3; URL=somepage'&gt;
                    an (external) browser is opened with the specified URL and
                    the user can then interact directly with the server, thru
                    pages it serves.
                </api><api name="org.netbeans.modules.uihandler.Submit" type="export" category="private" group="systemproperty">
                    
                    For testing purposes one can 
                    specify different URL for upload of files, by setting
                    <code>org.netbeans.modules.uihandler.Submit</code>
                    property when invoking NetBeans.
                </api><api name="ICON_BASE" type="export" category="devel" group="property">
                    there is an extension to the regular formatting done by
                    the <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Formatter.html" shape="rect">logging
                    formatter</a> that, in order to achieve nicer appearance to
                    the user, allows each record to be associated with an icon. 
                    Just define <code>MSG_KEY_ICON_BASE</code> in the bundle associated
                    with the
                    <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">LogRecord</a>
                    (where the MSG_KEY is the string returned by <code>record.getMessage()</code>)
                    and the value is then going to be used for the 
                    <a href="http://netbeans.apache.org/javadoc/dev/org-openide-nodes/org/openide/nodes/AbstractNode.html#setIconBaseWithExtension-java.lang.String-" shape="rect">
                        Node
                    </a> representing the UI gesture.
                </api><api name="CallbackInterfaces" type="export" category="devel" url="org-netbeans-modules-uihandler/org/netbeans/modules/uihandler/api/Activated.html" group="java">interfaces from the API of this module</api><api name="MSG_USER_CONFIGURATION" type="export" category="devel" group="logger">
                Before the results are submitted one more LogRecord is added. This LogRecord message is
                set to <code>MSG_USER_CONFIGURATION</code> . Four upto six parameters are added.
                Four common parameters are added always before sending logger info and two error 
                parameters are added only if an exception rised.
                
                <ul title="common parameters">
                    <li>Operating system name, version and architecture</li>
                    <li>Virtual machine name and version</li>
                    <li>Application version and build number</li>
                    <li>User name</li>
                </ul>
                <ul title="error parameters">
                    <li>Error summary</li>
                    <li>User's comment to an error situation</li>
                </ul>
            </api><api name="REGISTRATION_URL" type="export" category="private" group="property">
                There is a key in the <code>org.netbeans.modules.exceptions.Bundle</code>
                that specifies the location of the page on a server. This page 
                should be display to the user when he uses a "register here" link on ReportPanel.
            </api><api name="var-log-uigestures" type="export" category="private" group="java.io.File">
            The module stores its loggging
            information in $userdir/var/log/uigestures and 
            $userdir/var/log/uigestures.1 files. There are written whenever
            a UI action happens and read when the data are send to server.
            Each of these files is supposed to contain at most 1000 of 
            actions</api><api name="org.netbeans.modules.uihandler.autoautoSubmitWhenFull" type="export" category="devel" group="preferences">
                This property allows other parts of the system to turn on/off the
                automatic submission of log files to the server. This can be
                used for example by installer to query the user and on his
                confirmation create <code>config/Preferences/org/netbeans/modules/uihandler.properties</code>
                file in user dir or in nbX.Y cluster with one line saying:
                <code>autoSubmitWhenFull=true</code>. This works since 
                version 1.30 of this module.
            </api><api name="nb.show.statistics.ui" type="export" category="private" group="systemproperty">
            System property "nb.show.statistics.ui" controls if UI for Usage statistics is displayed in General panel.
            If this property is non null (for IDE) UI is shown. This property contains key of preference used
            to save status - true if usage statistics are collected and uploaded, false if not.
            Key is "usageStatisticsEnabled" and is described below.
        </api></module><module name="Versioning" target="org-netbeans-modules-versioning/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   The module allows SCM systems to fully integrate into the IDE workflow. 
  
 </description><deploy-dependencies>
  <p>
    No special requirements here.
  </p>
 </deploy-dependencies><arch-usecases>
     <p>
       Main and Popup Menu usecases come from the UI spec available here:         
       <a href="http://ui.netbeans.org/docs/ui/VersioningSpecification/" shape="rect">Versioning UI spec</a>
        <usecase id="1" name="Main Menu Itegration">
        All installed SCM systems must cooperate while constructing popup and main menus, see UI spec.
        </usecase>
        <usecase id="2" name="Popup Menu Itegration">
         All installed SCM systems must cooperate while constructing popup and main menus, see UI spec.
        </usecase>
        <usecase id="3" name="Coloring and Badging (annotations)">
         An SCM system needs a way to annotate labels and icons in the IDE.
        </usecase>
        <usecase id="4" name="Automated Versioning">
         To enable automated versioning (adds, removes, moves, delets), a SCM system needs to integrate at the lowest level
         into the IDE's filesystem layer. Refactoring is the most critical filesystem client here.  
        </usecase>
     </p>
 </arch-usecases><api name="VersioningSPI" type="export" category="devel" group="java">
          Enables Source Code Management (SCM or Versioning) modules to fully integrate into the IDE workflow.
      </api><api name="versioning.netbeans.user.versioned" type="export" category="private" group="property">
      NetBeans userdir is by default excluded from version control for performance reason. This can be overridden by setting the property to <code>true</code>.
  </api></module><module name="Versioning Core" target="org-netbeans-modules-versioning-core/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   No special requirements here.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
       Main and Popup Menu usecases come from the UI spec available here:         
       <a href="http://ui.netbeans.org/docs/ui/VersioningSpecification/" shape="rect">Versioning UI spec</a>
        <usecase id="1" name="Main Menu Itegration">
        All installed SCM systems must cooperate while constructing popup and main menus, see UI spec.
        </usecase>
        <usecase id="2" name="Popup Menu Itegration">
         All installed SCM systems must cooperate while constructing popup and main menus, see UI spec.
        </usecase>
        <usecase id="3" name="Coloring and Badging (annotations)">
         An SCM system needs a way to annotate labels and icons in the IDE.
        </usecase>
        <usecase id="4" name="Automated Versioning">
         To enable automated versioning (adds, removes, moves, delets), a SCM system needs to integrate at the lowest level
         into the IDE's filesystem layer. Refactoring is the most critical filesystem client here.  
        </usecase>
     </p>
 </arch-usecases><api name="FSIndependentVersioningSPI" type="export" category="friend" group="java">
        Enables to fully integrate into the IDE workflow filesystem independent Source Code Management (SCM or Versioning) modules.
    </api><api name="versioning.netbeans.user.versioned" type="export" category="private" group="property">
      NetBeans userdir is by default excluded from version control for performance reason. This can be overridden by setting the property to <code>true</code>.
  </api></module><module name="Extensible Abstract Model (XAM)" target="org-netbeans-modules-xml-xam/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
   The xam module (XAM Module) provides a framework for domain model developers
 to use when creating new models. This framework was started to encapsulate
common practices used when creating XML based models for XML schema and WSDL. 
List of the main features:

  Definition and partial implementation of both a generic and XML 
  specific model. The model supports eventing, Undo/Redo, sync, and
  simple transactions. XML based models extend generic models and add support
  for resolution.

 </description><deploy-dependencies>
  <p>
   This module was developed from the bottom up (the api is not yet stable) and
   thus a friend declaration is required before the module can be used. 
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="uc1" name="domain model developer">
       A domain model developer would determine the appropriate extension 
 package. A model outside of XML would extend org.netbeans.modules.xml.xam.AbstractModel,
 and have the components in the domain extend org.netbeans.modules.xml.xam.AbstractComponent. 
 The org.netbeans.modules.xml.xam.AbstractFactory can also be used for creation
 of models. The factory provides the creational, the model provides the entry point
 into the domain model as well as a concrete reference point to register for
 events. The component serves as the root of the domain level objects. This 
 provides some consistency across models as the original intention was to be 
 able to provide a unified model across different XML vocabularies. 
      An XML model developer would likely want to start using the XDM model 
which provides the full fidelty XML document model. This is in the xml/xdm 
module (described seperately). The XML module developer would also incorporate
the facilities for reading and writing to a catalog. This is incorporated
into methods available to subclasses in the xam.dom and xdm.xam models. The 
project based catalog facility provides the ability to support versioned 
catalog files which allow local access but URL based location attributes. 
   </usecase>
  </p>
 </arch-usecases><api name="org.netbeans.modules.xml.xam" type="export" category="devel" group="java">
Represents a domain independent model and associated artifacts such as
 a factory, source, and the concept of a reference. 
</api><api name="org.netbeans.modules.xml.xam.dom" type="export" category="devel" group="java">
Provides entities for working on XML based models. This package
depends on org.w3c packages and assumes a mapping between an xml tree and a 
strongly typed binding. This package also provides the ability to resolve other 
models 
</api></module><module name="XML Document Model (XDM)" target="org-netbeans-modules-xml-xdm/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
   The XDM module provides a basis for tool ready XML language models that require full 
document fidelity, undo/redo, and the ability to sync with the underlying source.
List of the main features:

  Support for full document fidelity. The users text including spacing and 
  comments are preserved.
  Undo / Redo is supported using the concept of an immutable tree. XDM nodes 
  do not have parent pointers (only a pointer to the model). Thus a node can
  be in multiple trees, where each tree is a version. When a mutation to the tree
  occurs a clone is made of each node in the parent path from the root to the mutated
  node. All unchanged nodes are simply referenced and thus will live in multiple
  trees. Thus an undo / redo is simply a reference change. The cost of storing
  multiple tree is minimized as only the diffs are stored in each version of the
  tree.
  The visitor pattern is used in addition to the DOM interfaces which allows 
  easier tree walking
  An XML diff visitor supports XML difference. Element identity can be 
  supplied by the client.

 </description><deploy-dependencies>
   <defaultanswer generate="here"/>
 </deploy-dependencies><arch-usecases>
  <p>
   The typical client of XDM would be a tool author supporting an XML language 
who wants to provide a custom client API. A concrete example of this is the XML 
Schema model. The XML Schema model starts by subclassing AbstractXDMModel and
providing the component updater, which is called in conjunction with sync
to mutate the model according to changes in the underlying source. 

<usecase id="uc1" name="WSDL model">
    The WSDL model is based on the XDM model and relies on the XDM capabilities
    to provide the infrastructure necessary for providing a XAM based model.
</usecase>
<usecase id="uc2" name="Schema model">
    The Schema model is based on the XDM model and relies on the XDM capabilities
    to provide the infrastructure necessary for providing a XAM based model.
</usecase>
<usecase id="uc3" name="BPEL model">
    The BPEL model is based on the XDM model and relies on the XDM capabilities
    to provide the infrastructure necessary for providing a XAM based model.
</usecase>

The XDM model can be used in standalone mode. 
<code>  <br/><br/>
        BaseDocument sd = ...;
	<br/>
        Lookup lookup = Lookups.singleton(sd);
	<br/>
	// create an editable ModelSource with base document
	<br/>
	// in the lookup (this is required)
	<br/>
	ModelSource ms = new ModelSource(lookup, true);
	<br/>
	// create an XDMModel
	<br/>
        XDMModel model = new XDMModel(ms);
	<br/>
	// sync the XDM model with the underlying source
	<br/>
        model.sync();
	<br/>
	// create customer element, same as dom
	<br/>
	Element customer = model.getDocument().createElement("customer");
	<br/>
	// add to the model as 0th child of employee element, not shown
	<br/>
        model.add(employee,customer,0);
	<br/>
</code>
  </p>
 </arch-usecases><api name="XDM" type="export" category="devel" group="java">XDM (XML Document Model)</api></module><module name="Debugger Core - UI" target="org-netbeans-spi-debugger-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The debuggercore module (Debugger Core UI) contains shared UI components for all debugger implementations, and defines some SPI
for sharing of them. 
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
<h2>UseCase I. - Install
and use CPP debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">CPP debugger plug-in installs support
for debugging of some new language to the NetBeans IDE, and some new
debugging engine. This implementation of debugger should share UI
components (actions, Debugger Views, ...) with default NB Java
Debugger. It should share basic debugger model too - notion of current
context, current session, thread, call stack line, ...</span><br/>
<br/>
CPP debugger plug-in installs:<br/>
<ul>
  <li>New set of breakpoint types - CPPLineBreakpointType,
CPPMethodBreakpointType...
  <ul>
    <li>This set of breakpoint types will have special cathegory in Add
Breakpoint Dialog called "CPP". Each breakpoint type will install a new
JPanel to Add Breakpoint Dialog.</li>
    <li>ToggleBreakpointAction on CPP files will create / remove a
instance of CPPLineBreakpointType.</li>
  </ul>
  </li>
  <li>Install some watches evaluator for CPP language.</li>
  <li>Some new View to Debugger Window</li>
  <li>Use Termilnal Emulator in Output Window as command line interface
to CPP debugger plug-in.</li>
  <li>Install / uninstall a columns to / from standard Debugger Window
Views.</li>
  <li>Redefine Nodes used for representation of CPP threads, watches,
variables, callstacks, sessions and breakpoints
  <ul>
    <li>Add / remove some properties<br/>
    </li>
    <li>Add / remove some actions</li>
    <li>change icons</li>
    <li>change display names</li>
  </ul>
  </li>
  <li>Register CPP Actions for:
  <ul>
    <li>Step Into, Over, Out, Continue, Pause, Start, Kill, Restart,
Finish</li>
  </ul>
  </li>
  <li>Some new CPP specific actions.</li>
</ul>
<br/>

<h2>UseCase II. -
Install and use JSP debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">JSP debugger plug-in installs support
for debugging of some new language to the NetBeans Java Debugger. It
does not contain a new debugger engine, but it delegates to standard NB
Java debugger. So it does not depends on Debugger Core API only, but it
depends on JavaDebugger API too.<br/>
<br/>
JSP debugger plug-in installs:<br/>
</span>
<ul>
  <li>New set of breakpoint types - JSPLineBreakpointType, ...
  <ul>
    <li>This set of breakpoint types will have special cathegory in Add
Breakpoint Dialog called "JSP". Each breakpoint type will install a new
JPanel to Add Breakpoint Dialog.</li>
    <li>ToggleBreakpointAction on JSP files will create / remove a
instance of JSPLineBreakpointType.</li>
    <li>JSPLineBreakpointType delegates all functionality to
JPDAClassBreakpoint and JPDALineBreakpoint<br/>
    </li>
  </ul>
  </li>
  <li>Some watches evaluator for JSP language expression. This
evaluator delegates evaluation of Java expressions to standard
JavaExpressionEvaluator.<br/>
  </li>
  <li>Redefine Nodes used for representation of JSP callstacks and
breakpoints
  <ul>
    <li>Add / remove some properties<br/>
    </li>
    <li>Add / remove some actions</li>
    <li>change icons</li>
    <li>change display names</li>
  </ul>
  </li>
  <li>Register JSP Actions for:
  <ul>
    <li>Step Into, Over, Out</li>
    <li>Implementation of this actions delegates to standard Java Step
actions - it redefines Java stepping functionality.</li>
  </ul>
  </li>
  <li>JSP debugger plug in adds support for new programming language
(JSP) to already running Java Session.<br/>
  </li>
</ul>
<br/>

<h2>UseCase III. -
Install and use J2EE debugger plug-in to NetBeans + Java Debugger.</h2>
<span style="font-style: italic;">J2EE debugger plug-in installs some
enhancements to the standard Java Debugger. It
does not contain a new debugger engine or language support. So it does
not depends on Debugger Core API only, but it
depends on JavaDebugger API too.<br/>
<br/>
J2EE debugger plug-in installs:<br/>
</span>
<ul>
  <li>New set of breakpoint types</li>
  <li>Filter for Threads and Callstack Views. This filter should allow
to:<br/>
  <ul>
    <li>Add / remove / modify nodes in this views.</li>
  </ul>
  </li>
  <li>Redefine Stepping (Smart Stepping) behaviour of default Java
Debugger.</li>
  <li>Some new View to Debugger Window</li>
</ul>
<br/>
<h2>UseCase IV. -
Install and use DBX debugger plug-in to NetBeans.</h2>
<span style="font-style: italic;">DBX debugger plug-in installs support
for debugging of some new language (CPP) to the NetBeans IDE, and some
new
debugging engine. But it contains debugger engine for Java debugging
too. DBX debugger engine has its own session management (or will have
in the next versions). One debugger engine can manage more than one
sessions. One engine supports debugging in more than one language.<br/>
<br/>
</span>
<h2>UseCase V. -
Implement Debugger Core UI module on top of Debugger Core API / SPI.</h2>
<span style="font-style: italic;">Debugger Core UI needs:<br/>
</span>
<ul>
  <li>List all breakpoint types and all breakpoint cathegories.</li>
  <li>Visually customize all breakpoints - some panel.</li>
  <li>Add / remove breakpoints.</li>
  <li>Add / remove watches.<br/>
  </li>
  <li>Represent breakpoints, threads, thread groups, watches, sessions,
call stack frames, locales, and fields as Nodes in NB Explorer View.</li>
  <li>List all threads, thread groups, locales, watches, breakpoints,
callstack frames, and fields.</li>
  <li>Listen on changes of hierarchy of threads, thread groups,
locales, watches, breakpoints, callstack frames, and fields.</li>
  <li>Some current context definition. Current contet should define
current session, language, thread, and call stack line.</li>
</ul>
<br/>
</arch-usecases><api name="DebuggerCoreUI-SPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-spi-debugger-ui" group="java"/></module><module name="Editor Hints" target="org-netbeans-spi-editor-hints/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
      XXX no answer.
  
 </description><deploy-dependencies>
  <p>
   Normal module dependencies are used for this module.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
      <usecase id="1" name="redunderline">
          Assume that you have a module using e.g. Parsing API to parse the source
          files and wants to mark the errors in the editor to be shown as red
          underlined in the editor. Here is the pseudo code that achieves this:
<pre xml:space="preserve">
Document doc = ...;
ArrayList&lt;ErrorDescription&gt; errors = new ArrayList&lt;ErrorDescription&gt;();
for (&lt;all errors from the parser that have parsed the doc&gt;) {
    errors.add(
        <b>ErrorDescriptionFactory.createErrorDescription</b>(
            Severity.ERROR,
            d.getMessage(Locale.getDefault()),
            doc,
            doc.createPosition(start),
            doc.createPosition(end)
        )
    );
}
<b>HintsController.setErrors</b>(doc, "myerrors", errors);
</pre>
      </usecase>
      <usecase id="2" name="warningwithfix">
          Adding a warning with fixes:
<pre xml:space="preserve">
static final class FixImpl implements Fix {
...
}
...
Document doc = ...;
List&lt;Fix&gt; <b>fixes</b> = Arrays.&lt;Fix&gt;asList(new FixImpl(...));
ArrayList&lt;ErrorDescription&gt; warnings = new ArrayList&lt;ErrorDescription&gt;();
for (&lt;all places where the warning should be displayed&gt;) {
    warnings.add(
        ErrorDescriptionFactory.createErrorDescription(
            Severity.WARNING,
            displayName,
            <b>fixes</b>,
            doc,
            doc.createPosition(start),
            doc.createPosition(end)
        )
    );
}
HintsController.setErrors(doc, "mywarnings", warnings);
</pre>
      </usecase>
  </p>
 </arch-usecases><api name="EditorHintsSPI" type="export" category="stable" url="org-netbeans-spi-editor-hints/org/netbeans/spi/editor/hints/package-summary.html" group="java">
          allows to show errors in the editor, with possible fixes.
      </api></module><module name="Java Hints SPI" target="org-netbeans-spi-java-hints/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   <usecase id="creating" name="Creating a new Java Hint">
       Simple way to create a new Java hint is as follows:
       <ul>
           <li>Create a new class, annotate it with the <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/Hint.html" shape="rect">@Hint</a>
           annotation to it.</li>
           <li>Create a <code>public static ErrorDescription hint(HintContext ctx) {}</code> method in the
           class. Annotate the method either with the <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/TriggerPattern.html" shape="rect">@TriggerPattern</a>
           annotation (strongly recommended), or with the <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/TriggerTreeKind.html" shape="rect">@TriggerTreeKind</a>.
           This method will be called when for parts of the code that match the given pattern, of for trees of the specified kinds.</li>
           <li>Perform whatever checks necessary to find out whether a warning should be produced at the given place, and produce the ErrorDescription if needed.</li>
       </ul>
       <br/>
       Tips:
       <ul>
           <li>Always use the java.hints' <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/ErrorDescriptionFactory.html" shape="rect">ErrorDescriptionFactory</a> to produce the resulting ErrorDescription.</li>
           <li>Never try to produce a custom suppress warnings "fix". Specify suppress warnings keys in the @Hint annotation.</li>
           <li>If an automated transformation is to be prodived from your hint, subclass <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/JavaFix.html" shape="rect">JavaFix</a> and
               use its <code>toEditorFix()</code> method to get the <code>Fix</code>, if the transformation is going to be used inside Inspect&amp;Transform.
           </li>
           <li>The name of the method is arbitrary, one hint can consist of more that one "triggered" method.</li>
       </ul>
   </usecase>
   <usecase id="no-class" name="Creating a new Java Hint Without a Class">
       For simple hints, it is possible to annotate the hint method with the <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/Hint.html" shape="rect">@Hint</a> annotation.
       The hint then consists of this sole method. Any number of such hints may be created in a single class.
   </usecase>
   <usecase id="testing" name="Creating a Tests for the Newly Created Java Hint">
       Creating automated tests for the hints is simple: create a test class, and use
       <a href="org-netbeans-spi-java-hints/../org-netbeans-modules-java-hints-test/org/netbeans/modules/java/hints/test/api/HintTest.html" shape="rect">HintTest</a>
       to setup the test, run the hint and verify that its outcomes are correct.
       The tests automatically run with <code>test</code> branding, so create <code>Bundle_test.properties</code>, and add
       bundle keys into it for ErrorDescription and Fix display names, to isolate the test from changes in the production
       <code>Bundle.properties</code>.
   </usecase>
   <usecase id="adding-options" name="Adding options to a Java Hint">
       To add a simple boolean option to your hint, use <a href="org-netbeans-spi-java-hints/org/netbeans/spi/java/hints/BooleanOption.html" shape="rect">@BooleanOption</a>.
   </usecase>
  </p>
 </arch-usecases><api name="spi.java.hints" type="export" category="devel" group="java">
       SPI to create custom Java hints, including code smell warnings, productivity tips, etc.
       Please see the Use Cases section for a guide on how to use this SPI.
   </api></module><module name="Navigator API" target="org-netbeans-spi-navigator/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
   Navigator module is a base API module which provides:
   
   
     A place for modules to show structure/outline of their documents
     Ability for modules to show their view only when special document(node)
     is active in the system
     UI for switching between multiple views available for currently active document(node)
     Coalescing of fast coming selected node changes to show content for
    
 </description><deploy-dependencies>
  <p>
    Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
    
   <usecase id="basicUsage" name="Basic Usage Steps">
      In order to plug in a view into Navigator UI for certain document (data) type,
      module writers need to write a <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorPanel.html" shape="rect">NavigatorPanel</a>
      implementation marked with <code>@Registration</code>.

      <h4>Writing NavigatorPanel implementation</h4>
        <p>Implementing <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorPanel.html" shape="rect">NavigatorPanel</a>
         interface is easy, you can copy from template basic implementation 
        <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/doc-files/BasicNavPanelImpl_java" shape="rect">BasicNavPanelImpl.java</a>.</p>
        
        Advices on important part of panel implementation:

        <ul>
            <li><b>Instantiation:</b> Your implementation of NavigatorPanel
            is instantied automatically by the system if you register it using <code>@Registration</code>.</li>

            <li><b>getComponent</b> method: Simply create and return your UI
            representation of your data in Swing's JComponent envelope. Just be sure
            that you don't create new JComponent subclass per every call, as
            performance will suffer then.<p/></li>

            <li><b>panelActivated and panelDeactivated</b> methods wraps an 
            'active' life of your panel implementation. In panelActivated, grab
            your data from given <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-lookup/org/openide/util/Lookup.html" shape="rect">Lookup</a>,
            usually by looking up its asociated
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a>
            or 
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-filesystems/org/openide/filesystems/FileObject.html" shape="rect">FileObject</a>
            to take data from. Also remember to attach listeners to lookup result,
            perhaps also to data itself and trigger UI update with new data.
            Code will typically look like this:<br/>
            <pre xml:space="preserve">
        /** JavaDataObject used as example, replace with your own data source */
        private static final Lookup.Template MY_DATA = new Lookup.Template(JavaDataObject.class);

        public void panelActivated (Lookup context) {
            // lookup context and listen to result to get notified about context changes
            curResult = context.lookup(MY_DATA);
            curResult.addLookupListener(/** your LookupListener impl here*/);
            Collection data = curResult.allInstances();
            // ... compute view from data and trigger repaint
        }
            </pre>
            Do *not* perform any long computation in panelActivated directly, see below.<br/>
            In panelDeactivated, be sure to remove all listeners to context given
            to you in panelActivated.<p/></li>

            <li><b>Long computation of content:</b> What if rendering your
            Navigator view takes long time, more than several milliseconds?
            Right approach is to create and run new task using
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/RequestProcessor.html" shape="rect">RequestProcessor techniques</a>, 
            each time when panelActivated call arrived or your listeners on 
            data context got called.<br/>
            While computing, UI of Navigator view
            should show some please wait message.<p/></li>
        </ul>

      <h4>Registering NavigatorPanel impl</h4>
       <p>Declarative registration of your NavigatorPanel impl connects this
        implementation with specific content type, which is type of 
        the document, expressed in mime-type syntax, for example 'text/x-java'
        for java sources. Infrastructure will automatically load and show
        your NavigatorPanel impl in UI, when <b>currently activated Node
        is backed by primary FileObject whose 
        <a href="http://netbeans.apache.org/javadoc/dev/org-openide-filesystems/org/openide/filesystems/FileObject.html#getMIMEType--" shape="rect">FileObject.getMimeType()</a>
        equals to content type specified in your registering annotation</b> (see more options below).</p>
   </usecase> 

   <usecase id="lookupHint" name="Advanced Content Registration - Linking to Node's Lookup">
        <p>There may be situations where linking between your Navigator view and
        activated Node's primary FileObject is not enough or not possible at all.
        This simply happens when the data you want to represent in Navigator are
        not accessible through primary FileObject or DataObject. Usual example is
        Multiview environment, where more views of one document exists.</p>
         
        <p>The solution is to bind content of your Navigator view directly to your
        TopComponent. Then, whenever your TopComponent gets activated in the system, Navigator UI
        will show th content you connected to it.</p>
        
        <b>Steps to do:</b>
         
        <ul>
            <li>Choose your content type, could be either well known or arbitrary,
            say <b>'text/my-amazing-type'</b> and
            do all basic steps described in above use case.<p/></li>
            
            <li>Implement <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorLookupHint.html" shape="rect">NavigatorLookupHint</a>
             interface like this:
             <pre xml:space="preserve">
        class AmazingTypeLookupHint implements NavigatorLookupHint {
            public String getContentType () {
                return "text/my-amazing-type";
            }
        }
             </pre>
             <p/></li>
             
            <li>Alter your <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html" shape="rect">TopComponent</a>
             to contain your NavigatorLookupHint implementation (AmazingTypeLookupHint in this case)
            in its lookup, returned from 
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html#getLookup--" shape="rect">TopComponent.getLookup()</a>
             method.<p/></li>
             
             <li>
             Another option you have is to alter lookup of your <code>Node</code> subclass 
             instead of directly altering lookup of your <code>TopComponent</code>.
             See <a href="http://netbeans.apache.org/javadoc/dev/org-openide-nodes/org/openide/nodes/Node.html#getLookup--" shape="rect">Node.getLookup()</a> method.
             Then Navigator will show your desired content whenever your <code>Node</code>
             subclass will be active in the system.<br/>             
             However, keep in mind that this option is less preferred, because it
             only uses implementation detail knowledge that default implementation
             of <code>TopComponent.getLookup()</code> includes also results from 
             lookup of asociated <code>Node</code>. So this approach will stop
             working if you change default behaviour of <code>TopComponent.getLookup()</code> method.
             <p/>
             </li>
             
        </ul>
   
           
   </usecase>
   
   <usecase id="activatePanel" name="Programmatic activation of NavigatorPanel">
        <p>Programmatic activation of specific navigator panel activates and shows
            navigator panel in navigation area, as if user had selected the panel
            manually. API clients are expected to use programmatic activation to
            activate/select preferred panel from a set of available panels.</p>
        <b>Example:</b>
            Several <code>TopComponents</code> in multiview arrangement,
            <code>TopComponentA</code> and <code>TopComponentB</code>.
            Both components provide the same
            <code>NavigatorLookupHint</code> impl, which is recognized by two
            providers <code>NavigatorPanelA</code> and <code>NavigatorPanelB</code>.
            Now when <code>TopComponentA</code> becomes activated (has a focus),
            it's desirable to select/show <code>NavigatorPanelA</code> from
            navigator panels. On the other side, when <code>TopComponentB</code>
            is activated, <code>NavigatorPanelB</code> should be activated automatically.
            <p/>
         
        <b>Steps to do to activate panel programmatically:</b>
         
        <ul>
            <li>Get the instance of <code>NavigatorPanel</code> implementation that
                you want to activate/show in navigator area.<br/>
                See <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/doc-files/api.html#instances" shape="rect">Instantiation rules</a>.<p/>
            </li>
            
            <li>Call <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorHandler.html#activatePanel-org.netbeans.spi.navigator.NavigatorPanel-" shape="rect">
                NavigatorHandler.activatePanel(NavigatorPanel panel)</a><p/>.
            </li>
             
        </ul>
           
   </usecase>
   
   <usecase id="activatedNode" name="Setting activated node of Navigator window">
        <p>Sometimes clients need to alter activated Nodes of Navigator window,
            to better represent Navigator area content within the whole application.
            See <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html#getActivatedNodes--" shape="rect">TopComponent.getActivatedNodes()</a>
            and <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.Registry.html#getActivatedNodes--" shape="rect">TopComponent.Registry.html#getActivatedNodes()</a>
            to find out what activated nodes of TopComponent and whole system mean.
        </p>
        <b>Use Case Example:</b>
            NavigatorPanel implementation shows list or tree of some <code>Node</code>s
            in Navigator area. When user selects a Node in the list or tree,
            it is desirable to show selected Node's properties in Properties
            window and enable proper actions in main menu. Exactly this can be done
            by presenting Node selected in the list/tree as activated Node of 
            Navigator window.
            <p/>
         
        <b>Steps to specify activated Nodes of Navigator window:</b>
         
        <ul>
            <li>In your implementation of <code>NavigatorPanel</code>, implement
                method <code>getLookup()</code> to return Lookup instance filled
                with Node(s) that you want to set as activated Nodes of Navigator window.
                <p/>
            </li>
            
            <li>Be sure to update Lookup content properly, for example using
                <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-lookup/org/openide/util/lookup/InstanceContent.html" shape="rect">InstanceContent</a> as follows:
             <pre xml:space="preserve">
        class MyNavigatorPanel implements NavigatorPanel {
        
            /** Dynamic Lookup content */
            private final InstanceContent ic;
            /** Lookup instance */
            private final Lookup lookup;
            
            public MyNavigatorPanel () {
                this.ic = new InstanceContent();
                this.lookup = new AbstractLookup(ic);
            }
        
            public Lookup getLookup () {
                return lookup;
            }

            /** Call this method when activated Nodes change is needed, 
            * for example when selection changes in your NavigatorPanel's Component
            */
            private void selectionChanged (Node oldSel, Node newSel) {
                ic.remove(oldSel);
                ic.add(newSel);
            }
            
            ... impl of rest of your NavigatorPanel
            
        }
             </pre>
            </li>
             
        </ul>
           
   </usecase>

   <usecase id="undoRedo" name="Adding UndoRedo support to the navigation view">
        <p>Some complex navigation views need support for undoing and redoing 
            edit changes done either directly in the view or in document which 
            the view is representing.
        </p>
         
        <b>Steps to support undo and redo in navigation view:</b>
         
        <ul>
            <li>Implement your navigation view as <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorPanelWithUndo.html" shape="rect">NavigatorPanelWithUndo</a>,
                which is <code>NavigatorPanel</code> interface with extra method 
                <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorPanelWithUndo.html#getUndoRedo--" shape="rect">getUndoRedo()</a>.
                <p/>
            </li>
            
            <li>All other things remain the same as with basic <code>NavigatorPanel</code> usage.
                <code>UndoRedo</code> support returned from <code>NavigatorPanelWithUndo.getUndoRedo()</code>
                is propagated to the Navigator TopComponent and returned as its
                <code>UndoRedo</code> support. For details see 
                <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html#getUndoRedo--" shape="rect">TopComponent.getUndoRedo()</a>
                and <a href="http://netbeans.apache.org/javadoc/dev/org-openide-awt/org/openide/awt/UndoRedo.html" shape="rect">UndoRedo interface</a>.
                <p/>
            </li>

            <li>Example of <code>NavigatorPanelWithUndo</code> implementation:
             <pre xml:space="preserve">
        class MyNavigatorPanelWithUndo implements NavigatorPanelWithUndo {
        
            /** UndoRedo support, substitute with your impl */
            private final UndoRedo undo = new UndoRedo.Manager();
        
            public UndoRedo getUndoRedo () {
                return undo;
            }
            
            ... rest of the NavigatorPanelWithUndo impl ...

        }
             </pre>
            </li>
             
        </ul>
           
   </usecase>

   <usecase id="panelsPolicy" name="Removing active Node/DataObject related NavigatorPanels from Navigator window">
        <p>In certain situations it's not desired to show NavigatorPanel implementations
            related to DataObject of active Node in Navigator window. Typically
            you need to have active Node of some type, so that actions in the system
            works properly. But you don't want to show NavigatorPanels that "come"
            with such active Node. 
        </p>

        <b>Steps to remove such NavigatorPanels:</b>

        <ul>
         <li>Implement interface <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorLookupPanelsPolicy.html" shape="rect">NavigatorLookupPanelsPolicy</a>,
             return kind of policy that suits you from <code>getPanelsPolicy()</code> method.
             <p/>
        </li>
         <li>Put implementation instance into your TopComponent's subclass lookup,
             see <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/org/openide/windows/TopComponent.html#getLookup--" shape="rect">TopComponent.getLookup()</a>
             for details.
             <p/>
         </li>
         <li>Now when your TopComponent becomes active in the system, found
             panels policy is used to limit/affect set of available
             <a href="org-netbeans-spi-navigator/org/netbeans/spi/navigator/NavigatorPanel.html" shape="rect">NavigatorPanel</a>
             implementations. 
             <p/>
         </li>
        </ul>

   </usecase>
   
   <usecase id="explorerView" name="Integration of Explorer view into Navigator">
        <p>Explorer views comes handy when showing Nodes in varienty of situations
            and it is just natural to be able to integrate them into Navigator window.
            Working with explorer views is described at 
            <a href="http://netbeans.apache.org/javadoc/dev/org-openide-explorer/org/openide/explorer/ExplorerUtils.html" shape="rect">ExplorerUtils javadoc</a>.
            Integration with Navigator is easy and there are only subtle differencies
            from integration into TopComponent.
        </p>
        
        <b>Steps to integrate some kind of Explorer View into Navigator:</b>
         
        <ul>
            <li>Implement <code>NavigatorPanel</code> interface and return created explorer
                view from <code>getComponent()</code> method. Creating explorer view
                is described in <a href="http://netbeans.apache.org/javadoc/dev/org-openide-explorer/org/openide/explorer/ExplorerUtils.html" shape="rect">ExplorerUtils</a>.
                <p/>
            </li>
            
            <li>Return lookup created using 
                <a href="http://netbeans.apache.org/javadoc/dev/org-openide-explorer/org/openide/explorer/ExplorerUtils.html#createLookup-org.openide.explorer.ExplorerManager-javax.swing.ActionMap-" shape="rect">
                ExplorerUtils.createLookup(ExplorerManager, ActionMap)</a> 
                from <code>getLookup()</code> method of <code>NavigatorPanel</code>.
                <p/>
            </li>
            
            <li>Use <a href="http://netbeans.apache.org/javadoc/dev/org-openide-explorer/org/openide/explorer/ExplorerUtils.html#activateActions-org.openide.explorer.ExplorerManager-boolean-" shape="rect">
                ExplorerUtils.activateActions(ExplorerManager, boolean)</a> for actions activation and
                deactivation in <code>panelActivated</code> and <code>panelDeactivated</code>.
                <p/>
            </li>
            
            <li>Take inspiration from following example code which integrates
                ListView with Navigator:
                
                <pre xml:space="preserve">
        public class ListViewNavigatorPanel extends JPanel implements NavigatorPanel, ExplorerManager.Provider {

            private ExplorerManager manager;
            private ListView listView;
            private Lookup lookup;
            private Action copyAction;

            public ListViewNavigatorPanel () {
                manager = new ExplorerManager();
                ActionMap map = getActionMap();
                copyAction = ExplorerUtils.actionCopy(manager);
                map.put(DefaultEditorKit.copyAction, copyAction);
                map.put(DefaultEditorKit.cutAction, ExplorerUtils.actionCut(manager));
                map.put(DefaultEditorKit.pasteAction, ExplorerUtils.actionPaste(manager));
                map.put("delete", ExplorerUtils.actionDelete(manager, true)); // or false

                lookup = ExplorerUtils.createLookup(manager, map);

                listView = new ListView();
                fillListView(listView);

                add(listView);
            }

            public String getDisplayName() {
                return "List view panel";
            }

            public String getDisplayHint() {
                return "List view based navigator panel";
            }

            public JComponent getComponent() {
                return this;
            }

            public void panelActivated(Lookup context) {
                ExplorerUtils.activateActions(manager, true);
            }

            public void panelDeactivated() {
                ExplorerUtils.activateActions(manager, false);
            }

            public Lookup getLookup() {
                return lookup;
            }

            public ExplorerManager getExplorerManager() {
                return manager;
            }

            private void fillListView(ListView listView) {
                try {
                    Node testNode = new AbstractNode(Children.LEAF);
                    manager.setRootContext(testNode);
                    manager.setSelectedNodes(new Node[]{testNode});
                } catch (PropertyVetoException ex) {
                    Exceptions.printStackTrace(ex);
                }
            }
        }
                </pre>
            </li>
             
        </ul>
           
   </usecase>
            
 </arch-usecases><api name="org.netbeans.spi.navigator.NavigatorPanel" type="export" category="stable" group="java"/><api name="org.netbeans.spi.navigator.NavigatorHandler" type="export" category="devel" group="java"/><api name="activated_node" type="export" category="devel" group="lookup">
     <p>
        Navigator listen to system activated node changes and sets activated
        node for Navigator top component accordingly. Local activated node is
        set from system activated node if any provider agrees to display content
        for data object behind the node. Navigator relies on default lookup
        mechanism of TopComponent to populate its activated node.
        Currently it means that if node backed by JavaDataObject is activated node
        in the system, it is also activated node for Navigator's top component.
        So main menu actions like Compile File, Move Class etc. work as usual
        when Navigator window is active.
        Also, lookup of currently selected Node is searched for NavigatorPanel
        SPI instances. 
     </p>
    </api></module><module name="Common Palette" target="org-netbeans-spi-palette/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
  The project implements a new component palette that will be reused by other
  projects. The new palette should provide a common look and feel for Form editor,
  Mobility, J2EE and possible other modules as well.
  UI draft specification is available at http://ui.netbeans.org/docs/ui/palette/index.html
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
    <usecase id="content" name="Palette Content">
        <p>The Common Palette content is a two-level hierarchy. The top-most level
        are <b>Categories</b>, the Category children are <b>Items</b>. It's 
        possible to select (highlight) items in the palette panel using a mouse
        or keyboard and then inserted/dropped into an editor that supports the palette.</p>
        <p>The palette content can come from two different sources:</p>
        <ul>
            <li><b>Folders and files hierarchy defined in XML layer:</b> folders under
            palette's root folder represent categories, files in category folders are palette
            item. This way of creating of palette content is more convenient for module
            developers as very little extra coding is required to setup a palette.</li>
            <li><b>An arbitraty hierarchy of generic Nodes:</b> the children of palette's
            root Node are categories and the children of a category Node are palette items.
            This approach is more flexible when the palette content must change dynamically
            (e.g. according to cursor position in editor window) however more coding
            may be needed to setup the Node hierarchy. Please see Nodes API for more
            details on Node management.</li>
        </ul>
    </usecase>
    
      <usecase id="basic_xml" name="Basic usage">
          <p>The following steps must be taken if a module wants to define its own palette
          content as a hierarchy of folders and files in its XML layer:</p>
          <ul>
              <li>Define palette's root folder in module's layer and also define subfolders for 
              categories and file objects for palette items.<br/>Example:<br/>
              <pre xml:space="preserve">
      &lt;filesystem&gt;
          &lt;folder name="MyModulePalette"&gt;
              &lt;folder name="Category1"&gt;
                  &lt;file name="PaletteItem_1.myitem" url="palette/PaletteItem_1.xml" /&gt;
                  &lt;file name="PaletteItem_2.myitem" url="palette/PaletteItem_2.xml" /&gt;
                  &lt;file name="PaletteItem_3.myitem" url="palette/PaletteItem_3.xml" /&gt;
              &lt;/folder&gt;
              &lt;folder name="Category2"&gt;
                  &lt;file name="PaletteItem_4.myitem" url="palette/PaletteItem_4.xml" /&gt;
                  &lt;file name="PaletteItem_5.myitem" url="palette/PaletteItem_5.xml" /&gt;
                  &lt;file name="PaletteItem_6.myitem" url="palette/PaletteItem_6.xml" /&gt;
              &lt;/folder&gt;
          &lt;/folder&gt;
      &lt;/filesystem&gt;
              </pre>
              <br/>Note: it's necessary to define some way of loading of the palette item
              from e.g. XML files. There are several possible ways to achieve that, 
              please refer to DataLoaders API for more details.
              </li>
              <li>Extend <a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteActions.html" shape="rect">PaletteActions</a> 
                class that provides custom Actions for palette's popup menus.
                <br/>Example:<br/>
                <pre xml:space="preserve">
        class MyPaletteActions extends PaletteActions {

            public Action getPreferredAction(Lookup lookup) {
                Node itemNode = (Node)lookup.lookup( Node.class );
                if( null != itemNode ) {
                    return new InsertItemAtDefaultLocationAction( itemNode );
                }
                return null;
            }

            public Action[] getCustomItemActions(Lookup lookup) {
                Node itemNode = (Node)lookup.lookup( Node.class );
                if( null != itemNode ) {
                    return new Action[] { new CustomizeItemAction( itemNode ) };
                }
                return null;
            }

            public Action[] getCustomCategoryActions(Lookup lookup) {
                Node categoryNode = (Node)lookup.lookup( Node.class );
                if( null != categoryNode ) {
                    return new Action[] { new CustomizeCategoryAction( categoryNode ) };
                }
                return null;
            }

            public Action[] getImportActions() {
                return new Action[] { new ImportItemsFromWebAction() };
            }

            public Action[] getCustomPaletteActions() {
                return null; //no custom actions for palette's root
            }
        }
                </pre>
              
              </li>
              <li>Use <a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteFactory.html" shape="rect">PaletteFactory</a>
               to create an instance of PaletteController. The editor module keeps
              a reference to this object and registers a PropertyChangeListner to it to be notified
              of palette's selection changes.<br/>Example:<br/>
              <pre xml:space="preserve">
        class MyClass {
            PaletteController controller;

            PaletteController initializePalette() {
                try {
                    controller = PaletteFactory.createPalette( "MyPalette", new MyPaletteActions() );
                } catch (IOException ex) {
                    ex.printStackTrace();
                    return;
                }

                controller.addPropertyChangeListener( new PropertyChangeListener() {
                    public void propertyChange(PropertyChangeEvent evt) {
                        if( PaletteController.PROP_SELECTED_ITEM.equals( evt.getPropertyName() ) ) {
                            Lookup selItem = controller.getSelectedItem();
                            if( null == selItem ) {
                                //nothing is selected in palette
                            } else {
                                Node selNode = (Node)selItem.lookup( Node.class );
                                if( null != selNode ) {
                                    //change mouse cursor for editor window to indicate 
                                    //the type of palette item that can be dropped
                                    changeCursorInEditorWindow( selNode );
                                }
                            }
                        }
                    }
                });
                return controller;
            }
        }
              </pre>
              
              </li>
              <li>Add the instance of 
                <a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteController.html" shape="rect">PaletteController</a> 
                to the lookup of editor's TopComponent.<br/>
              <pre xml:space="preserve">
        class MyEditorTopComponent extends TopComponent {

            private MyEditorTopComponent() {
                this( new InstanceContent() );
            }

            private MyEditorTopComponent( InstanceContent content ) {
                super( new AbstractLookup( content ) );
                content.add( initializePalette() );

                initEditorComponents();
            }

            PaletteController controller;
            private PaletteController initializePalette() {
                if( null == controller ) {
                    controller = PaletteFactory.createPalette( "MyPalette", new MyPaletteActions() );
                }
                return controller;
            }
        }
              </pre>
              </li>
          </ul>
          <p>
              When an item is selected in the palette and user clicks into the editor window
              then the module can ask for selected item by calling 
              <a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteController.html#getSelectedItem--" shape="rect">PaletteController.getSelectedItem()</a>.
              This method returns a Lookup that holds object(s) representing the selected item.
              After the item is inserted into the editor window the module may clear palette's selection
              (<a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteController.html#clearSelection--" shape="rect">PaletteController.clearSelection()</a>)
              or leave the item selected to implement 'multi drop' insertion scenario.
          </p>
      </usecase>
  </p>
  <p>
    <usecase id="filter" name="Filtering">
        <p>It is possible to filter palette content and hide some categories and/or
           items from the user by extending <a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteFilter.html" shape="rect">PaletteFilter</a> class.
           </p>
           <pre xml:space="preserve">
       class MyPaletteFilter extends PaletteFilter {

            public boolean isValidItem(Lookup lookup) {
                Node itemNode = (Node)lookup.lookup( Node.class );
                return isItemVisibleInCurrentEditorContext( itemNode );
            }

            public boolean isValidCategory(Lookup lookup) {
                Node categoryNode = (Node)lookup.lookup( Node.class );
                return isCategoryVisibleInCurrentEditorContext( categoryNode );
            }

            private boolean isItemVisibleInCurrentEditorContext( Node item ) {
                boolean res = true;
                //check current cursor positions and/or item type and decide whether
                //the item is valid, i.e. can be selected and dropped into editor
                return res;
            }

            private boolean isCategoryVisibleInCurrentEditorContext( Node item ) {
                boolean res = true;
                //check current cursor positions and/or category type and decide whether
                //the category is valid, i.e. its items can be selected and dropped into editor
                return res;
            }
          </pre>
          <p>Then initialize the palette using the following method:</p>
          <pre xml:space="preserve">
                MyPaletteFilter filter = new MyPaletteFilter();
                PaletteController controller = PaletteFactory.createPalette( "MyPalette", new MyPaletteActions(), filter, null );
          </pre>
          <p>It is necessary to call 
          <a href="org-netbeans-spi-palette/org/netbeans/spi/palette/PaletteController.html#refresh--" shape="rect">PaletteController.refresh()</a>
          to refresh and repaint the palette window whenever the filtering condition has changed:</p>
          <pre xml:space="preserve">
              myPaletteFilter.setShowSomeSpecialCategories( false );
              paletteController.refresh();
          </pre>
    </usecase>
  </p>
  <p>
    <usecase id="settings" name="Default Settings">
        <p>The initial state of the palette can be overridden by setting appropriate
           attributes to palette model. The list of supported attributes is defined
           in PaletteController class. If the palette model is create from Nodes then
           the attributes are extracted by calling Node.getValue() method on the root
           Node and category and item nodes. If the palette model is defined as folders
           and files in the layer then the attributes are extracted by calling 
           FileObject.getAttribute().</p>
           <p>In the example below the palette will not show item names initially 
            (only icons are visible), the user can change this in palette's context menu.
            Category1 is read-only therefore the user cannot remove it.
            Category2 is not initially visible, the user can change this in
            palette's customizer.
            <br/></p>
            <pre xml:space="preserve">
      &lt;filesystem&gt;
          &lt;folder name="MyModulePalette"&gt;
              &lt;attr name="showItemNames" stringvalue="false"/&gt;

              &lt;folder name="Category1"&gt;
                  &lt;attr name="isReadonly" stringvalue="true"/&gt;

                  &lt;file name="PaletteItem_1.myitem" url="palette/PaletteItem_1.myitem" /&gt;
                  &lt;file name="PaletteItem_2.myitem" url="palette/PaletteItem_2.myitem" /&gt;
                  &lt;file name="PaletteItem_3.myitem" url="palette/PaletteItem_3.myitem" /&gt;
              &lt;/folder&gt;

              &lt;folder name="Category2"&gt;
                  &lt;attr name="isVisible" stringvalue="false"/&gt;

                  &lt;file name="PaletteItem_4.myitem" url="palette/PaletteItem_4.myitem" /&gt;
                  &lt;file name="PaletteItem_5.myitem" url="palette/PaletteItem_5.myitem" /&gt;
                  &lt;file name="PaletteItem_6.myitem" url="palette/PaletteItem_6.myitem" /&gt;
              &lt;/folder&gt;
          &lt;/folder&gt;
      &lt;/filesystem&gt;
            </pre>
    </usecase>
  </p>

    <p>
    <usecase id="newcontentatruntime" name="Adding categories and items at runtime">
        <p>It is possible to add new palette categories and/or palette item at runtime
        when the palette window is already visible.</p>
        <p>Adding a <strong>new category</strong> is very straight-forward, it basically means creating
        a new folder under palette's root folder in XML layer:</p>
        <pre xml:space="preserve">
        FileObject paletteRoot = FileUtil.getConfigFile( "MyModulePalette" );
        paletteRoot.createFolder( "NewCategory" );
        </pre>
        <p>Adding a <strong>new item</strong> is a similar task:</p>
        <pre xml:space="preserve">
        FileObject paletteRoot = FileUtil.getConfigFile( "MyPalette" );
        FileObject targetCategoryFO = paletteRoot.getFileObject( "CategoryName" );
        DataFolder targetCategoryDF = DataFolder.findFolder( targetCategoryFO );
        DataObject dobj = (DataObject)itemNode.getLookup().lookup( DataObject.class );
        dobj.copy( targetCategoryFolder );
        </pre>
        
        <p>Please refer to Nodes API in case the palette content is defined as a 
        hierarchy of arbitrary Nodes.</p>
    </usecase>
  </p>

  <p>
    <usecase id="items" name="Palette content for text-based editors">
        <p>The following steps must be taken when writing the item using the support provided by this module:</p>
            <ol>
                <li>
                    Create XML file with item definition according to 
                    the <a href="org-netbeans-spi-palette/architecture-summary.html#dtd-editor-palette-item-1_0.dtd" shape="rect">editor-palette-item-1_0.dtd</a>.
                </li>
                <li>
                    Register it in the editor's layer file (see Basic usage).
                </li>
                <li>
                    Provide custom item implementation of the ActiveEditorDrop interface if needed. I must be
                    referenced from the definition file.
                </li>
            </ol>
    </usecase>
  </p>
 </arch-usecases><api name="Palette" type="export" category="stable" url="org-netbeans-spi-palette/overview-summary.html" group="java"/><api name="editor-palette-item-1_0.dtd" type="export" category="stable" url="http://www.netbeans.org/dtds/editor-palette-item-1_0.dtd" group="dtd"/><api name="org-netbeans-modules-palette.jar" type="export" category="stable" group="java.io.File"/><api name="user_settings" type="export" category="private" group="layer">
        <p>
            There's a private XML file for user settings for each palette model.
        </p>
    </api><api name="activated_node" type="export" category="stable" group="lookup">
     <p>
        Palette listens to system activated node changes. The palette TopComponent
        opens when an editor TopComponent with a PaletteController instance in its Lookup
        is opened or activated. Palette window closes when the editor window is closed
        or deactivated and no other visible editor window supports the palette.<br/>
        The palette window always shows the content from the last active editor 
        window regardless where the input focus is. The palette content is updated
        when user activates a different editor window that supports the palette.
     </p>
    </api><api name="node_represention" type="export" category="stable" group="lookup">
        The palette item implementor can either directly provide the item body 
        or her own item class implementing <code>org.openide.text.ActiveEditorDrop</code> interface.
        <br/>
        Lookup that holds object(s) representing the selected item then associates 
        custom item class instance with the <code>org.openide.text.ActiveEditorDrop.class</code> key and 
        the body with <code>java.lang.String</code> key.
        <br/>
        Editor side implementor can use the Lookup content whenever the Lookup is given, 
        namely in the editor-provided implementations of the <code>PaletteActions</code>,
        <code>DragAndDropHandler</code> and <code>PropertyChangeListener</code> (registered 
        on the <code>PaletteController</code>) interfaces.
    </api></module><module name="Quick Search API" target="org-netbeans-spi-quicksearch/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
    QuickSearch API and its implementations provides way for end user to learn
    system earlier and easier and also to find various things in the system more
    quickly, conveniently and in standard way.
    Main project page is on nb wiki, http://wiki.netbeans.org/QuickSearch
  
 </description><deploy-dependencies>
  <p>
    Nothing, regular depencency is enough.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
      
   <usecase id="newProvider" name="How To Add New Quick Search Provider">
      In order to plug in a new Quick Search provider and new category of results,
      module writers need to complete following steps:

      <h5>1. Implement <a href="org-netbeans-spi-quicksearch/org/netbeans/spi/quicksearch/SearchProvider.html" shape="rect">SearchProvider</a></h5>
        <ul>
            <li>Implement body of <b><code>SearchProvider.evaluate</code></b> method
            like suggested in its <a href="org-netbeans-spi-quicksearch/org/netbeans/spi/quicksearch/SearchProvider.html" shape="rect">javadoc</a>.
            </li>
        </ul>
      
      <h5>2. Register SearchProvider implementation in xml layer</h5>
            Register your SearchProvider implementation in your module's xml layer file under
            main <b>"/QuickSearch"</b> folder. Registration xml syntax is following:
            
            <pre xml:space="preserve">
              &lt;folder name="QuickSearch"&gt;
                  &lt;folder name="Category1_ID"&gt;
                      &lt;attr name="position" intvalue="300"/&gt;
                      &lt;file name="org-netbeans-module1-package1-Provider1Impl.instance"/&gt;
                  &lt;/folder&gt;
                  &lt;folder name="Category2_ID"&gt;
                      &lt;!--Attribute for localization - provide localized display name of category!--&gt;
                      &lt;attr name="SystemFileSystem.localizingBundle" stringvalue="org.netbeans.modules.yourmodule.YourBundle"/&gt;
                      &lt;!--Attribute for command prefix - used to narrow search to this category only!--&gt;
                      &lt;attr name="command" stringvalue="p"/&gt;
                      &lt;!--Attribute for category ordering!--&gt;
                      &lt;attr name="position" intvalue="200"/&gt;
                      &lt;!--Note that multiple providers can contribute to one category!--&gt;
                      &lt;file name="org-netbeans-module2-package2-Provider2Impl.instance"/&gt;
                      &lt;file name="org-netbeans-module2-package3-Provider3Impl.instance"/&gt;
                  &lt;/folder&gt;
              &lt;/folder&gt;
            </pre>
            
            <b>Syntax explanation:</b>
            <ul>
                <li>Subfolders of "QuickSearch" define search result categories and their order.</li>
                <li>Providers can share category by putting themselves under same subfolder.</li>
                <li>Ordering of categories is done through NetBeans standard FileSystem API ordering 
                "position" attribute</li>
                <li>Display name of category folder uses NetBeans standard FileSystem API
                "SystemFileSystem.localizingBundle" attribute.</li>
                <li>"command" attribute defines command prefix for category, which is used
                to narrow Quick Search to only one category. Provide short prefix, ideally
                containing one or two prefix, that will serve as command to narrow search
                only this category. In above syntax example, if
                user types 'p' and space key and then text, only "Category2_ID" category
                will be searched.</li>
                <li>If several providers share one category, then only one provider needs to
                specify above attributes. Note however that if your provider shares
                category with provider from different module, you should have dependency
                on module which actually define those attributes. Dependency assures
                there will always be category "description" for category that you are
                sharing.</li>
            </ul>
        
   </usecase> 
   
   <usecase id="shareCategory" name="How To Share Category Of Results">
       <p>Quick Search UI shows search results divided into visually separeted sections,
       called categories. Several <code>SearchProvider</code> implementations may decide to display
       their results in one shared category of results in Quick Search UI.</p>
       
       <p>In order to share category, module writers have to agree on shared
          category and its properties, especially its name.
          It means that all providers (possibly in different NetBeans modules)
          need to be registered under the same folder, as shown below:</p>
       
       <h5>Provider 1</h5>   
            Provider 1 is category "owner", which defines properties of <code>SharedCategory</code> such as 
            display name, position and command prefix.
            <pre xml:space="preserve">
              &lt;folder name="QuickSearch"&gt;
                  &lt;folder name="SharedCategory"&gt;
                      &lt;attr name="SystemFileSystem.localizingBundle" stringvalue="org.netbeans.modules.yourmodule.YourBundle"/&gt;
                      &lt;attr name="command" stringvalue="p"/&gt;
                      &lt;attr name="position" intvalue="200"/&gt;
                      &lt;file name="org-netbeans-module1-package1-Provider1Impl.instance"&gt;
                          &lt;attr name="position" intvalue="300"/&gt;
                      &lt;/file&gt;                          
                  &lt;/folder&gt;
              &lt;/folder&gt;
            </pre>

       <h5>Provider 2</h5>   
            Other providers from other modules are sharing category with Provider 1.
            Provider 2 does not define properties of <code>SharedCategory</code>,
            as they were already defined by Provider 1.
            Note that module dependency on the module of Provider 1 is needed
            to ensure that <code>SharedCategory</code> is fully defined.
            <pre xml:space="preserve">
              &lt;folder name="QuickSearch"&gt;
                  &lt;folder name="SharedCategory"&gt;
                      &lt;file name="org-netbeans-module2-package2-Provider2Impl.instance"/&gt;
                          &lt;attr name="position" intvalue="200"/&gt;
                      &lt;/file&gt;                          
                  &lt;/folder&gt;
              &lt;/folder&gt;
            </pre>

       <h5>Provider 3</h5>   
            The same rules apply like for Provider 2. Note that position attribute
            can be used to control position of provider's results in shared category.
            Results from provider with lowest position will go first and so on.
            <pre xml:space="preserve">
              &lt;folder name="QuickSearch"&gt;
                  &lt;folder name="SharedCategory"&gt;
                      &lt;file name="org-netbeans-module2-package3-Provider3Impl.instance"/&gt;
                          &lt;attr name="position" intvalue="100"/&gt;
                      &lt;/file&gt;                          
                  &lt;/folder&gt;
              &lt;/folder&gt;
            </pre>
   </usecase>

   <usecase id="categoryOrder" name="How To Define and Modify Order of Categories">
        Order of categories of results can be set by using "position" attribute
        of category xml folder definition. Following example will result in 
        <code>FirstCategory</code> to be first, and <code>SecongCategory</code> to be second :),
        which means that <code>FirstCategory</code> and its results will be
        displayed above <code>Secondcategory</code> in QuickSearch results window.

            <pre xml:space="preserve">
              &lt;folder name="QuickSearch"&gt;
                  &lt;folder name="SecondCategory"&gt;
                      &lt;attr name="position" intvalue="300"/&gt;
                      ...
                  &lt;/folder&gt;
                  &lt;folder name="FirstCategory"&gt;
                      &lt;attr name="position" intvalue="200"/&gt;
                      ...
                  &lt;/folder&gt;
             &lt;/folder&gt;
            </pre>
   </usecase>
   
   <usecase id="hideProvider" name="How To Hide Recent Searches Results and Others">
        "Recent Searches" provider is contained directly in <code>spi.quicksearch</code>
        module, so its functionality is automatically always available by default.
        However, if your module wants to disable "Recent Searches" or any other
        category, follow the steps below:
        
        <h5>Define module dependency</h5>
            Your module have to depend on module where provider you want to disable
            is contained. In case of "Recent Searches" provider, it's <code>spi,quicksearch</code>,
            on which you probably already depend.

        <h5>Disable provider using "_hidden"</h5>
            For example, to disable "Recent Searches" provider, write into your layer:
            
            <pre xml:space="preserve">
              &lt;folder name="QuickSearch"&gt;
                  &lt;folder name="Recent_hidden"&gt;
                  &lt;/folder&gt;
              &lt;/folder&gt;
           </pre>
           
           "Recent" is a name of category for "Recent Searches" provider and by appending
           "_hidden" suffix you are telling system to "hide" it. This technique
           can be used also to disable invidual search providers.
    </usecase>
    
   <usecase id="usageInPlatform" name="How To Use Quick Search in Platform Application">
        Quick Search UI is disabled by default in application built on top of
        NetBeans platform. To enable Quick Search feature in your application,
        complete following steps:
        
        <h5>1. Write XML layer registration</h5>
            Add the following lines to XML layer of some of your modules in your
            application suite:
        
        <pre xml:space="preserve">
        &lt;folder name="Toolbars"&gt;
            &lt;folder name="QuickSearch"&gt;
            &lt;attr name="SystemFileSystem.localizingBundle" stringvalue="com.myapp.mymodule.MyBundle"/&gt;
                &lt;file name="org-netbeans-modules-quicksearch-QuickSearchAction.shadow"&gt;
                    &lt;attr name="originalFile" stringvalue="Actions/Edit/org-netbeans-modules-quicksearch-QuickSearchAction.instance"/&gt;
                &lt;/file&gt;
            &lt;/folder&gt;
        &lt;/folder&gt;
        </pre>
        
        <h5>2. Localize Toolbar Name</h5>
             Replace <code>com.myapp.mymodule.MyBundle</code> in the xml registration
             above with path to your properties file, in which you'll define
             localized name of Quick Search toolbar:
             <pre xml:space="preserve">
                Toolbars/QuickSearch=Quick Search
             </pre>
        
        <p>By default, providers for searching in actions and recent searches
        will be enabled. Web search provider is disabled by default, see use case
        below for info how to turn it on.</p>
   </usecase>

   <usecase id="searchWebProvider" name="How To Add a Default Web Search Provider">
       There is a default implementation of web search provider which uses Google
       to search for the given text on the web. Simply add the following lines to your XML layer 
       to enable this search provider in your application:
        <pre xml:space="preserve">
          &lt;folder name="QuickSearch"&gt;
              &lt;folder name="WebSearch"&gt;
                  &lt;!--Attribute for localization - provide localized display name of category!--&gt;
                  &lt;attr name="SystemFileSystem.localizingBundle" stringvalue="com.myapp.mymodule.MyBundle"/&gt;
                  &lt;!--Attribute for command prefix - used to narrow search to this category only!--&gt;
                  &lt;attr name="command" stringvalue="g"/&gt;
                  &lt;!--Attribute for category ordering!--&gt;
                  &lt;attr name="position" intvalue="200"/&gt;
                  &lt;!--Note that multiple providers can contribute to one category!--&gt;
                  &lt;file name="org-netbeans-modules-quicksearch-web-WebQuickSearchProviderImpl.instance"/&gt;
              &lt;/folder&gt;
          &lt;/folder&gt;
        </pre>
        You can also add branding for <code>org.netbeans.modules.quicksearch.web</code> Bundle to restrict 
        the search to a particular site only:
        <pre xml:space="preserve">
            quicksearch.web.site=mywebsite.com
        </pre>
        And you can also restrict the search to some parts your website only:
        <pre xml:space="preserve">
            quicksearch.web.url_patterns=mywebsite.com/docs,mywebsite.com/files/tutorials
        </pre>
   </usecase>
   
   <usecase id="customizeLookAndFeel" name="How to customize Look&amp;Feel properties">
        If you need to adjust border of the Quick Search component for your
        Look&amp;Feel, you can put a <code>Border</code> instance into
        <code>UIManager</code> under key <code>nb.quicksearch.border</code>.
   </usecase>
  </p>
 </arch-usecases><api name="SearchProvider" type="export" category="official" url="org-netbeans-spi-quicksearch/org/netbeans/spi/quicksearch/SearchProvider.html" group="java"/><api name="SearchRequest" type="export" category="official" url="org-netbeans-spi-quicksearch/org/netbeans/spi/quicksearch/SearchRequest.html" group="java"/><api name="SearchResponse" type="export" category="official" url="org-netbeans-spi-quicksearch/org/netbeans/spi/quicksearch/SearchResponse.html" group="java"/><api name="quicksearch.web.site" type="export" category="devel" group="property">
     Resource name from org.netbeans.modules.quicksearch.web.Bundle where it is 
     possible to specify website to restrict the web search to. When set to e.g.
     NetBeans.org then the web search provider will search for given text in web pages
     from NetBeans.org site only.
</api><api name="quicksearch.web.url_patterns" type="export" category="devel" group="property">
     Resource name from org.netbeans.modules.quicksearch.web.Bundle where it is 
     possible to specify a comma separated list of regular expressions that the search results URLs 
     must contain. When set to e.g. ".*docs/myapp.*,.*tutorials/myapp.*" then all the search
     results will have either "docs/myapp" or "tutorials/myapp" anywhere in the URL.
</api></module><module name="Task List API" target="org-netbeans-spi-tasklist/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   This module provides SPI for third parties that want to display some sort information for 
    the user in the Task List / Problems window. A typical example are Java errors, warnings, TODOs etc.
  
    Part of the integration are several implementation modules that provider task list user interface,
    TODO task scanning, Java integration.
 </description><deploy-dependencies>
  <p>
   no special dependency declarations
  </p>
 </deploy-dependencies><arch-usecases>
    <usecase id="task-scanners" name="Task Scanners">
        <p>The main feature of the Task List SPI is the ability to 'plug-in' additional task providing 
        modules that generate tasks for the task list window.</p>
        <p>The plugable task scanners can either <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/PushTaskScanner.Callback.html#setTasks-org.openide.filesystems.FileObject-java.util.List-" shape="rect">push</a> 
        new <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/Task.html" shape="rect">Task</a>s to the Task List window whenever they want - 
        <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/PushTaskScanner.html" shape="rect">PushTaskScanner</a> - or they
        can inherit from <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/FileTaskScanner.html" shape="rect">FileTaskScanner</a>
        and the Task List framework will actively <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/FileTaskScanner.html#scan-org.openide.filesystems.FileObject-" shape="rect">poll</a> 
        them for new tasks for each file under the current scanning scope (see below).</p>
        <p>Scanner instances are registered in XML layer in folder "/TaskList/Scanners". The framework keeps track of modified files
        and notifies the scanners whenever a file under the scanning scope needs to be rescanned.</p>
    </usecase>
    <usecase id="scanning-scope" name="Task Scanning Scope">
        <p>Scanning scope defines which files/folders will be scanned for tasks. The default implementation
        includes scopes for currently edited file, scope for files and folders in the main project and projects 
        that depend on it and scope for all opened projects.</p>
        <p>Additional scopes may be provided by extending 
        <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/TaskScanningScope.html" shape="rect">TaskScanningScope</a> class
        and registering instances in folder "/TaskList/ScanningScopes" in XML layer.</p>
    </usecase>
    <usecase id="groups" name="Task Groups">
        <p>Tasks are organized into Groups according to their importance. Each task can be in one group only.
        The default implementation includes "Error", "Warning" and "TODO" groups. Additional groups can be
        registered in XML layer in folder "/TaskList/Groups". Each task group is identified by its unique name.</p>
    </usecase>
 </arch-usecases><api name="TaskListSPI" type="export" category="official" url="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/package-summary.html" group="java">
        
    </api><api name="TaskListXMLLayer" type="export" category="official" group="layer">
        <p>Task List framework defines the following folders in XML layer:
        <br/>
        <br/>
        <em>/TaskList/Scanners</em> - register your instances of task scanners here<br/>
        <em>/TaskList/ScanningScopes</em> - here you can add additional scanning <a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/TaskScanningScope.html" shape="rect">scopes</a> <br/>
        <em>/TaskList/Groups</em> - here you can define additional task groups, for example:  <br/>
            <samp>
                 <br/>
                &lt;folder name="TaskList"&gt; <br/>
                     &lt;folder name="Groups"&gt; <br/>
                          &lt;file name="mygroup.instance"&gt; <br/>
                               &lt;attr name="instanceCreate" methodvalue="org.netbeans.spi.tasklist.Task.createGroup"/&gt; <br/>

                               &lt;attr name="localizingBundle" stringvalue="org.mymodule.resources.Bundle"/&gt; <br/>
                               &lt;attr name="groupName" stringvalue="my-unique-group-name"/&gt; <br/>
                               &lt;attr name="diplayNameKey" stringvalue="LBL_my_group"/&gt; <br/>
                               &lt;attr name="descriptionKey" stringvalue="HINT_my_group"/&gt; <br/>
                               &lt;attr name="iconKey" stringvalue="ICON_my_group"/&gt; <br/>
                          &lt;/file&gt; <br/>
                     &lt;/folder&gt; <br/>
                &lt;/folder&gt; <br/>
 <br/>
            </samp>
        </p>
    </api><api name="TaskGroups" type="export" category="official" group="layer">
        <p><a href="org-netbeans-spi-tasklist/org/netbeans/spi/tasklist/Task.html" shape="rect">Task</a>s are organized into groups according 
        to their importance (error/warning/todo etc). The task group is specified when the Task is created.
        Each group is identified by its unique name. The Task List framework provides the following groups:
        
        <br/>
        <br/>
        <em>"nb-tasklist-error"</em> - for error-type tasks <br/>
        <em>"nb-tasklist-warning"</em> - for warning-type tasks
        
    </p> <p>Additional task groups can be specified in xml layers, see above.</p>
    </api></module><module name="TreeTableView Model" target="org-netbeans-spi-viewmodel/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The debuggercore/<api-ref name="ViewModel"/>
 module (View Model) allows to share one TreeTableView among different modules.
</description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
Used by debugger to display various information - threads, call stack, variables, etc.
</arch-usecases><api name="ViewModel" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-netbeans-spi-viewmodel/overview-summary.html" group="java"/></module><module name="ETable and Outline" target="org-netbeans-swing-outline/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   Nothing
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="ETable" type="export" category="devel" url="org-netbeans-swing-outline/org/netbeans/swing/etable/ETable.html" group="java">ETable</api><api name="Outline" type="export" category="devel" url="org-netbeans-swing-outline/org/netbeans/swing/outline/Outline.html" group="java">Outline</api></module><module name="Look &amp; Feel Customization Library" target="org-netbeans-swing-plaf/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
	The plaf library consists primarily of code that used to be in core.  What it does:
        
	Installs a custom look and feel if a custom look and feel class is passed to it
        Sets the correct fonts in the Swing UIDefaults if a custom fontsize is desired for the application's UI
        Loads a UI theme if a URL for the theme file (no format changes since NetBeans 3.4) is passed to it
        Installs custom UI keys and values used by other components of NetBeans, such as colors and UI delegate class names used by
   	    other parts NetBeans.  Examples of these:
             
               Tab control UI delegate class name, depending on the look and feel, for the window system
               Definitions of colors which the tab control, property sheet and output window will use, if present in
                   UIDefaults, to color themselves in accordance with the UI spec for them on a given look and feel
               Custom border implementations NetBeans uses for scroll panes to reduce "border-buildup"
               A custom implementation of ToolbarUI which NetBeans uses for its toolbars, and a custom UI for 
                   toolbar buttons which sizes them correctly (GTK and Aqua only, currently)
               Insets definition for the editor scrollbar, used to get the height of the upper and lower button of the scrollbar
                   for purposes of the Error Stripe. The appropriate key value is "Nb.Editor.ErrorStripe.ScrollBar.Insets".
               
             
         
         Compensate for missing elements on some (GTK) look and feels, which standard Swing code expects to be
             present, i.e. UIManager.getColor ("control"), to enable older code to run unmodified on newer
             look and feels.
         
    

    Its API consists of a single method, org.netbeans.swing.plaf.Startup.run (Class lookAndFeel, int fontSize, URL themeFile),
    which should be called early in NetBeans startup sequence by core, to initialize UIDefaults values before any main window
    GUI is constructed.  It provides a minimal SPI in the form of the abstract class LFCustoms, which an alternate look and
    feel could use to provide lists of keys and values which should be installed into UIDefaults, via the mechanism documented
    in the documentation for LFCustoms.

        <api-ref name="PlafAPI"/>
    </description><deploy-dependencies>
Components such as the window system, which use values defined here, will behave in a reasonable
way if those values are not defined.  However, it is preferable that they declare a runtime
dependency on the plaf library.
</deploy-dependencies><arch-usecases>
Used by NetBeans to customize the UI to conform to UI design specifications;  can be used by
third parties who are employing parts of the NetBeans platform in their applications, such as
the windowing system.
</arch-usecases><api name="PlafAPI" type="export" category="friend" url="org-netbeans-swing-plaf/org/netbeans/swing/plaf/package-summary.html" group="java"/><api name="LookAndFeelClassName" type="export" category="devel" group="property">
            The module initializes proper Look&amp;Feel. The decision is done
            based on various inputs including what has been specified on command
            line. To allow easier branding for those who build applications
            on top of NetBeans, there is key <code>LookAndFeelClassName</code>
            in <code>org.netbeans.swing.plaf.Bundle</code>
            bundle which can be branded to actual name of the L&amp;F class.
            The module will decide which sets of customizations to load based on
            the chosen look and feel.
        </api><api name="LookAndFeelCustomsClassName" type="export" category="devel" group="property">
            The module adds some UIManager keys and values to provide e.g. special
            border for main window toolbar or UI classes for tab control headers.
            By default the proper subclass of LFCustoms is derived from current
            Look and Feel name. Applications building on top of NetBeans can provide
            their own look and feel customizations by branding <code>LookAndFeelCustomsClassName</code>
            key in <code>org.netbeans.swing.plaf.Bundle</code>
            bundle.
        </api></module><module name="Tab Control" target="org-netbeans-swing-tabcontrol/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
	The tab control is a swing control used by NetBeans window system, similar in function to a JTabbedPane, which
        allows the user to see and select tabs that contain different components.  It defines two GUI components:
        TabbedContainer (similar to JTabbedPane) and TabDisplayer, a generic component for displaying tabs which 
        is not associated with any particular container.  Several different types of UIs (view, editor, sliding)
        are provided, each of which is handled by a different UI delegate class; UI delegate subclasses designed
        to fit with Windows, Metal, Aqua and GTK look and feels are provided.

        <api-ref name="TabbedContainerAPI"/>
        <api-ref name="PopupSwitcherAPI"/>
    </description><deploy-dependencies>
Nothing.
</deploy-dependencies><arch-usecases>
Primary use cases are in the NetBeans window system, as top level containers in the main window;  future use cases
include providing a consistent UI for tabs in the property sheet, the component inspector and the output window, but
this probably will not happen for 4.0.
</arch-usecases><api name="TabbedContainerAPI" type="export" category="friend" url="org-netbeans-swing-tabcontrol/org/netbeans/swing/tabcontrol/TabbedContainer.html" group="java"/><api name="PopupSwitcherAPI" type="export" category="friend" url="org-netbeans-swing-tabcontrol/org/netbeans/swing/popupswitcher/package-summary.html" group="java">
          API contains classes used only by <em>switchers</em> accessible through main menu in "Window/Documents..."
          and "Go To/Recent Document". Besides this module the package is used from core/windows too.
          Classes contained in the package are rather
          general and therefore this package could be moved in the future. It is placed here only due to current
          modules dependencies. Consequently the package is not intended for external use.<br/> For more
          information on <code>SwitcherTable</code> and <code>SwitcherTableItem</code> see a javadoc.
        </api><api name="nb.tabs.suppressCloseButton" type="export" category="devel" group="systemproperty">
            <p>
                The system property <code>nb.tabs.suppressCloseButton</code>
                can be used to hide close buttons by default.
            </p>
        </api><api name="winsys.stretching_view_tabs" type="export" category="devel" group="systemproperty">
            <p>
                The system property <code>winsys.stretching_view_tabs</code>
                can be used to switch to stretching tab layout as implemented 
                in NetBeans version 7.0 and older.
            </p>
        </api></module><module name="Actions APIs" target="org-openide-actions/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Actions provides system of support and utility classes 
for 'actions' usage in NetBeans.
</description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
        First see the <a href="org-openide-actions/org/openide/actions/doc-files/api.html" shape="rect">API description</a>. Here is just
    a list of frequently asked or interesting questions slowly expanding as
    people ask them:
    
    <h3>Actions faq:</h3>
    
    <usecase id="context-action-shortcuts" name="How to define configurable Shortcut for Component based shortcut?">
<em><b>Q:</b>
The usual Swing way of defining Actions for your component is to create an Action instance and put it into the Input and Action maps of your component.
However how to make this Action's shortcut configurable from the Tools/Keyboard Shortcuts dialog?</em>
<p>
In order for the action to show up in Keyboards Shortcut dialog you need the action defined in the 
layer file under "Actions" folder and have the shortcut defined there under "Keymaps/&lt;Profile Name&gt;" linking to your action.
</p>
<pre xml:space="preserve">
    &lt;folder name="Actions" &gt;
        &lt;folder name="Window"&gt;
            &lt;file name="org-netbeans-core-actions-PreviousViewCallbackAction.instance"/&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;

    &lt;folder name="Keymaps"&gt;
        &lt;folder name="NetBeans"&gt;
            &lt;file name="S-A-Left.shadow"&gt;
                &lt;attr name="originalFile" stringvalue="Actions/Window/org-netbeans-core-actions-PreviousViewCallbackAction.instance"/&gt;
            &lt;/file&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;
</pre>
<p>
The mentioned Action has to be a subclass of <code>org.openide.util.actions.CallbackSystemAction</code>. It does not necessarily has to 
perform the action, it's just a placeholder for linking the shortcut. You might want to override it's <code>getActionMapKey()</code> and give it a 
reasonable key.
</p>
<p>
The actual action that does the work in your component (preferably a simple Swing <code>javax.swing.Action</code>)
is to be put into your <code>TopComponent</code>'s <code>ActionMap</code>. The key for the <code>ActionMap</code> 
has to match the key defined in the global action's <code>getActionMapKey()</code> method.
</p>
<pre xml:space="preserve">
        getActionMap().put("PreviousViewAction", new MyPreviousTabAction());
</pre>
<p>
This way even actions from multiple <code>TopComponent</code>s with the same gesture (eg. "switch to next tab") can share the same configurable shortcut.
</p>
<p>
Note: Don't define your action's shortcut and don't put it into any of the <code>TopComponent</code>'s
<code>javax.swing.InputMap</code>. Otherwise the component would not pick up the changed shortcut from the
global context.
</p>

    </usecase>
</arch-usecases><api name="ActionsAPI" type="export" category="official" url="org-openide-actions/overview-summary.html" group="java"/><api name="OpenIDE-Transmodal-Action" type="export" category="devel" group="property">Inidicates action can be performed
    (typicaly via shortcut) even when dialog is popped out (modal or modeless).</api><api name="delegates" type="export" category="devel" group="property">Used internaly in <code>PasteAction</code> delegate action
    which serves to pass an array of <code>PasteType</code> or <code>Action</code> to global instance (it is the only one
    which actually performs paste operation).</api><api name="iconBase" type="export" category="devel" group="property">Used in companion to Actions.SMALL_ICON. Because there
    is no way to specify values for other types of icons the value of "iconBase" is used
    to construct the resource names of disabled, pressed and rollover icons. The value is
    expected to contain a resource path of the normal icon. Strings "_pressed",
    "_disabled" and "_rollover" are inserted before the suffix when searching for
    the other types of icons.</api><api name="noIconInMenu" type="export" category="devel" group="property"> 
    Allowed value <code>Boolean.TRUE</code>.
    Influences the display of the action in the main menu, the item will have no icon there. Works for Actions that don't define custom MenuPresenter.
    </api><api name="PreferredIconSize" type="export" category="devel" group="property">
    Used to support 24x24 icons in toolbars. If toolbar button has client property "PreferredIconSize"
    set to Integer(24) button tries to load icon with name "iconBase" + "24" eg. "cut24.gif".
    Strings "_pressed","_disabled" and "_rollover" are inserted before the suffix when searching for
    the other types of icons eg.:"cut24_pressed.gif".</api><api name="waitFinished" type="export" category="friend" group="property">
             There is a new contract established between the caller of an action that
             allows mutual communication and possible synchronous execution even for 
             actions that by default perform their operations asynchronously. If the
             action's <code>actionPeformed</code> method is passed <code>ActionEvent</code>
             with command <q>waitFinished</q> the action shall be executed synchronously.
             The code:
             <pre xml:space="preserve">
             action.actionPerformed (new ActionEvent (this, 0, "waitFinished"))
             </pre>
             shall be executed synchronously, even if the action by default runs asynchronously.
             All asynchronous actions are asked to obey this contract, <code>CallableSystemAction</code>
             does it by default. However this contract is defined as friend one 
             and may be abandoned in future.
        </api><api name="ActionMapKeys" type="export" category="stable" group="property">
<code>CallableSystemAction</code> uses its <code>getActionMapKey()</code> method
(usually overriden by subclasses) to get a key which is then searched in the
<code>ActionMap</code> obtained from the action's context. Other modules can
register their own action then: 
<pre xml:space="preserve">
topComponent.getActionMap ().put (theKey, new YourOwnSwingAction ());
</pre>
Here is the list of special keys:
<ul>
    <li><code>"cloneWindow"</code> - an action to be executed when a top component is to be cloned</li>
    <li><code>"closeWindow"</code> - an action when a view is about to be closed</li>
    <li><code>DefaultEditorKit.copyAction</code> - copy action handler</li>
    <li><code>DefaultEditorKit.cutAction</code> - cut action handler</li>
    <li><code>"delete"</code> - delete action handler</li>
    <li><code>DefaultEditorKit.pasteAction</code> - paste action handler</li>
    
    <!-- new since 5.8 -->
    <li><code>"jumpNext"</code> - when a next element shall be selected</li>
    <li><code>"jumpPrev"</code> - when a previous element shall be selected</li>
</ul>
</api><api name="org.openide.util.actions.CallableSystemAction.synchronousByDefault" type="export" category="friend" group="systemproperty">
                    If set to <code>true</code>, changes default value of the
                    <code>asynchronous()</code> method. Useful for unit tests
                    which would prefer to run all tested actions synchronously.
                </api><api name="UI-ToolActions" type="export" category="stable" group="layer">
        Register your <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/Action.html" shape="rect">javax.swing.Action</a>
        instances in <code>UI/ToolActions</code> folder to make them known
        to <a href="org-openide-actions/org/openide/actions/ToolsAction.html" shape="rect">ToolsAction</a>.
    </api><api name="org.openide.actions.HeapView" type="export" category="private" group="preferences">
      <table>
          <tbody>
              <tr>
                  <th colspan="1" rowspan="1">key</th>
                  <th colspan="1" rowspan="1">description</th>
                  <th colspan="1" rowspan="1">read</th>
                  <th colspan="1" rowspan="1">write</th>
              </tr>
              <tr>
                  <td colspan="1" rowspan="1">showDropShadow</td>
                  <td colspan="1" rowspan="1">Preserves "Drop Shadow" setting of the view</td>
                  <td colspan="1" rowspan="1">x</td>
                  <td colspan="1" rowspan="1">x</td>
              </tr>
              <tr>
                  <td colspan="1" rowspan="1">showText</td>
                  <td colspan="1" rowspan="1">Preserves "Show Text" setting of the view</td>
                  <td colspan="1" rowspan="1">x</td>
                  <td colspan="1" rowspan="1">x</td>
              </tr>
              <tr>
                  <td colspan="1" rowspan="1">tickStyle</td>
                  <td colspan="1" rowspan="1">Preserves "Overlay Grid" setting of the view</td>
                  <td colspan="1" rowspan="1">x</td>
                  <td colspan="1" rowspan="1">x</td>
              </tr>
          </tbody>
      </table>
  </api></module><module name="UI Utilities API" target="org-openide-awt/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  The <api-ref name="org.openide.awt"/>
  provides API/SPI for UI related aspects of application.
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
    For general overview of the concepts of NetBeans action system and related UI elements, 
    together with code samples, see chapter 5, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
  </p>
 </arch-usecases><api name="org.openide.awt" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-awt/org/openide/awt/package-summary.html" group="java"/><api name="menuText" type="export" category="stable" url="org-openide-awt/org/openide/awt/Actions.html#connect-javax.swing.JMenuItem-javax.swing.Action-boolean-" group="property"/><api name="popupText" type="export" category="stable" url="org-openide-awt/org/openide/awt/Actions.html#connect-javax.swing.JMenuItem-javax.swing.Action-boolean-" group="property"/><api name="USE_MNEMONICS" type="export" category="stable" group="branding">
        There is a way to enable mnemonics in popup menu items created via
        <a href="org-openide-awt/org/openide/awt/Actions.html" shape="rect">Actions</a> factory methods
        in your own application build on top of NetBeans Platform.
        Just provide branding for <code>org/openide/awt/Bundle.properties</code>
        file and modify <code>USE_MNEMONICS=always</code>. Other possible values
        of this key include <code>default</code>, <code>never</code> or <code>always</code>.
     </api><api name="org.netbeans.ui.actions.UI_ACTION_BUTTON_PRESS" type="export" category="friend" group="logger">
      There is a special support for notifying when an action wrapped by
      <a href="org-openide-awt/org/openide/awt/Actions.html" shape="rect">Actions bridge</a> is 
      invoked and how. The support is using <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
      Logger.getLogger("org.netbeans.ui.actions")
      </a> and sents a <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">LogRecord</a>
      with message <code>UI_ACTION_BUTTON_PRESS</code>, 
      <code>FINER</code> <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">level</a>
      and paramerters:
      <ul>
          <li>{<b>0</b>} instance of the button</li>
          <li>{<b>1</b>} class of the button</li>
          <li>{<b>2</b>} instance of the action</li>
          <li>{<b>3</b>} class of the action</li>
          <li>{<b>4</b>} display name of the action</li>
      </ul>
      whenever such action is invoked. This message can then be consumed
      by enhanced UI logger that track what the user is going.
      </api><api name="org.openide.awt.StatusDisplayer.DISPLAY_TIME" type="export" category="friend" group="systemproperty">
      Status text set in <a href="org-openide-awt/org/openide/awt/StatusDisplayer.html" shape="rect">StatusDisplayer</a> is 
      by default shown in status line of NetBeans and is hidden after specified timeout.
      If not overriden by this property it is done after 5000ms. 
      O means that the last text will be shown and not removed.
      </api><api name="org.openide.awt.ActionReference.completion" type="export" category="devel" group="systemproperty">
          If <a href="http://download.oracle.com/javase/8/docs/api/java/lang/System.html" shape="rect">System.getProperty("org.openide.awt.ActionReference.completion")</a>
          is specified, then the dedicated processor for <a href="org-openide-awt/org/openide/awt/ActionReference.html" shape="rect">ActionReference</a>
          tries to load such class, casts it to 
          <a href="http://download.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html" shape="rect">Processor</a>
          and asks it for additional completion items for its
          <code>path</code> attribute. By default, when running inside NetBeans IDE,
          <code>apisupport.project</code> registers such class and provides
          items representing valid paths in current project.
      </api><api name="ButtonActionConnectorSPI" type="export" category="friend" group="lookup">
          <p>
              Objects implementing 
              <a href="http://netbeans.apache.org/javadoc/dev/org-openide-awt/org/openide/awt/Actions.ButtonActionConnector.html" shape="rect">ButtonActionConnector</a> are
              looked up. Only the first instance found in the loookup is used to provide an alternative implementation
              of connection between Actions and GUI components. If there isn't one
              in the lookup the default implementation is used (it means there does
              not have to be one).
          </p>
      </api><api name="Actions.factories" type="export" category="stable" url="org-openide-awt/org/openide/awt/Actions.html" group="layer">
      Many action factories 
      (<a href="org/openide/awt/Actions.html#alwaysEnabled-java.awt.event.ActionListener-java.lang.String-java.lang.String-boolean-" shape="rect">alwaysEnabled</a>,
        <a href="org/openide/awt/Actions.html#context-java.lang.Class-boolean-boolean-org.openide.util.ContextAwareAction-java.lang.String-java.lang.String-java.lang.String-boolean-" shape="rect">
        context</a>
        and
        <a href="org/openide/awt/Actions.html#callback-java.lang.String-javax.swing.Action-boolean-java.lang.String-java.lang.String-boolean-" shape="rect">
            callback</a>,
        etc.)

      are ready
      to be called directly from layer XML file.
   </api></module><module name="Compatibility APIs" target="org-openide-compat/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   XXX no answer for arch-what
  
 </description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="CompatibilityAPIs" type="export" category="deprecated" group="java">
    This module is deprecated, do not use any classes herein.
    </api></module><module name="Dialogs API" target="org-openide-dialogs/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The  
<api-ref name="DialogsAPI"/>
allows creating a user notification, a dialog's description
and also permits it to be displayed. The wizard framework allows create a sequence
of panels which leads a user through the steps to complete any task.
This API is part of package org.openide.
</description><arch-usecases>

There is a <a href="http://netbeans.apache.org/javadoc/dev/org-openide-dialogs/org/openide/doc-files/wizard-guidebook.html" shape="rect">Wizard Guide Book</a>
providing the introductionary information, moreover here is a list
of frequently asked questions and their answers:

<usecase id="dialogs-title-of-wizard" name="How to change the title of a wizard?">
  <em>
  <b>Q:</b> Although none of my panels have names set (using setName() method) and the method name() in the WizardDescriptor.Iterator 
  returns an empty string, I'm getting "wizard ( )" as the title of each panel in my wizard. 
  When I set the name of the panel and return a string from the method name() I get: "panelName wizard (myName)".
  The wizard steps are labeled correctly, it just the panel title/name that looks like it adds "wizard ()" to 
  any of my panels. I don't mind the "( )", but I would like to rid of the word "wizard". 
  </em>
  <p>
  <b>A:</b> You can change the format of your wizard's title by 
  <a href="org-openide-dialogs/org/openide/WizardDescriptor.html#setTitleFormat-java.text.MessageFormat-" shape="rect">WizardDescriptor.setTitleFormat(MessageFormat format)</a>
  and rid of 'wizard' word in the default wizard's title.  
  </p>
</usecase>

</arch-usecases><api name="DialogsAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-dialogs/org/openide/package-summary.html#package.description" group="java"/></module><module name="Execution API" target="org-openide-execution/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The IDE uses a small interface to describe the execution of Java-based
classes together with arguments. The 
<api-ref name="ExecutionAPI"/>
controls the execution
of user-level classes. The system may have several different types
of executors simultaneously installed. By default we provide so called
External Execution for running a user code by an external process and
Internal Execution for running the user code in the same virtual machine
as the IDE.

</description><api name="ExecutionAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-execution/org/openide/execution/doc-files/api.html" group="java"/><api name="NetBeansAttrExecutor" type="export" category="private" group="property"/><api name="NetBeansAttrArguments" type="export" category="private" group="property"/><api name="readOnlyAttrs" type="export" category="private" group="property"/></module><module name="Explorer &amp; Property Sheet API" target="org-openide-explorer/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>

    The 
    <api-ref name="ExplorerAPI"/>
    is build around Explorer - solely a user-interface device: it has no particular knowledge 
    of the structure of the IDE. Rather, it provides the physical user interface for 
    the Node hierarchy, as described in the 
    <api-ref name="NodesAPI"/>.

    A given Explorer instance will be some visual component (such as a Swing panel) 
    displaying some representation of a subtree of the complete Node hierarchy; 
    the topmost node being displayed is said to be the root of the Explorer. 
    Be careful not to confuse the root of a particular Explorer instance, which is 
    selected according to what the user wishes to see, with the root(s) of 
    the entire Node hierarchy, which generally are fixed. 
</description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
    
  <p>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
    For general overview of the concepts related to <a href="http://netbeans.apache.org/javadoc/dev/org-openide-nodes/overview-summary.html" shape="rect">nodes</a> and explorers, 
    together with code samples, see chapter 7, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
  </p>
</arch-usecases><api name="ExplorerAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-explorer/org/openide/explorer/doc-files/api.html" group="java"/><api name="org.openide.explorer.VisualizerNode.prefetchCount" type="export" category="private" group="systemproperty">
        Setting this property to integer number controls prefetching of nodes
        when VisualizerChildren are constructed (prefetchCount = 0 disables
        prefetching).
        The prefetching should eliminate "bounce" effect (see #144718) in lazy 
        implementation which is caused by the fact that there exist keys without
        nodes. In such case "dummy" nodes are created and remove event is fired.
        This undesirable effect is eliminated by prefetching selected number of 
        nodes so "dummy" nodes are detected and removed in advance before any 
        visualization occurs. 
    </api><api name="TreeTableViewSortingAPI" type="export" category="friend" group="java"/><api name="netbeans.dnd.enabled" type="export" category="private" group="systemproperty">
    Checks by Drag &amp; Drop support for views. True is regard as default
    (no matter what jdk's version). False value disallows Drag &amp; Drop in
    all views.
    </api><api name="customDelete" type="export" category="devel" group="property">
    Nodes returing Boolean.TRUE from getValue("customDelete") are assumed to
    provide their own confirmation dialog for delete action and explorer will not show
    default one when they are deleted.
    </api><api name="slowRename" type="export" category="devel" group="property">
    Nodes returing Boolean.TRUE from getValue("slowRename") are expected
    to have potentially slow implemenation of <code>setName</code>. Explorer views
    rather process in-place rename in background for such nodes.
    </api></module><module name="File System API" target="org-openide-filesystems/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The Filesystems API provides a common API to access files in a uniform manner. 
It is available as standalone library and
also is bundled together with other parts of the openide. 
Specification
</description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
    For general overview of the filesystem concepts, related topics, 
    together with code samples, see chapter 3, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
   Many of the usecases are described at the
   <a href="org-openide-filesystems/org/openide/filesystems/doc-files/api.html" shape="rect">overall documentation</a>,
   in a way how to 
   <a href="org-openide-filesystems/org/openide/filesystems/doc-files/HOWTO-MIME.html" shape="rect">register a mime type</a>.
   Some of the additional usecases are covered here.
  </p>
  
  <usecase id="login-changes" name="How to change menus, etc. after login?">
      <p>
          See <a href="org-openide-filesystems/org/openide/filesystems/FileSystem.html" shape="rect">documentation</a>
          about dynamically changing the system filesystem.
      </p>
  </usecase>
 </arch-usecases><api name="FilesystemsAPI" type="export" category="official" url="org-openide-filesystems/org/openide/filesystems/doc-files/api.html" group="java"/><api name="fallback" type="export" category="stable" group="property">
    <p>
        See documentation of <code>FileSystem</code>.
    </p>
  </api><api name="revealEntries" type="export" category="devel" url="org-openide-filesystems/org/openide/filesystems/MultiFileSystem.html" group="property">
    <p>
        The MultiFileSystem defines some pseudo attributes on files and folders,
        which provide rollback features. Please see MultiFileSystem class javadoc 
        for more information.
    </p>
 </api><api name="FileObjectMoveLookup" type="export" category="friend" group="java">
    <code>masterfs</code> module is using
    a reflection to re-associate the lookup after a move operation.
    </api><api name="org.openide.filesystems.DefaultAttributes.ATTR_NAME_EXT_XML" type="export" category="private" group="systemproperty">
 Name of  attribute file can be changed , if .nbattrs can't be used. 
 </api><api name="org.openide.filesystems.LocalFileSystem.REFRESH_TIME" type="export" category="private" group="systemproperty">
Periodic refresh can be set.
 </api><api name="org.openide.filesystems.annotateUnclosedStreams" type="export" category="private" group="systemproperty">
    <p>
     If <code>true</code>, better diagnostic information will be available as to when file input or
     output streams were opened that prevent a file from being deleted because they were not closed.
     This information comes at a performance cost, however.
    </p>
   </api><api name="allow.filechooser.symlink.traversal" type="export" category="private" group="systemproperty">
       Used by FileChooserBuilder. If set to false,
    file choosers created by instances of FileChooserBuilder will traverse
    symlinks.  By default they do not.
   </api><api name="forget.recent.dirs" type="export" category="private" group="systemproperty">
       Used by FileChooserBuilder. If true, FileChooserBuilder will
    not remember users' recent directories across sessions.  This property
    is provided for applications where a history of recently used directories is a
    security concern.
   </api><api name="methodvalue-newvalue" type="export" category="stable" url="org-openide-filesystems/org/openide/filesystems/FileObject.html#setAttribute-java.lang.String-java.lang.Object-" group="layer">
When special form of <code>setAttribute</code> is supported by the filesystem, the 
<code>getAttribute</code> can behave like 
<a href="org-openide-filesystems/org/openide/filesystems/XMLFileSystem.html" shape="rect">XMLFileSystem</a>'s
<code>methodvalue</code> and <code>newvalue</code> attributes:
<ul>
<li><a href="http://www.netbeans.org/dtds/attributes-1_0.dtd" shape="rect"><code>"-//NetBeans//DTD DefaultAttributes 1.0//EN"</code></a></li>
<li><a href="http://www.netbeans.org/dtds/filesystem-1_0.dtd" shape="rect"><code>"-//NetBeans//DTD Filesystem 1.0//EN"</code></a></li>           
</ul>
</api><api name="raw-value" type="export" category="private" group="layer">
It is possible to prefix call to <a href="org-openide-filesystems/org/openide/filesystems/FileObject.html" shape="rect">FileObject</a>.<code>getAttribute</code>
with <code>raw:</code> prefix to evaluate the attribute without instantiating it
(e.g. get <a href="http://download.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" shape="rect">Method</a> or
<a href="http://download.oracle.com/javase/8/docs/api/java/lang/Class.html" shape="rect">Class</a> values from
<code>methodvalue</code> and <code>newvalue</code> attributes. This API
is not intended for public use at present and can change in future.
</api><api name="attributes-1_0.dtd" type="export" category="stable" url="http://www.netbeans.org/dtds/attributes-1_0.dtd" group="dtd"><samp>-//NetBeans//DTD DefaultAttributes 1.0//EN</samp></api><api name="filesystem-1_0.dtd" type="export" category="stable" url="http://www.netbeans.org/dtds/filesystem-1_0.dtd" group="dtd"><samp>-//NetBeans//DTD Filesystem 1.0//EN</samp></api></module><module name="Filesystems NetBeans Client" target="org-openide-filesystems-nb/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    This module has not provided an architectural description, sorry.
</description><deploy-dependencies>No answer</deploy-dependencies><arch-usecases>No answer</arch-usecases></module><module name="I/O APIs - Swing" target="org-openide-io/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The Input/Output API is a small API module
which contains InputOutput and related interfaces used in
driving the Output Window. The normal implementation is org.netbeans.core.output2.
</description><deploy-dependencies>
  <p>
   You will very likely also want to declare
  </p>
  <pre xml:space="preserve">OpenIDE-Module-Requires: org.openide.windows.IOProvider</pre>
  <p>to ensure that an Output Window implementation is in fact enabled.</p>
 </deploy-dependencies><arch-usecases>
  <p>There is an SPI but additional implementations are not expected. The API is most important.</p>
  <p>
   Simple usage example:
  </p>
<pre xml:space="preserve">
<span class="type">InputOutput</span> <span class="variable-name">io</span> = IOProvider.getDefault().getIO(<span class="string">"My Window"</span>, true);
io.select();
<span class="type">OutputWriter</span> <span class="variable-name">w</span> = io.getOut();
w.println(<span class="string">"Line of plain text."</span>);
<span class="type">OutputListener</span> <span class="variable-name">listener</span> = <span class="keyword">new</span> <span class="type">OutputListener</span>() {
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">outputLineAction</span>(<span class="type">OutputEvent</span> <span class="variable-name">ev</span>) {
        StatusDisplayer.getDefault().setStatusText(<span class="string">"Hyperlink clicked!"</span>);
    }
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">outputLineSelected</span>(<span class="type">OutputEvent</span> <span class="variable-name">ev</span>) {
        <span class="comment">// Let's not do anything special.
</span>    }
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">outputLineCleared</span>(<span class="type">OutputEvent</span> <span class="variable-name">ev</span>) {
        <span class="comment">// Leave it blank, no state to remove.
</span>    }
};
w.println(<span class="string">"Line of hyperlinked text."</span>, listener, true);
</pre>
 </arch-usecases><api name="InputOutputAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-io/org/openide/windows/package-summary.html" group="java">
        <p>
            Just an API/SPI for defining the output window.
        </p>
    </api></module><module name="Datasystems API" target="org-openide-loaders/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
    In summary, the <api-ref name="LoadersAPI"/>
    is responsible for scanning files in a directory on disk, 
    weeding out irrelevant files of no interest to the IDE, 
    and grouping the rest into logical chunks, or just determining 
    what type of data each represents. It does this scanning by asking each registered 
    data loader whether or not the given file(s) should be handled. The first 
    loader to recognize a file takes ownership of it, and creates a matching data object to represent it to the rest of the IDE.
</description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
    A lot of usecases is described <a href="org-openide-loaders/org/openide/loaders/doc-files/api.html" shape="rect">in the javadoc</a>. Here 
    is the list of some faqs:
  
    <usecase id="script" name="Using Scripting and Templating Languages">
        <p>
        Often many people require ability to create a "clever" template - e.g.
        write piece of simple text and at the time of its 
        <a href="org-openide-loaders/org/openide/loaders/DataObject.html#createFromTemplate-org.openide.loaders.DataFolder-java.lang.String-java.util.Map-" shape="rect">
            processing
        </a>
        do some advanced changes to it using either 
        <a name="script" shape="rect">scripting or templating</a> languages.
        </p>
        
        <p>
        This traditionally used to be a bit complicated task, however since 
        version 6.1 there are new interfaces 
        <api category="deprecated" group="lookup" name="org.openide.loaders.CreateFromTemplateHandler" type="export" url="org-openide-loaders/org/openide/loaders/CreateFromTemplateHandler.html">
            can be registered as a services in a lookup and it is reponsible
            for handling the whole copy of the template file(s) to the destination
            folder.
        </api> and 
        <api category="deprecated" group="lookup" name="org.openide.loaders.CreateFromTemplateAttributesProvider" type="export" url="org-openide-loaders/org/openide/loaders/CreateFromTemplateAttributesProvider.html">
            can be registered as a services in a lookup and it is reponsible
            for providing "hints" - e.g. map mapping strings to various objects.
        </api> and these interfaces allow anyone to extend the behaviour during
        creation of new files without writing new 
        <a href="org-openide-loaders/org/openide/loaders/DataLoader.html" shape="rect">DataLoader</a> and co.
        </p>
        <p>
            The support was moved to a new module; please see <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-api-templates/architecture-summary.html" shape="rect">api.templates</a>
            module for more information.
        </p>
    </usecase>
    <usecase id="add-action-to-folder" name="How to add action to folder's popup menu?">
    <api category="stable" group="layer" name="Loaders-folder-any-Actions" type="export">
    The actions that the default folder loader shows in its popup menu are read from
    a layer folder <code>Loaders/folder/any/Actions</code>
    so if any module wishes
    to extend, hide or reorder some of them it can just register its actions there.</api> 
    As code like this does:
    <pre xml:space="preserve">
    &lt;folder name="Loaders" &gt;
        &lt;folder name="folder" &gt;
            &lt;folder name="any" &gt;
                &lt;folder name="Actions" &gt;
                    &lt;file name="org-mymodule-MyAction.instance" &gt;
                        &lt;attr name="instanceCreate" stringvalue="org.mymodule.MyAction" /&gt;
                    &lt;/file&gt;
                &lt;/folder&gt;
            &lt;/folder&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;
    </pre>
    As described in general <a href="http://netbeans.apache.org/javadoc/dev/org-openide-actions/org/openide/actions/doc-files/api.html#adv-install" shape="rect">
    actions registration tutorial</a>. 
    <p/>
    This functionality is available since version 5.0 of the loaders module. Please use
    <code>OpenIDE-Module-Module-Dependencies: org.openide.loaders &gt; 5.0</code> in your
    module dependencies. 
    <p>
        In version 5.8 all the standard loaders were changed to read actions
        from layer:
    </p>
    <ul>
        <li><api category="stable" group="layer" name="Loaders-text-xml-Actions" type="export">
        The actions that the standard XML loader shows in its popup menu are read from
        a layer folder <code>Loaders/text/xml/Actions</code></api></li>
        
        <li><api category="stable" group="layer" name="Loaders-content-unknown-Actions" type="export">
        The actions that the loader for unrecognized files shows in its popup menu are read from
        a layer folder <code>Loaders/content/unknown/Actions</code></api></li>
        
        <li><api category="stable" group="layer" name="Loaders-application-x-nbsettings-Actions" type="export">
        The actions that the loader for instance and settings files shows in its popup menu are read from
        a layer folder <code>Loaders/application/x-nbsettings/Actions</code></api></li>
    </ul>
    </usecase>

    <usecase id="let-others-to-add-actions-to-loader" name="How to allow others to enhance actions of your loader?">
    If you want other modules to enhance or modify actions that are visible on 
    <code>DataObject</code>s produced by your <code>DataLoader</code> and you
    are either using <code>DataNode</code> or its subclass, you can just override
    <code>protected String actionsContext()</code> method to return non-null
    location of context in layers from where to read the actions.
    <p/>
    The usual value should match <code>Loaders/mime/type/Actions</code> scheme, 
    for example java is using <code>Loaders/text/x-java/Actions</code>, but 
    the name can be arbitrary.
    <p/>
    This functionality is available since version 5.0 of the loaders module. Please use
    <code>OpenIDE-Module-Module-Dependencies: org.openide.loaders &gt; 5.0</code> in your
    module dependencies.
    </usecase>
</arch-usecases><api name="LoadersAPI" type="export" category="official" url="org-openide-loaders/org/openide/loaders/doc-files/api.html" group="java"/><api name="org.openide.loaders.CreateFromTemplateHandler" type="export" category="deprecated" url="org-openide-loaders/org/openide/loaders/CreateFromTemplateHandler.html" group="lookup">
            can be registered as a services in a lookup and it is reponsible
            for handling the whole copy of the template file(s) to the destination
            folder.
        </api><api name="org.openide.loaders.CreateFromTemplateAttributesProvider" type="export" category="deprecated" url="org-openide-loaders/org/openide/loaders/CreateFromTemplateAttributesProvider.html" group="lookup">
            can be registered as a services in a lookup and it is reponsible
            for providing "hints" - e.g. map mapping strings to various objects.
        </api><api name="Loaders-folder-any-Actions" type="export" category="stable" group="layer">
    The actions that the default folder loader shows in its popup menu are read from
    a layer folder <code>Loaders/folder/any/Actions</code>
    so if any module wishes
    to extend, hide or reorder some of them it can just register its actions there.</api><api name="Loaders-text-xml-Actions" type="export" category="stable" group="layer">
        The actions that the standard XML loader shows in its popup menu are read from
        a layer folder <code>Loaders/text/xml/Actions</code></api><api name="Loaders-content-unknown-Actions" type="export" category="stable" group="layer">
        The actions that the loader for unrecognized files shows in its popup menu are read from
        a layer folder <code>Loaders/content/unknown/Actions</code></api><api name="Loaders-application-x-nbsettings-Actions" type="export" category="stable" group="layer">
        The actions that the loader for instance and settings files shows in its popup menu are read from
        a layer folder <code>Loaders/application/x-nbsettings/Actions</code></api><api name="NetBeansAttrAssignedLoader" type="export" category="stable" group="property">
        Extended attribute for holding the class of the loader that should
        be used to recognize a file object before the normal processing takes
        place.
    </api><api name="NetBeansAttrAssignedLoaderModule" type="export" category="private" group="property">
        Extended attribute which may be used in addition to EA_ASSIGNED_LOADER
        which indicates the code name base of the module that installed that preferred
        loader. If the indicated module is not installed, ignore the loader request.
        See #13816.     
    </api><api name="template" type="export" category="stable" group="property">
        If set to Boolean.TRUE the file is recognized as template and
        its instantiation is allowed.
    </api><api name="isRemoteAndSlow" type="export" category="friend" group="property">
        If the file attribute <code>isRemoteAndSlow</code> is <code>true</code> on a folder,
        the New File wizard will avoid asking for its children.
    </api><api name="templateWizardURL" type="export" category="stable" group="property">
        Attribute that defines a template wizard description page (type <code>URL</code> to HTML).
    </api><api name="templateWizardIterator" type="export" category="stable" group="property">
        Attribute that defines a custom template wizard iterator (type <code>TemplateWizard.Iterator</code>).
    </api><api name="originalFile" type="export" category="stable" group="property">
        Path to the target file in its filesystem (type <code>String</code>).
    </api><api name="originalFileSystem" type="export" category="stable" group="property">
        System name of filesystem of target file (type <code>String</code>; default is same as that of shadow).
    </api><api name="UseOwnName" type="export" category="private" group="property">
        if true, the DataShadow name is used instead of original's name, 
        affects DataShadows of filesystem roots only
    </api><api name="simple" type="export" category="stable" group="property">
        templates and folders under <code>Templates/</code>
        folder can be annotated with &lt;attr name="simple" boolvalue="false"&lt;
        if they are supposed to be hidden in <em>Template Manager</em>.
        If a folder is annotated with this attribute, it is also hidden
        in standard <em>New File wizard</em>.
    </api><api name="PartialOrders" type="export" category="stable" group="property">
        Read the list of intended partial orders from disk.
        Each element is a string of the form <samp>a/b</samp> for <samp>a</samp>, <samp>b</samp> filenames
        with extension, where <samp>a</samp> should come before <samp>b</samp>.
        The value of the attribute must be of type <code>Boolean</code>; ignored unless <code>true</code>.
    </api><api name="OpenIDE-Folder-SortMode" type="export" category="private" group="property">
        Extended attribute for order of children. The values
        are "F", "N", "C", "0" (type <code>String</code>).
    </api><api name="OpenIDE-Folder-Order" type="export" category="private" group="property">
        Extended attribute for order of children - stores list
        of file names separated by '/' (type <code>String</code>).
    </api><api name="org.openide.loaders.FolderChildren.delayedCreation" type="export" category="devel" group="systemproperty">
        <p>
        Since 7.25 the <code>DataFolder.getNodeDelegate()</code> tries to prevent
        creation of <a href="org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a>
        in AWT dispatch thread. Rather it creates dummy node with name
        derived from the name of the file and simplified content of lookup:
        </p>
        <ul>
            <li><a href="http://netbeans.apache.org/javadoc/dev/org-openide-filesystems/org/openide/filesystems/FileObject.html" shape="rect">FileObject</a>
               - the file that the node represents</li>
            <li><a href="http://netbeans.apache.org/javadoc/dev/org-openide-nodes/org/openide/nodes/Node.html" shape="rect">Node</a>
               - the node itself, but without any important properties</li>
            <li><a href="org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a>
               - created on the fly, very <b>inefficient</b>, if requested from
               AWT dispatch thread, it prints a warning. Consider using
               just <a href="http://netbeans.apache.org/javadoc/dev/org-openide-filesystems/org/openide/filesystems/FileObject.html" shape="rect">FileObject</a>.</li>
        </ul>
        <p>
        The creation of real node is scheduled to background and as soon as
        the 
        <a href="org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a>
        and its
        <a href="http://netbeans.apache.org/javadoc/dev/org-openide-nodes/org/openide/nodes/Node.html" shape="rect">Node</a> are 
        ready, the initial dummy node is replaced by the real one.
        </p>
        <p>
        This whole system is slightly incompatible and may complicate creation
        of filtered views over the node hierarchy (one needs to be ready to
        really dynamics changes). That is why it is possible to disable 
        the new <q>delayed</q> system by starting the system with
        <code>-Dorg.openide.loaders.FolderChildren.delayedCreation=false</code>.
        Use this property as a temporary fix for your problems, but consider
        fixing your code to support the <q>delayed mode</q> in the future.
        </p>
    </api><api name="EA-OpenIDE-Connection" type="export" category="private" group="property">
        Extended attribute to store (ArrayList of Type and Node.Handle).
        Used by Java synchronization feature at least; generally, <code>ConnectionCookie</code>.
    </api><api name="DataFolder.Index.reorderable" type="export" category="friend" group="property">
        If set to <code>Boolean.TRUE</code> on a folder not in the system filesystem, make its node reorderable.
    </api><api name="org.openide.loaders.FolderList.refresh.interval" type="export" category="private" group="systemproperty"> 
        The value of type integer determines the number of milliseconds
        between successive refreshes of contents of a folder. Can be used to tweak
        performance of folder refresh. Defaults to 10.
    </api><api name="netbeans.dataobject.insecure.operation" type="export" category="friend" group="systemproperty">
        If set to <b>true</b>, the <code>DataObject.copy, move, createFromTemplate</code> 
        are executed in insecure way. That means that other threads can access the
        products of such operation before it finishes. This is a friend contract
        with projects, that need to do such strange things. Will be removed when they
        fix it.
    </api><api name="Nb.Explorer.Folder.icon" type="export" category="devel" group="javax.swing.UIManager">
        Icon or Image for closed folder.
    </api><api name="Nb.Explorer.Folder.openedIcon" type="export" category="devel" group="javax.swing.UIManager">
        Icon or Image for opened folder.
    </api><api name="Tree.openedIcon" type="export" category="devel" group="javax.swing.UIManager">
        Fallback Icon or Image for opened folder.
    </api><api name="Tree.closedIcon" type="export" category="devel" group="javax.swing.UIManager">
        Fallback Icon or Image for folder.
    </api><api name="wizard.anything" type="export" category="stable" group="property">
        When <a href="org-openide-loaders/org/openide/loaders/TemplateWizard.html" shape="rect">TemplateWizard</a> invokes 
        <a href="org-openide-loaders/org/openide/loaders/DataObject.html" shape="rect">DataObject</a>.createFromTemplate,
        it passes as argument all its <a href="http://netbeans.apache.org/javadoc/dev/org-openide-dialogs/org/openide/WizardDescriptor.html#getProperties--" shape="rect">properties</a>
        to it with prefix <code>wizard.</code>. That way they are available to
        underlaying <a href="org-openide-loaders/architecture-summary.html#script" shape="rect">scripting and templating
        engines</a>.
    </api><api name="Loaders-mime-type-Factories" type="export" category="stable" url="org-openide-loaders/org/openide/loaders/doc-files/api.html#register" group="layer">
        Loaders are registered in the layer in folder <code>Loaders/mime/type/Factories</code>.
    </api><api name="PrivilegedTemplates" type="export" category="devel" group="layer">
    A folder Privileged offers to other module possibility add own templates.
    </api><api name="RecentTemplates" type="export" category="private" group="layer">
    A folder Recent stores a set of recently used templates, it's not open to other module. 
    </api><api name="Menu" type="export" category="stable" group="layer"><p>
        The main menu of the application is composed by reading <code>Menu/</code>
        folder in the layer. A sub folder is treated as a sub menu. 
        Instances of individual files (usually <code>.instance</code> 
        or <code>.shadow</code>) may then represent <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/Action.html" shape="rect">Action</a>
        or <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/JMenuItem.html" shape="rect">JMenuItem</a>
        or <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/JSeparator.html" shape="rect">JSeparator</a>.
    </p>
    <p>
        Since version 7.44 one can attach <code>property-prefix</code> attribute
        to every folder. Then all the file attributes are scanned and if some 
        of them start with the specified prefix they are placed a 
        <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#putClientProperty-java.lang.Object-java.lang.Object-" shape="rect">
        client
        properties</a> on the <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/JMenu.html" shape="rect">JMenu</a>
        instance (after stripping the prefix off).
    </p>
    </api><api name="org.openide.actions.FileSystemRefreshAction.manual" type="export" category="devel" group="preferences">
       If <code>NbPreferences.root().node("org/openide/actions/FileSystemRefreshAction").getBoolean("manual", false)</code>
       returns true, then <a href="org-openide-loaders/org/openide/actions/FileSystemRefreshAction.html" shape="rect">FileSystemRefreshAction</a>
       is displayed in popup menu of folders.
   </api></module><module name="Module System API" target="org-openide-modules/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The Modules API lies at the core of NetBeans and describes how plug-in
modules are added and managed.
<api-ref name="ModulesAPI"/>
</description><arch-usecases>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
    For general overview of the concepts, 
    together with code samples, see chapter 2, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
    
    Gory technical details are explained on <a href="org-openide-modules/org/openide/modules/doc-files/api.html" shape="rect">
    API overview page                                         
    </a>. Other interesting topic(s) follow:
    
	<usecase id="classpath" name="How a classpath of my module is constructed?">
    The NetBeans is defacto a container that manages individual module's 
    lifecycle and other runtime aspects. One of the important things is 
    that it creates a runtime classpath for provided modules based on
    dependencies they specify in their manifests. The 
    <a href="org-openide-modules/org/openide/modules/doc-files/classpath.html" shape="rect">
    overview of the runtime infrastructure</a> is a good starting place for
    everyone who wishes to learn more about the NetBeans runtime container
    behaviour.
  </usecase>
  <usecase id="patchfor" name="Runtime compatibility patches">
      <p>
        To maintain binary compatibility, method implementations may be injected
        at runtime, in a form of a superclass in the class' inheritance hierarchy.
        Modules compiled against older version of APIs which contains MethodReferences to 
        methods removed from the oficial APIs will be then linked according to JVM Resolution
        algorithm to a matching method present in the superclass of the referenced type.
      </p>
      <p>
        Annotations are used to instruct the ClassLoader to make transformations to the API
          classes. <a href="org-openide-modules/org/openide/modules/PatchFor.html" shape="rect">PatchFor</a> causes the annotated
          class to be injected as a superclass of the API class identified by the annotation's value.
          <a href="org-openide-modules/org/openide/modules/ConstructorDelegate.html" shape="rect">ConstructorDelegate</a> marks
          a method, which is called as constructor implementation in the case that it is necessary
          to preserve a constructor for binary compatibility.
      </p>
  </usecase>
</arch-usecases><api name="ModulesAPI" type="export" category="official" url="org-openide-modules/org/openide/modules/doc-files/api.html" group="java"/><api name="ModulesAPI" type="export" category="official" group="java"/><api name="CoreModulesAPI" type="export" category="friend" group="java"/><api name="netbeans.systemclassloader.patches" type="export" category="friend" group="systemproperty">
Classpath appended to the system class loader.
Used for automated testing infrastructure.
</api><api name="netbeans.cache.manifests" type="export" category="private" group="systemproperty">
By default true, may be turned off to disable manifest caching.
</api><api name="netbeans.patches.MODULE.CODE.NAME.BASE" type="export" category="friend" group="systemproperty">
Patch directories or JARs to add to the class loader for a module,
besides <samp>patches/MODULE-CODE-NAME-BASE/*.jar</samp>.
</api><api name="netbeans.preresolve.classes" type="export" category="private" group="systemproperty">
If true, all module classes are forcibly loaded at startup, to help
detect possible linkage errors.
</api><api name="org.netbeans.core.modules.NbInstaller.noAutoDeps" type="export" category="private" group="systemproperty">
Disables automatic module dependency upgrades.
</api><api name="org.netbeans.core.modules" type="export" category="private" group="systemproperty">
If set to <samp>0</samp>, enables logging for the module system.
</api><api name="org.netbeans.core.modules.NbInstaller.NO_COMPAT_AUTO_TRANSITIVE_DEPS" type="export" category="private" group="systemproperty">
Disabled automatic transitive class loader dependencies for old modules.
</api><api name="netbeans.modules.quiet" type="export" category="private" group="systemproperty">
Avoids text messaging (other than <code>ErrorManager</code> logging) to the console
from the module system.
</api><api name="netbeans.moduleitem.dontverifyclassloader" type="export" category="private" group="systemproperty">
Suppresses checks to ensure that module section classes are actually loaded
from the module itself.
</api><api name="netbeans.security.nocheck" type="export" category="friend" group="systemproperty">
Suppress security checks in the VM, even from "untrusted" code.
</api><api name="netbeans.classloader.verbose" type="export" category="private" group="systemproperty">
Prints messages when resources or classes are loaded from JARs.
</api><api name="netbeans.cache.layers" type="export" category="private" group="systemproperty">
            <p>
                Used to control the XML layer cache mechanism. Value may be a
                fully-qualified class name to load as a manager (implement
                <code>org.netbeans.core.projects.cache.LayerCacheManager</code>),
                or <code>-</code> to disable caching and always parse the XML
                layers directly. Current default is to use a binary cache
                manager.
            </p>
        </api><api name="module-status-1_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/module-status-1_0.dtd" group="dtd"><samp>-//NetBeans//DTD Module Status 1.0//EN</samp></api><api name="module-auto-deps-1_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/module-auto-deps-1_0.dtd" group="dtd"><samp>-//NetBeans//DTD Module Automatic Dependencies 1.0//EN</samp></api><api name="filesystem-1_1.dtd" type="export" category="stable" url="http://www.netbeans.org/dtds/filesystem-1_1.dtd" group="dtd"><samp>-//NetBeans//DTD Filesystem 1.1//EN</samp></api></module><module name="Nodes API" target="org-openide-nodes/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Nodes API serves as the main aparatus for visualisation of objects
in NetBeans. Nodes augment objects with standard aspects used for
visualisation (e.g. name, displayName, icons, set of proerties, 
subnodes hierarchy, etc.) Once a Node is defined for given object
it can be visualised using diferent views e.g. trees, lists, tables etc.
Descripion of nodes can be found  
here.
</description><arch-usecases>
    
  <p>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
    For general overview of the concepts related to nodes and <a href="http://netbeans.apache.org/javadoc/dev/org-openide-explorer/overview-summary.html" shape="rect">explorers</a>, 
    together with code samples, see chapter 7, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
  </p>
</arch-usecases><api name="NodesAPI" type="export" category="official" url="org-openide-nodes/org/openide/nodes/doc-files/api.html" group="java"/><api name="propertiesHelpID" type="export" category="stable" group="property">For providing help sets for JavaBeans proerties</api><api name="expertHelpID" type="export" category="stable" group="property">For providing help sets for JavaBeans properties</api></module><module name="Settings Options API" target="org-openide-options/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   <api-ref name="org.openide.options"/>
  
 </description><deploy-dependencies>
  <p>
   N/A
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   N/A
  </p>
 </arch-usecases><api name="org.openide.options" type="export" category="deprecated" group="java">
       Option API
   </api></module><module name="Text API" target="org-openide-text/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
The <api-ref name="EditorAPI"/> is used for accessing editor-related functionality from within the IDE
for use by other modules and the core IDE itself. 
</description><deploy-dependencies>
  <p>
   XXX no answer for deploy-dependencies
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   XXX no answer for arch-usecases
  </p>
 </arch-usecases><api name="EditorAPI" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-text/org/openide/text/doc-files/api.html" group="java"/><api name="indentEngine" type="export" category="stable" group="property">
Property hold instance of <a href="http://netbeans.apache.org/javadoc/dev/org-openide-text/org/openide/text/IndentEngine.html" shape="rect">IndentEngine</a>
and this indentation engine is used instead of system one.
</api><api name="javax.swing.text.Document.modificationListener" type="export" category="friend" group="property">
In order to fix <a href="http://www.netbeans.org/issues/show_bug.cgi?id=51872" shape="rect">issue 51872</a> the 
openide needs a way how to be notified about change of a document outside of its Document lock. 
<code>DocumentListener</code>s are always notified under the lock, so a special contract has
been established (since version 5.3) by registering an instance of <code>VetoableListener</code>
by calling <code>putProperty ("modificationListener", listener)</code>. The
NetBeans aware documents are adviced to honor this property and call the listener
outside of the document lock when a modification is made. The actual contract
of the call can be seen in 
<a href="http://www.netbeans.org/source/browse/openide/test/unit/src/org/openide/text/NbLikeEditorKit.java" shape="rect">NbLikeEditorKit.java</a> 
in methods 
<code>insertString</code> and <code>remove</code>.

</api><api name="beforeSaveRunnable" type="export" category="friend" group="property">
    Document property that allows to execute a runnable before save of a document is performed.
    For example an extra whitespace accumulated during typing can be removed by exploiting this property.
</api><api name="expectedTime" type="export" category="friend" group="property">
    <a href="org-openide-text/org/openide/text/CloneableEditorSupport.html" shape="rect">CloneableEditorSupport</a>
    understands not only its <code>Env.TIME</code> property, but also special
    "expectedTime". When this one arrives, it means refresh its internal
    last saved time, but without any refresh. This functionality is used from
    <code>DataEditorSupport</code> when the DataObject is moved to new location
    and we need to adjust the time to the new file object.
</api><api name="usedByCloneableEditor" type="export" category="friend" group="property">
    Component client property which is set to Boolean.TRUE if an editor pane is actively used by a cloneable editor.
    Once the component gets closed the CloneableEditor sets the property to Boolean.FALSE.
</api><api name="EditorKitInitialization" type="export" category="friend" group="java">
    In order to speedup, or remove the load of initialization of kit in AWT during startup,
    there is a special API that allows to ask the kit to pre-initialize. If the kit
    implements <code>Callable</code> interface from JDK, it is called in non-AWT thread.
    This works since version 6.18 and can be disabled by property <code>oldInitialization</code>.
</api><api name="oldInitialization" type="export" category="devel" group="property">
    As the speedup of startup done in version 6.18 is not fully compatible,
    there is a way to get back the original behaviour: just use
    <code>this.putClientProperty("oldInitialization", Boolean.TRUE)</code>
    and the whole initialization will be done in AWT thread. This is generally
    slower, but compatible.
</api><api name="org.openide.text.CloneableEditor.oldInitialization" type="export" category="private" group="property">
    In order to measure startup improvements between AWT and non-AWT startup,
    we have a property dedicated to testing that can switch all editors to be
    opened in AWT. Just start NetBeans with 
    <code>-J-Dorg.openide.text.CloneableEditor.oldInitialization=true</code>.
    This property may be discontiued anytime.
</api><api name="Editors-TabActions" type="export" category="devel" group="layer">
    Actions for the editor tab (window) context menu can be injected into <code>Editors/TabActions</code>.
</api></module><module name="Base Utilities API" target="org-openide-util/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   Described in the overall answer.
  
 </description><deploy-dependencies>
  <p>
   None.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
   Use-cases can be found in <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-ui/architecture-summary.html" shape="rect">org.openide.util.ui module</a> arch summary.
  </p>
 </arch-usecases><api name="org.openide.util.RequestProcessor.inactiveTime" type="export" category="private" group="systemproperty">
    Specifies the time in ms unused <a href="org-openide-util/org/openide/util/RequestProcessor.html" shape="rect">RequestProcessor</a>
    processor threads remain around, until 
    they get GCed. By default 60s. Primarily used from tests.</api><api name="WeakListener.setAccessible" type="export" category="devel" url="org-openide-util/org/openide/util/WeakListeners.html" group="java">
   used to call the remove method using reflection
   </api><api name="TranslateNames" type="export" category="official" url="org-openide-util/org/openide/util/BaseUtilities.html#translate-java.lang.String-" group="java.io.File">
    <a href="org-openide-util/org/openide/util/BaseUtilities.html#translate-java.lang.String-" shape="rect">Utilities.translate</a> 
    reads <code>META-INF/netbeans/translate.names</code> files from JARs</api></module><module name="Old Enumeration API" target="org-openide-util-enumerations/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
   <api-ref name="OldEnumerationsAPI"/>
  
 </description><deploy-dependencies>
  <p>
   Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
  Most of the functionality is deprecated, so it is better to go
  and use <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/Enumerations.html" shape="rect">the 
  replacement API</a> in <code>org-openide-util.jar</code>.
  </p>
 </arch-usecases><api name="OldEnumerationsAPI" type="export" category="deprecated" group="java">
       is deprecated and replaced with the
       <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/Enumerations.html" shape="rect">
       Enumerations</a> class.
   </api></module><module name="Lookup API" target="org-openide-util-lookup/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
    Described in the overall answer.
  
 </description><deploy-dependencies>
  <p>
  Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
  
    There is a great introduction to Lookup and its usage in its 
    <a href="org-openide-util-lookup/org/openide/util/Lookup.html" shape="rect">javadoc</a>. 
    For details on this topic, 
    together with code samples, see chapter 4, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
    In addition to that here is
    a list of frequently asked or interesting questions slowly expanding as
    people ask them:
    
    <h3>Lookup faq:</h3>
    
    <usecase id="lookup-on-certain-platform" name="How to specify that a service in Lookup should be available only on Windows?">
<em><b>Q:</b>
Most of the time I specify interfaces that I want to add to the Lookup class in the layer.xml file. 
But, let's say I have a platform-specific interface (something on Windows only, for instance).</em>
<p>
<em>
How can I specify (in the xml, or programmatically) that this service should only be added to the Lookup if the platform is Windows?
</em>&gt;
</p>
In general there are three ways to achieve this.
<ul>
    <li><p>It is possible to write a specific module and enable it only on windows.
    See <a href="http://netbeans.apache.org/javadoc/dev/org-openide-modules/org/openide/modules/doc-files/api.html#how-os-specific" shape="rect">os specific modules</a> documentation.
    Then you can put a registration of your instance into your module's 
    <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/doc-files/api.html#service-lookup" shape="rect">META-INF/services</a> directory and it
    will be available only on Windows.</p>
    </li>
    
    <li><p>Another possibility that does not require new module, but which executes 
    a code on startup (which may have performance implications) is to use <code>methodvalue</code>
    attribute. Register your instance in layer using <code>your-Object.instance</code> file
    as described at 
    <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/doc-files/api.html#ido-methodvalue" shape="rect">services
    </a> documentation and in your factory method either return the instance 
    your want or <code>null</code> depending on result of <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/BaseUtilities.html#isWindows--" shape="rect">
    Utilities.isWindows()</a> call.</p>
    </li>
                <li>
                    <p>
                        In some cases, the interface for which you will register an implementation permits a
                        no-operation semantics. For example, <code>InstalledFileLocator.locate(...)</code> can
                        return a valid <code>File</code>, or null. You could always register an
                        <code>InstalledFileLocator</code> instance yet disable it on non-Windows platforms
                        (always returning null).
                    </p>
                </li>
</ul>

    </usecase>
    
    <usecase id="lookup-extension-point" name="How shall I write an extension point for my module?">
    <p>
        <em><b>Q:</b>
        I have more modules one of them providing the core functionality and
        few more that wish to extend it. What is the right way to do it?
        How does the Netbeans platform declare such extension point? 
        </em>
    </p>

    <p>
    
    Start with declaring an extension interface in your
    core module and put it into the module's <em>public packages</em>. Imagine
    for example that the core module is in JAR file <code>org-my-netbeans-coremodule.jar</code>
    and already contains in manifests line like 
    <code>OpenIDE-Module: org.my.netbeans.coremodule/1</code> and wants 
    to display various tips of the day provided by other modules and thus defines:
    </p><pre xml:space="preserve"> 
<span class="java-keywords">package</span> <span class="java-identifier">org</span><span class="java-operators">.</span><span class="java-identifier">my</span><span class="java-operators">.</span><span class="java-identifier">netbeans</span><span class="java-operators">.</span><span class="java-identifier">coremodule</span><span class="java-operators">;</span>

<span class="java-keywords">public</span> <span class="java-keywords">interface</span> <span class="java-identifier">TipsOfTheDayProvider</span> <span class="java-operators">{</span>
    <span class="java-keywords">public</span> <span class="java-identifier">String</span> <span class="java-layer-method">provideTipOfTheDay</span> <span class="java-operators">(</span><span class="java-operators">)</span><span class="java-operators">;</span>
<span class="java-operators">}</span>
</pre><p>
    And in its manifest adds line 
    <code>OpenIDE-Module-Public-Packages: org.my.netbeans.coremodule.*</code>
    to specify that this package contains exported API and shall be 
    accessible to other modules.
    </p>
    <p>
    When the core module is about to display the tip of the day it can ask
    the system for all registered instances of the <code>TipsOfTheDayProvider</code>,
    randomly select one of them:
    </p><pre xml:space="preserve">
<span class="java-keywords">import</span> <span class="java-identifier">java</span><span class="java-operators">.</span><span class="java-identifier">util</span><span class="java-operators">.</span><span class="java-identifier">Collection</span><span class="java-operators">;</span>
<span class="java-keywords">import</span> <span class="java-identifier">java</span><span class="java-operators">.</span><span class="java-identifier">util</span><span class="java-operators">.</span><span class="java-identifier">Collections</span><span class="java-operators">;</span>
<span class="java-keywords">import</span> <span class="java-identifier">org</span><span class="java-operators">.</span><span class="java-identifier">openide</span><span class="java-operators">.</span><span class="java-identifier">util</span><span class="java-operators">.</span><span class="java-identifier">Lookup</span><span class="java-operators">;</span>

<a href="org-openide-util-lookup/org/openide/util/Lookup.Result.html" shape="rect"><span class="java-identifier">Lookup</span><span class="java-operators">.</span><span class="java-identifier">Result</span></a> <span class="java-identifier">result</span> <span class="java-operators">=</span> <a href="org-openide-util-lookup/org/openide/util/Lookup.html" shape="rect"><span class="java-identifier">Lookup</span></a><span class="java-operators">.</span><span class="java-layer-method">getDefault</span> <span class="java-operators">(</span><span class="java-operators">)</span><span class="java-operators">.</span><span class="java-layer-method">lookup</span> <span class="java-operators">(</span><span class="java-keywords">new</span> <a href="org-openide-util-lookup/org/openide/util/Lookup.Template.html" shape="rect"><span class="java-identifier">Lookup</span><span class="java-operators">.</span><span class="java-layer-method">Template</span></a> <span class="java-operators">(</span><span class="java-identifier">TipsOfTheDayProvider</span><span class="java-operators">.</span><span class="java-keywords">class</span><span class="java-operators">)</span><span class="java-operators">)</span><span class="java-operators">;</span>
<span class="java-identifier">Collection</span> <span class="java-identifier">c</span> <span class="java-operators">=</span> <span class="java-identifier">result</span><span class="java-operators">.</span><a href="org-openide-util-lookup/org/openide/util/Lookup.Result.html#allInstances--" shape="rect"><span class="java-layer-method">allInstances</span></a> <span class="java-operators">(</span><span class="java-operators">)</span><span class="java-operators">;</span>
<span class="java-identifier">Collections</span><span class="java-operators">.</span><span class="java-layer-method">shuffle</span> <span class="java-operators">(</span><span class="java-identifier">c</span><span class="java-operators">)</span><span class="java-operators">;</span>
<span class="java-identifier">TipsOfTheDayProvider</span> <span class="java-identifier">selected</span> <span class="java-operators">=</span> <span class="java-operators">(</span><span class="java-identifier">TipsOfTheDayProvider</span><span class="java-operators">)</span><span class="java-identifier">c</span><span class="java-operators">.</span><span class="java-layer-method">iterator</span> <span class="java-operators">(</span><span class="java-operators">)</span><span class="java-operators">.</span><span class="java-layer-method">next</span> <span class="java-operators">(</span><span class="java-operators">)</span><span class="java-operators">;</span>
</pre><p>    
    and then display the tip. Simple, trivial, just by the usage of 
    <a href="org-openide-util-lookup/org/openide/util/Lookup.html" shape="rect">Lookup</a> interface once 
    creates a registry that other modules can enhance. But such enhancing 
    of course requires work on the other side. Each module that would like
    to register its <code>TipsOfTheDayProvider</code> needs to depend on the 
    core module - add 
    <code>OpenIDE-Module-Module-Dependencies: org.my.netbeans.coremodule/1</code>
    into its manifest and write a class with its own implementation of the
    provider:</p><pre xml:space="preserve">
<span class="java-keywords">package</span> <span class="java-identifier">org</span><span class="java-operators">.</span><span class="java-identifier">my</span><span class="java-operators">.</span><span class="java-identifier">netbeans</span><span class="java-operators">.</span><span class="java-identifier">extramodule</span><span class="java-operators">;</span>

<span class="java-keywords">class</span> <span class="java-identifier">ExtraTip</span> <span class="java-keywords">implements</span> <span class="java-identifier">TipsOfTheDayProvider</span> <span class="java-operators">{</span>
    <span class="java-keywords">public</span> <span class="java-identifier">String</span> <span class="java-layer-method">provideTipOfTheDay</span> <span class="java-operators">(</span><span class="java-operators">)</span> <span class="java-operators">{</span>
        <span class="java-keywords">return</span> <span class="java-string-literal">"Do you know that in order to write extension point you should use Lookup?"</span><span class="java-operators">;</span>
    <span class="java-operators">}</span>
<span class="java-operators">}</span>
</pre><p>
    Then, the only necessary thing is to register such class by using the 
    J2SE standard <api category="standard" group="java" name="ProviderRegistrationMechanism" type="import"/> into plain text file
    <code>META-INF/services/org.my.netbeans.coremodule.TipsOfTheDayProvider</code>
    in the module JAR containing just one line: </p><pre xml:space="preserve">
org.my.netbeans.extramodule.ExtraTip
</pre><p>    
    and your modules are now ready to communicate
    using your own <em>extension point</em>.
    </p>
    
    </usecase>
 </arch-usecases><api name="LookupAPI" type="export" category="official" url="org-openide-util-lookup/org/openide/util/lookup/doc-files/lookup-api.html" group="java">
    allows the discovery</api><api name="LookupSPI" type="export" category="official" url="org-openide-util-lookup/org/openide/util/lookup/doc-files/lookup-spi.html" group="java">
    simplifies creation and registration of own lookup objects</api><api name="ProviderRegistrationRemoval" type="export" category="devel" url="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/doc-files/api.html#service-lookup" group="java"/><api name="FileLocation" type="export" category="devel" group="java.io.File">
   the JAR file is located in platform cluster under <code>lib/org-openide-util-lookup.jar</code>
   </api><api name="org.openide.util.Lookup" type="export" category="devel" group="systemproperty">
        checked by the initialization of the 
        <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>
        and can
        contain name of a class that extends <code>org.openide.util.Lookup</code> and
        has public constructor, that should be instantiated and returned from 
        <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>
        the class will be loaded by 
        <a href="http://download.oracle.com/javase/8/docs/api/java/lang/Thread.html#getContextClassLoader--" shape="rect">
        Thread.currentThread().getContextClassLoader()</a>
        classloader the first time <code>Lookup.getDefault</code> is invoked.
        <p/>
        The property can also contain value <code>"-"</code> which means to completely
        disable the lookup instantiation and return <a href="org-openide-util-lookup/org/openide/util/Lookup.html#EMPTY" shape="rect">Lookup.EMPTY</a>
        from <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>.
        <p/>
        If the property is unspecified, the default <code>MetaInfServicesLookup</code>
        is constructed for <code>Thread.currentThread().getContextclassLoader()</code>
        that implements the <a href="architecture-summary.html#answer-compat-standards" shape="rect">JDK's standard</a>. If, by 
        a chance an instance of 
        <a href="org-openide-util-lookup/org/openide/util/Lookup.Provider.html" shape="rect">Lookup.Provider</a>
        is found
        in there, its lookup is returned as result. Otherwise the <code>MetaInfServicesLookup</code>
        is the result of <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>.
    </api><api name="org.openide.util.Lookup.paths" type="export" category="devel" group="systemproperty">
        Sometimes it may be useful for the Lookup to contains objects from
        some system file system folder. This can be done with
        <code>org.openide.util.Lookup.paths=Folder1:Folder2:Folder3</code>.
        If this property is set prior to first call to
        <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>,
        it is split into pieces (separator is <code>':'</code>) and individual
        parts are then used to construct <code>Lookups.forPath("Folder1")</code>,
        etc. All these lookups then become part of the
        <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>
        one. This property works since version 7.24
    </api><api name="Lookups.metaInfServices" type="export" category="devel" url="org-openide-util-lookup/org/openide/util/lookup/Lookups.html#metaInfServices-java.lang.ClassLoader-" group="java">
   calls constructor of registered classes using reflection
   </api><api name="Lookup.resetDefaultLookup" type="export" category="friend" group="java">
    There is a static private method <code>Lookup.resetDefaultLookup</code> that 
    is called by NbJUnit's <code>MockServices</code> to properly reset default
    lookup and fire changes to all registred listeners.
   </api><api name="LookupInitializationLookup" type="export" category="devel" url="#systemproperty-org.openide.util.Lookup" group="lookup">
    during 
    initialization of the <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>
    the <a href="org-openide-util-lookup/org/openide/util/Lookup.Provider.html" shape="rect">Lookup.Provider</a>
    is being searched</api><api name="LookupSharedClassObject" type="export" category="devel" group="lookup">
    singleton subclasses of <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-ui/org/openide/util/SharedClassObject.html" shape="rect">SharedClassObject</a>
    are searched for using Lookup.
    </api><api name="LookupClassLoader" type="export" category="devel" group="lookup">
    Nearly all resource looking functions and reflective code
    uses <a href="http://download.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html" shape="rect">ClassLoader</a>
    obtained from <a href="org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>
    for loading system wide resources.
    </api></module><module name="Utilities API" target="org-openide-util-ui/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
    Described in the overall answer.
  
 </description><deploy-dependencies>
  <p>
  Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
    <usecase id="logging" name="How shall I do or influence logging in NetBeans?">
    <p>
        If you are interested in logging from inside your module, or in writing
        your own log handler or in configuring the whole system, then best place
        to start is the <a href="org-openide-util-ui/org/openide/util/doc-files/logging.html" shape="rect">NetBeans logging guide</a>.
    </p>
    </usecase>
 </arch-usecases><api name="UtilitiesAPI" type="export" category="official" url="org-openide-util-ui/org/openide/util/doc-files/api.html" group="java"/><api name="BrandingSupport" type="export" category="official" url="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/NbBundle.html" group="property">
   which is similar to localization but also supports changes of resorces 
   for application build on top of NetBeans. This is handled by our
   class <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/NbBundle.html" shape="rect">NbBundle</a> which 
   reimplements the JDK's standard <a href="http://download.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html" shape="rect">ResourceBundle</a>
   to to take branding into the consideration.
   </api><api name="AWTBridge" type="export" category="private" url="http://www.netbeans.org/source/browse/openide/util/src/org/netbeans/modules/openide/util/AWTBridge.java" group="java">
   a class that is looked up in <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>
   and if registered can provide better UI elements for <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/Action.html" shape="rect">Action</a>s.
   </api><api name="FileLocation" type="export" category="devel" group="java.io.File">
   the JAR file is located in platform cluster under <code>lib/org-openide-util.jar</code>
   </api><api name="HelpID" type="export" category="standard" url="org-openide-util-ui/org/openide/util/HelpCtx.html" group="property">
        read from <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/JComponent.html" shape="rect">JComponent</a>.getClientProperty
        to simulate the standard javahelp behaviour and extract the help id for given component.
        </api><api name="org.openide.util.SharedClassObject.initialize" type="export" category="private" group="property">
        For purposes of 
        <code>SystemOption</code>
        the
        <a href="org-openide-util-ui/org/openide/util/SharedClassObject.html" shape="rect">SharedClassObject</a>
        handles
        <code>getProperty ("org.openide.util.SharedClassObject.initialize")</code> 
        in a special way, by returning 
        <code>null</code> if initialization is not running and <code>Boolean.TRUE</code> if 
        it is.
        </api><api name="OpenIDE-Transmodal-Action" type="export" category="devel" group="property">
        <a href="org-openide-util-ui/org/openide/util/actions/CallbackSystemAction.html" shape="rect">CallbackSystemAction</a> 
        checks whether <code>action.getValue("OpenIDE-Transmodal-Action")</code>
        returns <code>Boolean.TRUE</code> to enable it in dialogs, otherwise
        the action is disabled when there is an open dialog.
        </api><api name="SharedClassObject.setAccessible" type="export" category="devel" url="org-openide-util-ui/org/openide/util/SharedClassObject.html" group="java">
   used to instantiate subclasses. 
   </api><api name="WeakListener.setAccessible" type="export" category="devel" url="http://netbeans.apache.org/javadoc/dev/org-openide-util/org/openide/util/WeakListeners.html" group="java">
   used to call the remove method using reflection
   </api><api name="ActionManagerInvocation" type="export" category="private" group="lookup">
    because of the API separation, <a href="org-openide-util-ui/org/openide/util/actions/CallableSystemAction.html" shape="rect">CallableSystemAction</a> uses lookup for <code>ActionsBridge</code>
    provided by <code>org-openide-actions</code> module
    when looking for <a href="http://netbeans.apache.org/javadoc/dev/org-openide-actions/org/openide/actions/ActionManager.html" shape="rect">org.openide.actions.ActionManager</a> implementation.
    </api><api name="LookupSharedClassObject" type="export" category="devel" group="lookup">
    singleton subclasses of <a href="org-openide-util-ui/org/openide/util/SharedClassObject.html" shape="rect">SharedClassObject</a> 
    are searched for using Lookup.
    </api><api name="LookupContextGlobalProvider" type="export" category="stable" group="lookup">
    <a href="org-openide-util-ui/org/openide/util/Utilities.html#actionsGlobalContext--" shape="rect">actionsGlobalContext</a>
    searches for <a href="org-openide-util-ui/org/openide/util/ContextGlobalProvider.html" shape="rect">ContextGlobalProvider</a> in 
    <a href="http://netbeans.apache.org/javadoc/dev/org-openide-util-lookup/org/openide/util/Lookup.html#getDefault--" shape="rect">Lookup.getDefault()</a>.
    The provider is usually provided by <a href="http://netbeans.apache.org/javadoc/dev/org-openide-windows/overview-summary.html" shape="rect">window 
    system implementation</a>.
    </api><api name="LookupErrorManager" type="export" category="devel" group="lookup">
    <a href="org-openide-util-ui/org/openide/ErrorManager.html" shape="rect">ErrorManager</a> 
    delegates its methods to all instances of <a href="org-openide-util-ui/org/openide/ErrorManager.html" shape="rect">ErrorManager</a>s
    found in Lookup
    </api></module><module name="Window System API" target="org-openide-windows/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
Window System API is used to display and control application GUI: Main window,
frames, components.
</description><deploy-dependencies>
        You might use <code>OpenIDE-Module-Requires: org.openide.windows.WindowManager</code>
        but it is not generally done.
</deploy-dependencies><arch-usecases>
    
  <p>
     <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">
     <img alt="Cover of NetBeans Platform for Beginners book" height="70" src="http://wiki.apidesign.org/images/0/03/NetBeansPlatformForBeginners.jpg" style="float: right" width="60"/>
     </a>
    For general overview of the concepts, 
    together with code samples, see chapter 6, 
    of <a href="https://leanpub.com/nbp4beginners" onclick="target='_blank'" shape="rect">NetBeans Platform for Beginners</a> 
    by Jason Wexbridge and Walter Nyland.
  </p>
    
<usecase id="windowsystem-general" name="General Usecases">
General usecases
can be read in the <a href="http://core.netbeans.org/windowsystem/changes.html#4" shape="rect">design document</a>
created before work on new window system design started. 
</usecase>

<usecase id="windowsystem-settings-for-topcomponent" name="How to create a '.settings' file for a TopComponent?">

Either write it by hand (not that hard if you copy other file and
tweak it to match your TC), or start the IDE, instantiate the TC
somehow (You have a "Window-&gt;Show My TC", right? ),
copy the file that gets created in $userdir/config/Windows2Local/Component
and cleanup the serialdata section - replace it with proper  "&lt;instance class='..." /&gt; tag.

</usecase>

<usecase id="windowsystem-groups" name="How to make a TopComponentGroup?">

<p/>
    <b>Q:</b> I'm trying to make a TopComponentGroup.  I've just read http://ui.netbeans.org/docs/ui/ws/ws_spec.html#3.9
            I want to make a group that uses the first invocation strategy.  
            That is, I want the group to open/close when I activate a certain subclass of TopComponent.  
            Say, for example, I have a FooTopComponent, and when it's active, 
            I want to open a FooPropertySheetComponent, docked in a mode on the right-hand side.
            I know I have to:

            <ol>
                <li>declare the group in the layer file (Windows2/Groups)</li>
                <li>have code for opening the group</li>
                <li>have code for closing the group</li>
            </ol>
            I think I do #2 in FooTopComponent.componentActivated() and #3 in 
            FooTopComponent.componentDeactivated().  Is that right? 

<p/>
    <b>A:</b>Yes it is correct way. You can check
    <a href="http://www.netbeans.org/source/browse/platform/samples/window-system-groups/" shape="rect">simple test module</a>.
    First you must get TopComponentGroup instance using find method then call TopComponentGroup.open()/close(). 
    Here is the code in your componentDeactivated method:
    <pre xml:space="preserve">
   protected void componentDeactivated ()
   {
       // close window group containing propsheet, but only if we're
       // selecting a different kind of TC in the same mode
       boolean closeGroup = true;
       Mode curMode = WindowManager.getDefault().findMode(this);
       TopComponent selected = curMode.getSelectedTopComponent();
       if (selected != null &amp;&amp; selected instanceof FooTopComponent)
           closeGroup = false;
             if (closeGroup)
       {
           TopComponentGroup group = WindowManager.getDefault().findTopComponentGroup(TC_GROUP);
           if (group != null)
           {
               group.close();
           }
       }
   }     
    </pre>

</usecase>

</arch-usecases><api name="NewConfigurationData" type="export" category="devel" url="http://core.netbeans.org/windowsystem/changes.html#3.4.2" group="layer">
new configuration data</api><api name="OldConfigurationData" type="export" category="deprecated" url="http://core.netbeans.org/windowsystem/changes.html#3.4.6" group="layer">
old configuration data </api><api name="WindowSystemAPI" type="export" category="official" url="org-openide-windows/org/openide/windows/doc-files/api.html" group="java"/><api name="WindowSystemImplementationAPI" type="export" category="friend" group="java"/><api name="KeepNonPersistentTCInModelWhenClosed" type="export" category="private" group="property">
    Client property "KeepNonPersistentTCInModelWhenClosed" of TopComponent controls behavior of winsys
    when TopComponent with persistence type "Never" or "OnlyOpened" is closed. As some TopComponent wants
    to keep their position in winsys ie. be able to reopen at the same place and some TopComponent wants
    to be removed from winsys model.
    If property is not set nonpersistent TopComponent is removed from model when closed - it is original
    behavior before fix of issue #101700.
    If property is set (to Boolean.TRUE) then TopComponent is kept in model. It means that
    client must explicitly set this client property to get behavior requested by issue #101700.
</api><api name="netbeans.winsys.tc.activate_at_startup" type="export" category="private" group="property">
     Name of TopComponent's Boolean client property which instructs the window system to activate
     the given TopComponent at startup time regardless which TopComponent was active at
     shutdown time. So it's usuable for welcome screen-like behavior. 
     If more than one TopComponent has this property set to Boolean.TRUE then
     an arbitrary one will be selected and activated.
</api><api name="TopComponentAllowDockAnywhere" type="export" category="private" group="property">
    Name of client property (of Boolean type) which says whether the TopComponent is allowed
    to be docked anywhere (even crossing view-editor border).
</api><api name="netbeans.winsys.tc.keep_preferred_size_when_slided_in" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which forces the window system
     to respect TopComponent's preferred size when it is slided-in from left/right/bottom 
     sliding bar when set to Boolean.TRUE. Otherwise the slided-in TopComponent
     will fill the entire width/length of the IDE window (the default behavior).
     This switch is intended for tools/palette windows like e.g. color chooser, 
     tool picker etc.
</api><api name="netbeans.winsys.tc.closing_disabled" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which removes close button
     from TopComponent's header and disables its 'Close Window' action when set to Boolean.TRUE.
</api><api name="netbeans.winsys.tc.sliding_disabled" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which removes 'minimized' button
     from TopComponent's header and disables its 'Minimize Window' action when
     set to Boolean.TRUE. TopComponents which are already slided-out and have this
     property set to Boolean.TRUE will have 'pin' button removed from their header
     and their 'Minimize Window' action will be disabled.
</api><api name="netbeans.winsys.tc.undocking_disabled" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which disables TopComponent's
     'Undock Window' action when set to Boolean.TRUE. TopComponents which are already
     floating and have this property set to Boolean.TRUE will have their 'Dock Window' action disabled.
</api><api name="netbeans.winsys.tc.dragging_disabled" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which disables drag and drop
     when set to Boolean.TRUE.
</api><api name="netbeans.winsys.tc.maximization_disabled" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which disables TopComponent
     maximization by double-clicking its header when set to Boolean.TRUE. TopComponent's
     'Maximize Window' action will be also disabled.
</api><api name="netbeans.winsys.tc.draganddrop_copy_disabled" type="export" category="stable" group="property">
     Name of TopComponent's Boolean client property which disables 'copy' drag and drop action 
     of a TopComponent when set to Boolean.TRUE.
</api><api name="OpenIDE-Transmodal-Action" type="export" category="friend" group="property">
            <p>
                An <code>Action</code> with the property <code>OpenIDE-Transmodal-Action</code> set to
                <code>Boolean.TRUE</code> should function on all focused components. This includes the Main
                Window, dialogs, popup menus, etc. Otherwise only the Main Window and <code>TopComponent</code>s
                will receive the keystroke.
            </p>
        </api><api name="org.netbeans.core.windows.TopComponent.DragAndDrop.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables the drag and drop of window
         TopComponents when its value is set to <code>false</code>, the default value is <code>true</code>.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.TopComponent.DragAndDrop.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.TopComponent.Undocking.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables undocking of window
         TopComponents when its value is set to <code>false</code>, the default value is <code>true</code>.
         When this feature is disabled then there is no 'Undock' item in TopComponent popup menu
         and 'Undock Window' action the main menu is disabled.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.TopComponent.Undocking.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.TopComponent.Sliding.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables sliding of window
         TopComponents when its value is set to <code>false</code>, the default value is <code>true</code>.
         When this feature is disabled then there is no 'Minimize Window' item in TopComponent popup menu
         and also the Minimize button in TopComponent's header is hidden.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.TopComponent.Sliding.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.TopComponent.Resizing.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables resizing of window
         TopComponents when its value is set to <code>false</code>, the default value is <code>true</code>.
         When this feature is disabled then it is not possible to drag splitter bars
         to change the size of TopComponents.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.TopComponent.Resizing.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.View.TopComponent.Closing.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables closing of view TopComponents (non-editor windows)
         when its value is set to <code>false</code>, the default value is <code>true</code>.
         When this feature is disabled then there is no 'Close Window' item in view's popup menu,
         there is no close button in TopComponent's header and also 'Close Window' action in 
         the main menu is disabled when a view TopComponent is activated.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.View.TopComponent.Closing.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.Editor.TopComponent.Closing.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables closing of editor TopComponents (document windows)
         when its value is set to <code>false</code>, the default value is <code>true</code>.
         When this feature is disabled then there are no 'Close Window', 'Close All Documents' and 
         'Close Other Documents' items in editor's popup menu,
         there is no close button in editor's header and also Close actions in 
         the main menu are disabled when an editor TopComponent is activated.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Editor.TopComponent.Closing.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.TopComponent.Maximization.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which disables maximization of TopComponents 
         when its value is set to <code>false</code>, the default value is <code>true</code>.
         When this feature is disabled then there is no 'Maximize Window' item 
         in TopComponent's popup menu and also 'Maximize Window' action in 
         the main menu is disabled.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.TopComponent.Maximization.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.Splitter.Respect.MinimumSize.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which forces splitter to ignore TopComponent
         minimum size when resizing when its value is set to <code>false</code>,
         the default value is <code>true</code>.
         When this feature is enabled then the splitter bars will not move beyond
         the minimum size of its TopComponents.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Splitter.Respect.MinimumSize.Enabled=true command-line switch to override.
    </api><api name="NbMainWindow.showCustomBackground" type="export" category="stable" group="property">
         Name of boolean property in <code>javax.swing.UIManager</code>. When the property value
         is <code>TRUE</code> then the window system will turn off opacity
        for most of the main window components - menu bar, toolbars, status bar,
        sliding bars and the main desktop area component. That means that the main
        window background will be showing through these components.
        The property value must be set before the window system loads.
    </api><api name="org.netbeans.core.windows.Mode.View.DragAndDrop.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows to drag and drop the whole
         group of non-document windows when its value is set to <code>true</code>,
         which is also the default value.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Mode.View.DragAndDrop.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.Mode.Editor.DragAndDrop.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows to drag and drop the whole
         group of document windows when its value is set to <code>false</code>,
         which is also the default value.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Mode.Editor.DragAndDrop.Enabled=true command-line switch to override.
    </api><api name="org.netbeans.core.windows.Mode.View.Undocking.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows to float the whole
         group of non-document windows when its value is set to <code>true</code>,
         which is also the default value.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Mode.View.Undocking.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.Mode.Editor.Undocking.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows to float the whole
         group of document windows when its value is set to <code>false</code>,
         which is also the default value.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Mode.Editor.Undocking.Enabled=true command-line switch to override.
    </api><api name="org.netbeans.core.windows.Mode.Sliding.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows to minimize (slide-out) the whole
         group of non-document windows when its value is set to <code>true</code>,
         which is also the default value.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Mode.Sliding.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.TopComponent.Auto.Slide.In.Minimized.Mode.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which controls the opening of windows in a
         minimized (slided-out) group of non-document windows. When set to true
         (the default value) then a window which should open in a minimized group (Mode)
         will open also minimized (slided-out). When set to false a window will open
         docked even though the whole group (Mode) has been minimized.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.TopComponent.Auto.Slide.In.Minimized.Mode.Enabled=false command-line switch to override.
    </api><api name="org.netbeans.core.windows.Mode.Closing.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows to close the whole
         group of non-document windows when its value is set to <code>true</code>,
         which is also the default value.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.Mode.Closing.Enabled=false command-line switch to override.
    </api><api name="WinSys.Show.Hide.MainWindow.While.Switching.Role" type="export" category="stable" group="branding">
         Name of resource bundle property which controls whether the main IDE
         window may hide temporarily (<code>true</code>) when switching window
         layout role or whether the main window should stay visible when switching
         roles (<code>false</code>). The default value is <code>false</code>.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.WinSys.Show.Hide.MainWindow.While.Switching.Role=true command-line switch to override.
    </api><api name="WinSys.Open.New.Editors.Docked" type="export" category="stable" group="branding">
         Name of resource bundle property which when set to <code>true</code> will
         force opening of new editor windows docked into the main IDE window.
         When set to <code>false</code> new editor windows will open tabbed
         with the last active editor window (which may be floating).
         The default value is <code>false</code>.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.WinSys.Open.New.Editors.Docked=true command-line switch to override.
    </api><api name="WinSys.DragAndDrop.Sliding.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which enables/disables drag and drop
         of TopComponents into sliding Modes. When set to <code>true</code> then user can
         drag a TopComponent and drop it into a sliding bar to minimize it.
         The default value is <code>false</code>.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.WinSys.DragAndDrop.Sliding.Enabled=true command-line switch to override.
    </api><api name="WinSys.TabControl.SimpleTabs.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which allows replacing the custom TabbedContainer
         with plain Swing JTabbedPane implementation when the property value is <code>true</code>.
         The default value is <code>false</code>.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.WinSys.TabControl.SimpleTabs.Enabled=true command-line switch to override.
    </api><api name="WinSys.TabControl.SimpleTabs.Placement" type="export" category="stable" group="branding">
         Name of resource bundle property which defines the placement of window tabs.
         The possible values are <code>top</code> (default), <code>bottom</code>,
         <code>left</code>, <code>right</code>. Branding of this property has no effect when
         <code>WinSys.TabControl.SimpleTabs.Enabled</code> is set to false.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
    </api><api name="WinSys.TabControl.SimpleTabs.MultiRow" type="export" category="stable" group="branding">
         Name of resource bundle property which defines the tab layout when JTabbedPane
         implementation of tab control is being used. When set to <code>true</code>
         window tabs will be organized into multiple rows, when set to <code>false</code>
         the tab displayer will have scroll buttons.
         Branding of this property has no effect when
         <code>WinSys.TabControl.SimpleTabs.Enabled</code> is set to false.
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
    </api><api name="WinSys.CtrlTabSwitching.In.JTable.Enabled" type="export" category="stable" group="branding">
         Name of resource bundle property which can disable window switching 
         when the input focus is in JTable or JTabbedPane.<br/>
         Ctrl+Tab and Ctrl+Shift+Tab key strokes are hard-coded to switch between
         opened TopComponents. However the same keys are also used in some Containers
         (e.g. JTable and JTabbedPane) to transfer input focus to next Component.<br/>
         When this property is set to <code>true</code> (default value) and input
         focus is in JTable or JTabbedPane then the window system will consume
         Ctrl+Tab and Ctrl+Shift+Tab key strokes and show window switcher popup.<br/>
         When this property is set to <code>false</code> then KeyboardFocusManager will consume
         Ctrl+Tab and Ctrl+Shift+Tab key strokes to transfer focus out of JTable or
         out of JTabbedPane.<br/>
         The property value can be adjusted by branding of <code>org.netbeans.core.windows</code> module.
         Or use -J-DNB.WinSys.WinSys.CtrlTabSwitching.In.JTable.Enabled=true command-line switch to override.
    </api><api name="netbeans.winsys.imageSource" type="export" category="private" group="systemproperty">
    Valid values are path to image in NB like "org/netbeans/core/resources/splash.gir". 
    It puts the specified image into the the emptied documents area.
    it is experimental now.
    <code>-J-Dnetbeans.winsys.imageSource=org/netbeans/core/resources/splash.gif</code>
</api><api name="netbeans.winsys.dndfade.on" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false".
    If it is "true" it paint faded feedback during DnD of windows. Keep in mind it makes
    some performance impact on DnD.
    It is experimental now.
    <code>-J-Dnetbeans.winsys.fade.on=true</code>
</api><api name="netbeans.winsys.disable_dnd" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false". 
    If it is "true" it disables DnD of windows.
    <code>-J-Dnetbeans.winsys.disable_dnd=true</code>
</api><api name="netbeans.winsys.allow.dock.anywhere" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false". 
    It allows user to move (e.g. using DnD) <code>TopComponent</code>S between editor(document) and view
    which is restricte otherwise.
    It is experimental now.
    <code>-J-Dnetbeans.winsys.allow.dock.anywhere=true</code>
</api><api name="netbeans.winsys.hideEmptyDocArea" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false". 
    If it is "true" it doesn't show empty documents area.
    <code>-J-Dnetbeans.winsys.hideEmptyDocArea=true</code>
</api><api name="netbeans.winsys.statusLine.in.menuBar" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false".
    If it is "true" it shows status line at the and of menu bar instead of the
    bottom of documents are (or main window).
    <code>-J-Dnetbeans.winsys.statusLine.in.menuBar=true</code>
</api><api name="netbeans.winsys.no_toolbars" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false".
    If it is "true" it hides all toolbars.
    <code>-J-Dnetbeans.winsys.no_toolbars=true</code>
</api><api name="netbeans.winsys.menu_bar.path" type="export" category="private" group="systemproperty">
    If this property is set its value must point to a file on the system file system
    that provides instance of type <code>org.openide.awt.MenuBar</code>. 
    This alternative menu bar will be used instead of the default one.
    <code>-J-Dnetbeans.winsys.menu_bar.path=foo/bar.instance</code>
</api><api name="netbeans.winsys.status_line.path" type="export" category="private" group="systemproperty">
    If this property is set its value must point to a file on the system file system
    that provides instance of type <code>javax.swing.JComponent</code>. 
    This alternative status line will be used instead of the default one.
    <code>-J-Dnetbeans.winsys.status_line.path=foo/bar.instance</code>
</api><api name="netbeans.winsys.no_help_in_dialogs" type="export" category="private" group="systemproperty">
    Valid values are "true" and "false". Default is "false". 
    If set to "true" the modal dialogs will be shown without the help button.
    <code>-J-Dnetbeans.winsys.no_help_in_dialogs=true</code>
</api><api name="netbeans.windows" type="export" category="private" group="property">
    This property was deleted and has no effect now, as sdi support was dropped
    and replaced by individual seperate windows. Please don't use, it's useless.
</api><api name="org.openide.windows.DummyWindowManager.VISIBLE" type="export" category="private" group="systemproperty">
    <p>
        If set to <code>false</code>, windows opened (e.g. <code>TopComponent.open</code>) using the
        dummy fallback window manager will not really be set to be visible. Useful for unit tests which
        must incidentally use the Window System API but for which actual display of windows is undesirable.
    </p>
</api><api name="tab_focus_fill_dark" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_focus_fill_dark")</code>
</api><api name="tab_focus_fill_bright" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_focus_fill_bright")</code>
</api><api name="tab_unsel_fill_dark" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_unsel_fill_dark")</code>
</api><api name="tab_unsel_fill_bright" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_unsel_fill_bright")</code>
</api><api name="tab_sel_fill" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_sel_fill")</code>
</api><api name="tab_sel_fill_bright" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_sel_fill_bright")</code>
</api><api name="tab_sel_fill_dark" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_sel_fill_dark")</code>
</api><api name="tab_border" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_border")</code>
</api><api name="tab_bottom_border" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_bottom_border")</code>
</api><api name="tab_sel_border" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_sel_border")</code>
</api><api name="workplace_fill" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("workplace_fill")</code>
</api><api name="tab_highlight_header" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_highlight_header")</code>
</api><api name="tab_highlight_header_fill" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("tab_highlight_header_fill")</code>
</api><api name="standard_border" type="export" category="private" group="javax.swing.UIManager">
    One of colors used in own tabs UI implementation.
    Usage example: To get color, call <code>javax.swing.UIManager.get("standard_border")</code>
</api><api name="org.netbeans.core.windows.view.ui.tabcontrol.BorderProvider" type="export" category="private" group="javax.swing.UIManager">
    Custom border management for tabbed containers can be achieved by implementing
    interface <code>org.netbeans.core.windows.view.ui.tabcontrol.BorderProvider</code>
    and putting instance into Swing's UIManager table under key with the same name 
    as interface has.
    Usage example: Provide BorderProviderImpl implementation and put it in table
    <code>javax.swing.UIManager.put("org.netbeans.core.windows.view.ui.tabcontrol.BorderProvider", borderProviderImpl)</code>
    during startup, before main window is shown.
</api><api name="org.netbeans.ui.actions.UI_ACTION_KEY_PRESS" type="export" category="friend" group="logger">
  There is a special support for notifying when an action is invoked by the
  <a href="org-openide-windows/org/openide/windows/TopComponent.html" shape="rect">TopComponent</a>'s
  key event handling code. The support is using <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/Logger.html" shape="rect">
  Logger.getLogger("org.netbeans.ui.actions")
  </a> and sents a <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">LogRecord</a>
  with message <code>UI_ACTION_KEY_PRESS</code>, 
  <code>FINER</code> <a href="http://download.oracle.com/javase/8/docs/api/java/util/logging/LogRecord.html" shape="rect">level</a>
  and paramerters:
  <ul>
      <li>{<b>0</b>} instance of the <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/KeyStroke.html" shape="rect">KeyStroke</a></li>
      <li>{<b>1</b>} toString of the <a href="http://download.oracle.com/javase/8/docs/api/javax/swing/KeyStroke.html" shape="rect">KeyStroke</a></li>
      <li>{<b>2</b>} instance of the action</li>
      <li>{<b>3</b>} class of the action</li>
      <li>{<b>4</b>} display name of the action</li>
  </ul>
  whenever such action is invoked. This message can then be consumed
  by enhanced UI logger that track what the user is going.
  </api><api name="DataFlavorDnDTopComponent" type="export" category="private" group="java">DataFlavor.javaJVMLocalObjectMimeType + "; class=org.openide.windows.TopComponent"</api><api name="DataFlavorDnDTopComponent.Cloneable" type="export" category="private" group="java">DataFlavor.javaJVMLocalObjectMimeType + "; class=org.openide.windows.TopComponent$Cloneable"</api><api name="DataFlavorDnDTopComponentArray" type="export" category="private" group="java">DataFlavor.javaJVMLocalObjectMimeType + "; class=org.netbeans.core.windows.dnd.TopComponentDragSupport$TopComponentArray"</api><api name="windowmanager-properties2_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/windowmanager-properties2_0.dtd" group="dtd"><samp>-//NetBeans//DTD Window Manager Properties 2.01//EN</samp></api><api name="mode-properties2_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/mode-properties2_0.dtd" group="dtd"><samp>-//NetBeans//DTD Mode Properties 2.0//EN</samp></api><api name="tc_ref2_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/tc_ref2_0.dtd" group="dtd"><samp>-//NetBeans//DTD Top Component in Mode Properties 2.0//EN</samp></api><api name="group-properties2_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/group-properties2_0.dtd" group="dtd"><samp>-//NetBeans//DTD Group Properties 2.0//EN</samp></api><api name="tc_group2_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/tc_group2_0.dtd" group="dtd"><samp>-//NetBeans//DTD Top Component in Group Properties 2.0//EN</samp></api><api name="sessionsettings-1_0.dtd" type="export" category="devel" url="http://www.netbeans.org/dtds/sessionsettings-1_0.dtd" group="dtd"><samp>-//NetBeans//DTD Session settings 1.0//EN</samp></api><api name="ModuleDataStructure" type="export" category="private" url="http://core.netbeans.org/windowsystem/changes.html#3.4.2" group="layer">Module folder structure under Windows2 directory </api><api name="LocalDataStructure" type="export" category="private" url="http://core.netbeans.org/windowsystem/changes.html#3.4.2" group="layer">Local folder structure under Windows2Local directory</api></module><module name="Deprecated, old search API" target="org-openidex-util/architecture-summary.html" stylesheet="prose.css" overviewlink="" footer=""><description>
  
    It allows other modules to define how the nodes they define should be
    searched, without depending on any concrete module containing the search
    feature.
  
 </description><deploy-dependencies>
  <p>
Nothing.
  </p>
 </deploy-dependencies><arch-usecases>
  <p>
    The SearchInfo API+SPI allows other modules to specify whether and how
    should nodes they define be searched.
  </p><p>
    The definition is represented by objects implementing interface
    <code>SearchInfo</code>. To enable searching on a custom node,
    a <code>SearchInfo</code> object must be added to the node's lookup.
    In most cases, there is no need to define own class implementing the
    interface - one can use factory methods of class
    <code>SearchInfoFactory</code>.
  </p><p>
    Example:
  </p><blockquote>
    <pre xml:space="preserve">import org.openide.util.lookup.Lookups;
  
public class MyNode extends AbstractNode {

    public MyNode(FileObject folder) {
        super( new MyNodeChildren(folder),
               Lookups.singleton(SearchInfoFactory.createSearchInfo(
                     folder,
                     true,
                     new FileObjectFilter[] {
                             SearchInfoFactory.VISIBILITY_FILTER
                     }) );
    }

    ...

}</pre>
  </blockquote>
  <p>
    One of the factory methods - <code>createSearchInfoBySubnodes(...)</code>
    - requires that a reference to the node itself. In this case, it is not
    possible to fully define the lookup in the <code>super(...)</code>
    statement of the constructor because a reference to the node is not
    available until the call of <code>super(...)</code> returns.
    In this case, a special technique must be used:
  </p>
  <blockquote>
    <pre xml:space="preserve">import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
  
public class MyNode extends AbstractNode {

    public MyNode() {
        this(new InstanceContent());
    }

    public MyNode(InstanceContent ic) {
        super(new AbstractLookup(ic));
        ic.add(SearchInfoFactory.createSearchInfoBySubnodes(this));
    }

    ...

}</pre>
  </blockquote>
   
   <api category="deprecated" group="java" name="deprecated-SearchAPI" type="export" url="org-openidex-util/index.html">
   defines interfaces <code>SearchInfo</code>, <code>FileObjectFilter</code>
   and a factory class <code>SearchInfoFactory</code>
   </api>
 </arch-usecases><api name="deprecated-SearchAPI" type="export" category="deprecated" url="org-openidex-util/index.html" group="java">
   defines interfaces <code>SearchInfo</code>, <code>FileObjectFilter</code>
   and a factory class <code>SearchInfoFactory</code>
   </api></module>
            </apis>
        