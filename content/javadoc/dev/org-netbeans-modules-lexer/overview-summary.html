<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Overview (Lexer)</title>
<link rel="stylesheet" type="text/css" href="javadoc.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (Lexer)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-files/index-1.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">org.netbeans.modules.lexer/2 1.66.0 1</div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">Lexer<br/><span style='font-style:normal; font-size:medium; font-weight:normal; background-color:#ffffff;'><a href='http://wiki.netbeans.org/API_Stability#Official' target='_blank'>Official</a></span></h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">
The lexer module defines
LexerAPI
providing access to sequence of tokens for various input sources.</div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Lexer table, listing packages, and an explanation">
<caption><span>Lexer</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="org/netbeans/api/lexer/package-summary.html">org.netbeans.api.lexer</a></td>
<td class="colLast">
<div class="block">The entrance point into Lexer API is
    <a href="org/netbeans/api/lexer/TokenHierarchy.html" title="class in org.netbeans.api.lexer"><code>TokenHierarchy</code></a> class with
    its static methods that provide its instance for the given input source.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="org/netbeans/spi/lexer/package-summary.html">org.netbeans.spi.lexer</a></td>
<td class="colLast">
<div class="block">The main abstract class in the Lexer SPI that must be implemented
    is <a href="org/netbeans/spi/lexer/LanguageHierarchy.html" title="class in org.netbeans.spi.lexer"><code>LanguageHierarchy</code></a> that mainly defines
    set of token ids and token categories for the new language
    and its <a href="org/netbeans/spi/lexer/Lexer.html" title="interface in org.netbeans.spi.lexer"><code>Lexer</code></a>.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block"><p>
The lexer module defines
LexerAPI
providing access to sequence of tokens for various input sources.
<br>
An <b>API entry point</b> is
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenHierarchy.html" shape="rect">TokenHierarchy</a>
class with its static methods that provide its instance for the given input source.

<h3>Input Sources</h3>

<p>

<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenHierarchy.html" shape="rect">TokenHierarchy</a>
    can be created for immutable input sources (
<a href="http://download.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" shape="rect">CharSequence</a>
    or
<a href="http://download.oracle.com/javase/8/docs/api/java/io/Reader.html" shape="rect">java.io.Reader</a>
    ) or for mutable input sources (typically 
<a href="http://download.oracle.com/javase/8/docs/api/javax/swing/text/Document.html" shape="rect">javax.swing.text.Document</a>
    ).
    <br>
    For mutable input source the lexer framework updates the tokens in the token hierarchy automatically
    with subsequent changes to the underlying text input.
    The tokens of the hierarchy always reflect the text of the input at the given time.
</p>


<h3>TokenSequence and Token</h3>

<p>

<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenHierarchy.html#tokenSequence--" shape="rect">TokenHierarchy.tokenSequence()</a>
   allows to iterate over a list of
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html" shape="rect">Token</a>
    instances.
    <br>
    The token carries a token identification
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenId.html" shape="rect">TokenId</a>
    (returned by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html#id--" shape="rect">Token.id()</a>
    ) and a text (aka token body) represented as
<a href="http://download.oracle.com/javase/8/docs/api/java/lang/CharSequence.html" shape="rect">CharSequence</a>
    (returned by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html#text--" shape="rect">Token.text()</a>
    ).
    <br>

<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenUtilities.html" shape="rect">TokenUtilities</a>
    contains many useful methods related to operations with the token's text such as
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenUtilities.html#equals-java.lang.CharSequence-java.lang.Object-" shape="rect">TokenUtilities.equals(CharSequence text, Object o)</a>,
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenUtilities.html#startsWith-java.lang.CharSequence-java.lang.CharSequence-" shape="rect">TokenUtilities.startsWith(CharSequence text, CharSequence prefix)</a>,
   etc.
    <br>
   It is also possible to debug the text of the token (replace special chars by escapes) by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenUtilities.html#debugText-java.lang.CharSequence-" shape="rect">TokenUtilities.equals(CharSequence text)</a>.
    <br>
    A typical token also carries offset of its occurrence in the input text.
</p>


<h3>Flyweight Tokens</h3>

<p>
    As there are many token occurrences where the token text is the same for all
    or many occurrences
    (e.g. java keywords, operators or a single-space whitespace) the memory consumption
    can be decreased considerably by allowing the creation of <b>flyweight token</b> instances
    i.e. just one token instance is used for all the token's occurrences
    in all the inputs.
    <br>
    Flyweight tokens can be determined by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html#isFlyweight--" shape="rect">Token.isFlyweight()</a>.
    <br>
    The flyweight tokens do not carry a valid offset (their internal offset is -1).
    <br>
    Therefore
 <a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenSequence.html" shape="rect">TokenSequence</a>
    is used for iteration through the tokens (instead of a regular iterator) and it provides 
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenSequence.html#offset--" shape="rect">TokenSequence.offset()</a>
    which returns the proper offset even when positioned over a flyweight token.
    <br>
    When holding a reference to the token's instance its offset can also be determined by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html#offset-org.netbeans.api.lexer.TokenHierarchy-" shape="rect">Token.offset(TokenHierarchy tokenHierarchy)</a>.
    The <code>tokenHierarchy</code> parameter should be always <code>null</code> and it will be used
    for the token hierarchy snapshot support in future releases.
    <br>
    For flyweight tokens the 
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html#offset-org.netbeans.api.lexer.TokenHierarchy-" shape="rect">Token.offset(TokenHierarchy tokenHierarchy)</a>
    returns -1 and for regular tokens it gives the same value like 
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenSequence.html#offset--" shape="rect">TokenSequence.offset()</a>.
</p>


<p>
    There may be applications where the flyweight tokens use could be problematic.
    For example if a parser would like to use token instances
    in a parse tree nodes to determine the nodes' boundaries then the flyweight tokens
    would always return offset -1 so the positions of the parse tree nodes
    could not generally be determined from the tokens only.
    <br>
    Therefore there is a possibility to de-flyweight a token by using
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenSequence.html#offsetToken--" shape="rect">TokenSequence.offsetToken()</a>
    which checks the current token
    and if it's flyweight then it replaces it with a non-flyweight token instance
    with a valid offset and with the same properties as the original flyweight token.
</p>


<h3>TokenId and Language</h3>

<p>
    Token is identified by its id represented by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenId.html" shape="rect">TokenId</a>
    interface. Token ids for a language are typically implemented as java enums (extensions of
<a href="http://download.oracle.com/javase/8/docs/api/java/lang/Enum.html" shape="rect">Enum</a>
    ) but it's not mandatory.
    <br>
    All token ids for the given language are described by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Language.html" shape="rect">Language</a>.
    <br>
    Each token id may belong
    to one or more token categories that allow to better operate
    tokens of the same type (e.g. keywords or operators).
    <br>
    Each token id may define its primary category
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenId.html#primaryCategory--" shape="rect">TokenId.primaryCategory()</a>
    and
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageHierarchy.html#createTokenCategories--" shape="rect">LanguageHierarchy.createTokenCategories()</a>
    may provide additional categories for the token ids for the given language.
    <br>
    Each language description has a mandatory mime-type specification
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Language.html#mimeType--" shape="rect">Language.mimeType()</a>
    
<br>
    Although it's a bit non-related information it brings many benefits
    because with the mime-type the language can be accompanied
    with an arbitrary sort of settings (e.g. syntax coloring information etc.).
</p>


<h3>LanguageHierarchy, Lexer, LexerInput and TokenFactory</h3>

<p>
    SPI providers wishing to provide a
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Language.html" shape="rect">Language</a>
    first need to define its SPI counterpart
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageHierarchy.html" shape="rect">LanguageHierarchy</a>.
    It mainly needs to define token ids in
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageHierarchy.html#createTokenIds--" shape="rect">LanguageHierarchy.createTokenIds()</a>
    and lexer in
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageHierarchy.html#createLexer-org.netbeans.spi.lexer.LexerRestartInfo-" shape="rect">
    LanguageHierarchy.createLexer(LexerInput lexerInput, TokenFactory tokenFactory, Object state, LanguagePath languagePath, InputAttributes inputAttributes)</a>.
    <br>

<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/Lexer.html" shape="rect">Lexer</a>
    reads characters from
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LexerInput.html" shape="rect">LexerInput</a>
    and breaks the text into tokens.
    <br>
    Tokens are produced by using methods of
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/TokenFactory.html" shape="rect">TokenFactory</a>.
    <br>
    As a per-token memory consumption is critical the
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Token.html" shape="rect">Token</a>
    does not have any counterpart in SPI. However the framework prevents instantiation
    of any other token classes except those contained in the lexer module's implementation.
</p>



<h3>Language Embedding</h3>

<p>
    With language embedding the flat list of tokens becomes in fact a tree-like hierarchy
    represented by the
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenHierarchy.html" shape="rect">TokenHierarchy</a>
    class. Each token can potentially be broken into a sequence of embedded tokens.
    <br>The 
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenSequence.html#embedded--" shape="rect">TokenSequence.embedded()</a>
    method can be called to obtain the embedded tokens (when positioned on the branch token).
    <br>
    There are two ways of specifying what language is embedded in a token. The language
    can either be specified explicitly (hardcoded) in the
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageHierarchy.html#embedding-org.netbeans.api.lexer.Token-org.netbeans.api.lexer.LanguagePath-org.netbeans.api.lexer.InputAttributes-" shape="rect">LanguageHierarchy.embedding()</a>
    method or there can be a
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageProvider.html" shape="rect">LanguageProvider</a>
    registered in the default Lookup, which will create a
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/Language.html" shape="rect">Language</a>
    for the embedded language.
    <br>
    There is no limit on the depth of a language hierarchy and there can be as many embedded languages
    as needed.
    <br>
    In SPI the language embedding is represented by
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/spi/lexer/LanguageEmbedding.html" shape="rect">LanguageEmbedding</a>.
</p>


</p>
<h3>What is New (see <a href="apichanges.html">all changes</a>)?</h3>
<ul>

         
<!--Search for dates that are later or equal to 1997-09-01 in
          .-->
<!--Checking date 2008-5-28 with count of newer 0--><!--year ok-->
<li>May 28 '08 <a href="apichanges.html#Joined-sections-Lexing">Joined Sections Lexing</a>
<p>
        
<p>
            Embeddings that request input sections to be joined before lexing
            are now lexed as a single section.
            <br>
            
<code>Token.isRemoved()</code> was added to check whether a particular token
            is still present in token hierarchy or whether it was removed as part of a modification.
        </p>
      
</p>
</li>
<!--Checking date 2007-11-5 with count of newer 1--><!--year ok-->
<li>Nov 5 '07 <a href="apichanges.html#Lexer-API-Cleanup">Lexer API Cleanup</a>
<p>
        
<p>
            Support for token hierarchy snapshots and generic character preprocessing
            was removed from the API and SPI since there were no usecases yet
            and it should be possible to add the functionality later in a backward compatible way.
            Some more changes regarding generification etc. were performed.
        </p>
      
</p>
</li>
<!--Checking date 2007-11-3 with count of newer 2--><!--year ok-->
<li>Nov 3 '07 <a href="apichanges.html#LexerInput.integerState-removed">Removing LexerInput.integerState</a>
<p>
        
<p>
            
<code>LexerInput.integerState()</code> was removed.
        </p>
      
</p>
</li>
<!--Checking date 2007-10-5 with count of newer 3--><!--year ok-->
<li>Oct 5 '07 <a href="apichanges.html#TokenSequence.removeEmbedding-added">Possibility to remove a previously created custom embedding</a>
<p>
        
<p>
            
<code>TokenSequence.removeEmbedding()</code> was added as counterpart
            to <code>TokenSequence.createEmbedding()</code>.
            <br>
            Also <code>TokenSequence.isValid()</code> was added to check whether
            the token sequence can be used for iteration (no modifications
            of the underlying input in the meantime).
        </p>
      
</p>
</li>
<!--Checking date 2007-8-30 with count of newer 4--><!--year ok-->
<li>Aug 30 '07 <a href="apichanges.html#embedding.joinSections.support">Support for embeddings that join sections</a>
<p>
        
<p>
            Joining sections embeddings now supported and some minor changes
            were introduced like adding <code>LanguagePath.parent()</code>.
            Some is* methods with trivial implementations were removed from LanguagePath.
            <code>TokenChange.embeddedChange(Language)</code> was removed because
            there might be multiple such changes and they can be gathered
            with existing methods.
        </p>
      
</p>
</li>
<!--Checking date 2007-8-17 with count of newer 5--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-6-5 with count of newer 6--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-5-16 with count of newer 7--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-4-27 with count of newer 8--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-4-13 with count of newer 9--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-3-23 with count of newer 10--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-3-1 with count of newer 11--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2007-1-16 with count of newer 12--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-12-7 with count of newer 13--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-11-23 with count of newer 14--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-10-18 with count of newer 15--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-10-12 with count of newer 16--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-10-11 with count of newer 17--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-9-18 with count of newer 18--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-9-14 with count of newer 19--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-8-30 with count of newer 20--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2006-5-5 with count of newer 21--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2003-5-16 with count of newer 22--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2002-9-20 with count of newer 23--><!--Skipped as the amount of changes is too big-->
<!--Checking date 2002-9-20 with count of newer 23--><!--Skipped as the amount of changes is too big-->
</ul>
<h3>Use Cases</h3>
<answer id="arch-usecases">

<!-- API Usecases - API Usecases - API Usecases - API Usecases - API Usecases -->


<h1>
API Usecases
</h1>


<h3>
Obtaining of token hierarchy for various inputs.
</h3>
The
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/TokenHierarchy.html" shape="rect">TokenHierarchy</a>
is an entry point into Lexer API
and it represents the given input in terms of tokens.
<pre xml:space="preserve">
    String text = "public void m() { }";
    TokenHierarchy hi = TokenHierarchy.create(text, JavaLanguage.description());
</pre>


<br>
Token hierarchy for swing documents must be operated under read/write document's lock.
<pre xml:space="preserve">
    document.readLock();
    try {
        TokenHierarchy hi = TokenHierarchy.get(document);
        ... // explore tokens etc.
    } finally {
        document.readUnlock();
    }
</pre>



<h3>
Obtaining and iterating token sequence over particular swing document from the given offset.
</h3>
The tokens cover the whole document and it's possible to iterate either forward or backward.
<br>
Each token can contain language embedding that can also be explored by the token sequence.
The language embedding covers the whole text of the token (there can be few characters
skipped at the begining an end of the branch token).

<pre xml:space="preserve">
    document.readLock();
    try {
        TokenHierarchy hi = TokenHierarchy.get(document);
        TokenSequence ts = hi.tokenSequence();
        // If necessary move ts to the requested offset
        ts.move(offset);
        while (ts.moveNext()) {
            Token t = ts.token();
            if (t.id() == ...) { ... }
            if (TokenUtilities.equals(t.text(), "mytext")) { ... }
            if (ts.offset() == ...) { ... }

            // Possibly retrieve embedded token sequence
            TokenSequence embedded = ts.embedded();
            if (embedded != null) { // Token has a valid language embedding
                ...
            }
        }
    } finally {
        document.readUnlock();
    }
</pre>


<br>
Typical clients:
<ul>
    
<li>Editor's painting code doing syntax coloring
        <code>org.netbeans.modules.lexer.editorbridge.LexerLayer</code> in <i>lexer/editorbridge</i> module.
    </li>  
    
<li>Brace matching code searching for matching brace in forward/backward direction.</li>
    
<li>Code completion's quick check whether caret is located inside comment token.</li>
    
<li>Parser constructing a parse tree iterating through the tokens in forward direction.</li>

</ul>


<h3>
Using language path of the token sequence
</h3>
For the given token sequence the client may check whether it's a top level
token sequence in the token hierarchy or whether it's embedded at which level
it's embedded and what are the parent languages.
<br>
Each token can contain language embedding that can also be explored by the token sequence.
The language embedding covers the whole text of the token (there can be few characters
skipped at the begining an end of the branch token).

<pre xml:space="preserve">
    TokenSequence ts = ...
    LanguagePath lp = ts.languagePath();
    if (lp.size() &gt; 1) { ... } // This is embedded token sequence
    if (lp.topLanguage() == JavaLanguage.description()) { ... } // top-level language of the token hierarchy
    String mimePath = lp.mimePath();
    Object setting-value = some-settings.getSetting(mimePath, setting-name);
</pre>



<h3>
Extra information about the input
</h3>
The
<a href="http://netbeans.apache.org/javadoc/dev/org-netbeans-modules-lexer/org/netbeans/api/lexer/InputAttributes.html" shape="rect">InputAttributes</a>
class may carry extra information about the text input on which the token hierarchy
is being created. For example there can be information about the version of the language
that the input represents and the lexer may be written to recognize multiple versions
of the language. It should suffice to do the versioning through a simple integer:
<pre xml:space="preserve">
public class MyLexer implements Lexer&lt;MyTokenId&gt; {
    
    private final int version;
    
    ...
    
    public MyLexer(LexerInput input, TokenFactory&lt;MyTokenId&gt; tokenFactory, Object state,
    LanguagePath languagePath, InputAttributes inputAttributes) {
        ...
        
        Integer ver = (inputAttributes != null)
                ? (Integer)inputAttributes.getValue(languagePath, "version")
                : null;
        this.version = (ver != null) ? ver.intValue() : 1; // Use version 1 if not specified explicitly
    }
    
    public Token&lt;MyTokenId&gt; nextToken() {
        ...
        if (recognized-assert-keyword) {
            return (version &gt;= 4) { // "assert" recognized as keyword since version 4
                ? keyword(MyTokenId.ASSERT)
                : identifier();
        }
        ...
    }
    ...
}
</pre>

The client will then use the following code:
<pre xml:space="preserve">
    InputAttributes attrs = new InputAttributes();
    // The "true" means global value i.e. for any occurrence of the MyLanguage including embeddings
    attrs.setValue(MyLanguage.description(), "version", Integer.valueOf(3), true);
    TokenHierarchy hi = TokenHierarchy.create(text, false, SimpleLanguage.description(), null, attrs);
    ...
</pre>



<h3>
Filtering out unnecessary tokens
</h3>
Filtering is only possible for immutable inputs (e.g. String or Reader).
<pre xml:space="preserve">
    Set&lt;MyTokenId&gt; skipIds = EnumSet.of(MyTokenId.COMMENT, MyTokenId.WHITESPACE);
    TokenHierarchy tokenHierarchy = TokenHierarchy.create(inputText, false,
        MyLanguage.description(), skipIds, null);
    ...
</pre>


<br>
Typical clients:
<ul>
    
<li>Parser constructing a parse tree. It is not interested
        in the comment and whitespace tokens so these tokens do not need
        to be constructed at all.
    </li>

</ul>


<!-- SPI Usecases - SPI Usecases - SPI Usecases - SPI Usecases - SPI Usecases -->


<h1>
SPI Usecases
</h1>


<h3>
Providing language description and lexer.
</h3>

Token ids should be defined as enums. For example
<code>org.netbeans.lib.lexer.test.simple.SimpleTokenId</code> can be copied
or the following example from
<code>org.netbeans.modules.lexer.editorbridge.calc.lang.CalcTokenId</code>.
<br>
The static <code>language()</code> method returns the language describing the token ids.
<pre xml:space="preserve">
public enum CalcTokenId implements TokenId {

    WHITESPACE(null, "whitespace"),
    SL_COMMENT(null, "comment"),
    ML_COMMENT(null, "comment"),
    E("e", "keyword"),
    PI("pi", "keyword"),
    IDENTIFIER(null, null),
    INT_LITERAL(null, "number"),
    FLOAT_LITERAL(null, "number"),
    PLUS("+", "operator"),
    MINUS("-", "operator"),
    STAR("*", "operator"),
    SLASH("/", "operator"),
    LPAREN("(", "separator"),
    RPAREN(")", "separator"),
    ERROR(null, "error"),
    ML_COMMENT_INCOMPLETE(null, "comment");


    private final String fixedText;

    private final String primaryCategory;

    private CalcTokenId(String fixedText, String primaryCategory) {
        this.fixedText = fixedText;
        this.primaryCategory = primaryCategory;
    }
    
    public String fixedText() {
        return fixedText;
    }

    public String primaryCategory() {
        return primaryCategory;
    }

    private static final Language&lt;CalcTokenId&gt; language = new LanguageHierarchy&lt;CalcTokenId&gt;() {
        <code>@Override</code>
        protected Collection&lt;CalcTokenId&gt; createTokenIds() {
            return EnumSet.allOf(CalcTokenId.class);
        }
        
        <code>@Override</code>
        protected Map&lt;String,Collection&lt;CalcTokenId&gt;&gt; createTokenCategories() {
            Map&lt;String,Collection&lt;CalcTokenId&gt;&gt; cats = new HashMap&lt;String,Collection&lt;CalcTokenId&gt;&gt;();

            // Incomplete literals 
            cats.put("incomplete", EnumSet.of(CalcTokenId.ML_COMMENT_INCOMPLETE));
            // Additional literals being a lexical error
            cats.put("error", EnumSet.of(CalcTokenId.ML_COMMENT_INCOMPLETE));
            
            return cats;
        }

        <code>@Override</code>
        protected Lexer&lt;CalcTokenId&gt; createLexer(LexerRestartInfo&lt;CalcTokenId&gt; info) {
            return new CalcLexer(info);
        }

        <code>@Override</code>
        protected String mimeType() {
            return "text/x-calc";
        }
        
    }.language();

    public static final Language&lt;CalcTokenId&gt; language() {
        return language;
    }

}
</pre>

Note that it is not needed to publish the underlying <code>LanguageHierarchy</code> extension.

<br>
Lexer example:
<pre xml:space="preserve">
public final class CalcLexer implements Lexer&lt;CalcTokenId&gt; {

    private static final int EOF = LexerInput.EOF;

    private static final Map&lt;String,CalcTokenId&gt; keywords = new HashMap&lt;String,CalcTokenId&gt;();
    static {
        keywords.put(CalcTokenId.E.fixedText(), CalcTokenId.E);
        keywords.put(CalcTokenId.PI.fixedText(), CalcTokenId.PI);
    }
    
    private LexerInput input;
    
    private TokenFactory&lt;CalcTokenId&gt; tokenFactory;

    CalcLexer(LexerRestartInfo&lt;CalcTokenId&gt; info) {
        this.input = info.input();
        this.tokenFactory = info.tokenFactory();
        assert (info.state() == null); // passed argument always null
    }
    
    public Token&lt;CalcTokenId&gt; nextToken() {
        while (true) {
            int ch = input.read();
            switch (ch) {
                case '+':
                    return token(CalcTokenId.PLUS);

                case '-':
                    return token(CalcTokenId.MINUS);

                case '*':
                    return token(CalcTokenId.STAR);

                case '/':
                    switch (input.read()) {
                        case '/': // in single-line comment
                            while (true)
                                switch (input.read()) {
                                    case '\r': input.consumeNewline();
                                    case '\n':
                                    case EOF:
                                        return token(CalcTokenId.SL_COMMENT);
                                }
                        case '*': // in multi-line comment
                            while (true) {
                                ch = input.read();
                                while (ch == '*') {
                                    ch = input.read();
                                    if (ch == '/')
                                        return token(CalcTokenId.ML_COMMENT);
                                    else if (ch == EOF)
                                        return token(CalcTokenId.ML_COMMENT_INCOMPLETE);
                                }
                                if (ch == EOF)
                                    return token(CalcTokenId.ML_COMMENT_INCOMPLETE);
                            }
                    }
                    input.backup(1);
                    return token(CalcTokenId.SLASH);

                case '(':
                    return token(CalcTokenId.LPAREN);

                case ')':
                    return token(CalcTokenId.RPAREN);

                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                case '.':
                    return finishIntOrFloatLiteral(ch);

                case EOF:
                    return null;

                default:
                    if (Character.isWhitespace((char)ch)) {
                        ch = input.read();
                        while (ch != EOF &amp;&amp; Character.isWhitespace((char)ch)) {
                            ch = input.read();
                        }
                        input.backup(1);
                        return token(CalcTokenId.WHITESPACE);
                    }

                    if (Character.isLetter((char)ch)) { // identifier or keyword
                        while (true) {
                            if (ch == EOF || !Character.isLetter((char)ch)) {
                                input.backup(1); // backup the extra char (or EOF)
                                // Check for keywords
                                CalcTokenId id = keywords.get(input.readText());
                                if (id == null) {
                                    id = CalcTokenId.IDENTIFIER;
                                }
                                return token(id);
                            }
                            ch = input.read(); // read next char
                        }
                    }

                    return token(CalcTokenId.ERROR);
            }
        }
    }

    public Object state() {
        return null;
    }

    private Token&lt;CalcTokenId&gt; finishIntOrFloatLiteral(int ch) {
        boolean floatLiteral = false;
        boolean inExponent = false;
        while (true) {
            switch (ch) {
                case '.':
                    if (floatLiteral) {
                        return token(CalcTokenId.FLOAT_LITERAL);
                    } else {
                        floatLiteral = true;
                    }
                    break;
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case 'e': case 'E': // exponent part
                    if (inExponent) {
                        return token(CalcTokenId.FLOAT_LITERAL);
                    } else {
                        floatLiteral = true;
                        inExponent = true;
                    }
                    break;
                default:
                    input.backup(1);
                    return token(floatLiteral ? CalcTokenId.FLOAT_LITERAL
                            : CalcTokenId.INT_LITERAL);
            }
            ch = input.read();
        }
    }
    
    private Token&lt;CalcTokenId&gt; token(CalcTokenId id) {
        return (id.fixedText() != null)
            ? tokenFactory.getFlyweightToken(id, id.fixedText())
            : tokenFactory.createToken(id);
    }

}
</pre>

<p>
    The classes containing token ids and the language description should be
    part of an API. The lexer should only be part of the implementation.
</p>




<h3>
Providing language embedding.
</h3>

The embedding may be provided statically
in the <code>LanguageHierarchy.embedding()</code>
see e.g. <code>org.netbeans.lib.lexer.test.simple.SimpleLanguage</code>.

<p>
    Or it may be provided dynamically through the xml layer
    by using a file in "Editors/language-mime-type/languagesEmbeddingMap" folder
    named by the token-id's name containing target mime-type and initial and ending skip lengths:
</p>

<pre xml:space="preserve">
    &lt;folder name="Editors"&gt;
        &lt;folder name="text"&gt;
            &lt;folder name="x-outer-language"&gt;
                &lt;folder name="languagesEmbeddingMap"&gt;
                    &lt;file name="WORD"&gt;&lt;![CDATA[text/x-inner-language,1,2]]&gt;
                    &lt;/file&gt;
                &lt;/folder&gt;
            &lt;/folder&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;
</pre>


</answer>
<h3>Exported Interfaces</h3>
          
                This table lists all of the module exported APIs 
                with 
                defined stability classifications. It is generated
                based on answers to questions about the architecture 
                of the module. <a href="architecture-summary.html">Read them all</a>...

                
                <a name="group-java">
<h5>Group of java interfaces</h5>
</a>
<table cellpadding="1" cellspacing="0" border="0" class="tablebg" width="100%">
<tr>
<td>
<table border="0" cellpadding="3" cellspacing="1" width="100%">
<tr class="tablersh">
<td align="CENTER" width="25%"><span class="titlectable">Interface Name</span></td><td align="CENTER" width="10%"><span class="titlectable">In/Out</span></td><td align="CENTER" width="10%"><span class="titlectable">Stability</span></td><td align="CENTER"><span class="titlectable">Specified in What Document?</span></td>
</tr>
<tr class="tabler">
<td>LexerAPI</td><td>Exported</td><td><a href="http://wiki.netbeans.org/API_Stability#Official">Official</a></td><td><a name="java-LexerAPI"></a></td>
</tr>
</table>
</td>
</tr>
</table>
<p></p>
<a name="group-logger">
<h5>Group of logger interfaces</h5>
</a>
<table cellpadding="1" cellspacing="0" border="0" class="tablebg" width="100%">
<tr>
<td>
<table border="0" cellpadding="3" cellspacing="1" width="100%">
<tr class="tablersh">
<td align="CENTER" width="25%"><span class="titlectable">Interface Name</span></td><td align="CENTER" width="10%"><span class="titlectable">In/Out</span></td><td align="CENTER" width="10%"><span class="titlectable">Stability</span></td><td align="CENTER"><span class="titlectable">Specified in What Document?</span></td>
</tr>
<tr class="tabler">
<td>org.netbeans.lib.lexer.TokenHierarchyOperation</td><td>Exported</td><td><a href="http://wiki.netbeans.org/API_Stability#Friend">Friend</a></td><td><a name="logger-org.netbeans.lib.lexer.TokenHierarchyOperation">
<p></p>
        
<code>FINE</code> level lists lexer changes made in tokens both at the root level
        and embedded levels of the token hierarchy after each document modification.
        <br>
        
<code>FINER</code> level in addition will also check the whole token hierarchy
         for internal consistency after each modification.
    <p></p>
</a></td>
</tr>
<tr class="tabler">
<td>org.netbeans.lib.lexer.TokenList</td><td>Exported</td><td><a href="http://wiki.netbeans.org/API_Stability#Friend">Friend</a></td><td><a name="logger-org.netbeans.lib.lexer.TokenList">
<p></p>
        
<code>FINE</code> level forces lexer to perform more thorough and strict checks
        in certain situations so this is useful mainly for tests.
        Lookahead and state information is generated even for batch-lexed inputs which allows
        easier checking of incremental algorithm correctness (fixing of token list after modification).
        There are also some additional checks performed
        that should verify correctness of the framework and the SPI implementation
        classes being used (for example when flyweight tokens are created the text
        passed to the token factory is compared to the text in the lexer input).
    <p></p>
</a></td>
</tr>
</table>
</td>
</tr>
</table>
<p></p>
<h3>Implementation Details</h3>
<h5>Where are the sources for the module?</h5>
  
<p>
<p>
            The sources for the module are in the
            <a href="http://hg.netbeans.org/" shape="rect">NetBeans Mercurial repositories</a>.
        </p>
</p>

<h5>What do other modules need to do to declare a dependency on this one, in addition to or instead of a plain module dependency?</h5>

<pre xml:space="preserve">
OpenIDE-Module-Module-Dependencies: org.netbeans.modules.lexer/2 &gt; @SPECIFICATION-VERSION@
</pre>

<p>
                Read more about the implementation in the <a href="architecture-summary.html">answers to 
                architecture questions</a>.
            </p></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-files/index-1.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">org.netbeans.modules.lexer/2 1.66.0 1</div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><span class="footnote"></span><!-- See javadoc.css for timestamp information --></small></p>
</body>
</html>
